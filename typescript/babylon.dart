@JS() library typescript.babylon ; import "package:js/js.dart" ;
 import "package:func/func.dart" ;
 import "dart:typed_data" show ByteBuffer, Uint8List, Float32List, Int32List, Uint32List, Uint16List, TypedData ;
 import "dart:html" show HttpRequest, Event, HtmlElement, CanvasElement, ImageElement, VideoElement, KeyboardEvent, ProgressEvent, File, Blob, Worker, DeviceOrientationEvent, FocusEvent, ButtonElement, GamepadButton, CanvasRenderingContext2D, Window, Document, MouseEvent, Navigator, Screen, EventTarget, Gamepad ;
 import "dart:web_audio" show AudioNode, GainNode, AudioContext, AudioBuffer ;
 import "dart:web_gl" show ContextAttributes, Program, Buffer, Framebuffer, RenderingContext, UniformLocation, Texture, ContextEvent, Renderbuffer ;
 import "dart:math" show Rectangle ;

// Module babylonjs
 /* WARNING: export assignment not yet supported. */
 
// End module babylonjs
 
// Module BABYLON
 /// Set of assets to keep when moving a scene into an asset container.
 @JS("BABYLON.KeepAssets" ) class KeepAssets { // @Ignore
 KeepAssets .fakeConstructor$() ;
 /// Cameras to keep.
 external List<Camera> get cameras; external set cameras(List<Camera> v);
 /// Lights to keep.
 external List<Light> get lights; external set lights(List<Light> v);
 /// Meshes to keep.
 external List<AbstractMesh> get meshes; external set meshes(List<AbstractMesh> v);
 /// Skeletons to keep.
 external List<Skeleton> get skeletons; external set skeletons(List<Skeleton> v);
 /// ParticleSystems to keep.
 external List<IParticleSystem> get particleSystems; external set particleSystems(List<IParticleSystem> v);
 /// Animations to keep.
 external List<Animation> get animations; external set animations(List<Animation> v);
 /// AnimationGroups to keep.
 external List<AnimationGroup> get animationGroups; external set animationGroups(List<AnimationGroup> v);
 /// MultiMaterials to keep.
 external List<MultiMaterial> get multiMaterials; external set multiMaterials(List<MultiMaterial> v);
 /// Materials to keep.
 external List<Material> get materials; external set materials(List<Material> v);
 /// MorphTargetManagers to keep.
 external List<MorphTargetManager> get morphTargetManagers; external set morphTargetManagers(List<MorphTargetManager> v);
 /// Geometries to keep.
 external List<Geometry> get geometries; external set geometries(List<Geometry> v);
 /// TransformNodes to keep.
 external List<TransformNode> get transformNodes; external set transformNodes(List<TransformNode> v);
 /// LensFlareSystems to keep.
 external List<LensFlareSystem> get lensFlareSystems; external set lensFlareSystems(List<LensFlareSystem> v);
 /// ShadowGenerators to keep.
 external List<ShadowGenerator> get shadowGenerators; external set shadowGenerators(List<ShadowGenerator> v);
 /// ActionManagers to keep.
 external List<ActionManager> get actionManagers; external set actionManagers(List<ActionManager> v);
 /// Sounds to keep.
 external List<Sound> get sounds; external set sounds(List<Sound> v);
 /// Textures to keep.
 external List<Texture> get textures; external set textures(List<Texture> v);
 /// Effect layers to keep.
 external List<EffectLayer> get effectLayers; external set effectLayers(List<EffectLayer> v); }

 /// Container with a set of assets that can be added or removed from a scene.
 @JS("BABYLON.AssetContainer" ) class AssetContainer { // @Ignore
 AssetContainer .fakeConstructor$() ;
 /// The scene the AssetContainer belongs to.
 external Scene get scene; external set scene(Scene v);
 /// Cameras populated in the container.
 external List<Camera> get cameras; external set cameras(List<Camera> v);
 /// Lights populated in the container.
 external List<Light> get lights; external set lights(List<Light> v);
 /// Meshes populated in the container.
 external List<AbstractMesh> get meshes; external set meshes(List<AbstractMesh> v);
 /// Skeletons populated in the container.
 external List<Skeleton> get skeletons; external set skeletons(List<Skeleton> v);
 /// ParticleSystems populated in the container.
 external List<IParticleSystem> get particleSystems; external set particleSystems(List<IParticleSystem> v);
 /// Animations populated in the container.
 external List<Animation> get animations; external set animations(List<Animation> v);
 /// AnimationGroups populated in the container.
 external List<AnimationGroup> get animationGroups; external set animationGroups(List<AnimationGroup> v);
 /// MultiMaterials populated in the container.
 external List<MultiMaterial> get multiMaterials; external set multiMaterials(List<MultiMaterial> v);
 /// Materials populated in the container.
 external List<Material> get materials; external set materials(List<Material> v);
 /// MorphTargetManagers populated in the container.
 external List<MorphTargetManager> get morphTargetManagers; external set morphTargetManagers(List<MorphTargetManager> v);
 /// Geometries populated in the container.
 external List<Geometry> get geometries; external set geometries(List<Geometry> v);
 /// TransformNodes populated in the container.
 external List<TransformNode> get transformNodes; external set transformNodes(List<TransformNode> v);
 /// LensFlareSystems populated in the container.
 external List<LensFlareSystem> get lensFlareSystems; external set lensFlareSystems(List<LensFlareSystem> v);
 /// ShadowGenerators populated in the container.
 external List<ShadowGenerator> get shadowGenerators; external set shadowGenerators(List<ShadowGenerator> v);
 /// ActionManagers populated in the container.
 external List<ActionManager> get actionManagers; external set actionManagers(List<ActionManager> v);
 /// Sounds populated in the container.
 external List<Sound> get sounds; external set sounds(List<Sound> v);
 /// Textures populated in the container.
 external List<Texture> get textures; external set textures(List<Texture> v);
 /// Effect layers populated in the container.
 external List<EffectLayer> get effectLayers; external set effectLayers(List<EffectLayer> v);
 /// Instantiates an AssetContainer.
 external factory AssetContainer(Scene scene);
 /// Adds all the assets from the container to the scene.
 external void addAllToScene();
 /// Removes all the assets in the container from the scene
 external void removeAllFromScene(); external JS$_moveAssets /*<T>*/(sourceAssets, targetAssets, keepAssets);
 /// Removes all the assets contained in the scene and adds them to the container.
 external void moveAllFromScene([KeepAssets keepAssets]); }

 /// Node is the basic class for all scene objects (Mesh, Light Camera).
 @JS("BABYLON.Node" ) class Node { // @Ignore
 Node .fakeConstructor$() ;
 /// Gets or sets the name of the node
 external String get name; external set name(String v);
 /// Gets or sets the id of the node
 external String get id; external set id(String v);
 /// Gets or sets the unique id of the node
 external num get uniqueId; external set uniqueId(num v);
 /// Gets or sets a string used to store user defined state for the node
 external String get state; external set state(String v);
 /// Gets or sets an object used to store user defined information for the node
 external dynamic get metadata; external set metadata(dynamic v);
 /// Gets or sets a boolean used to define if the node must be serialized
 external bool get doNotSerialize; external set doNotSerialize(bool v);
 /// @hidden
 external bool get JS$_isDisposed; external set JS$_isDisposed(bool v);
 /// Gets a list of Animations associated with the node
 external List<Animation> get animations; external set animations(List<Animation> v); external get JS$_ranges; external set JS$_ranges(v);
 /// Callback raised when the node is ready to be used
 external VoidFunc1<Node> get onReady; external set onReady(VoidFunc1<Node> v); external get JS$_isEnabled; external set JS$_isEnabled(v); external get JS$_isReady; external set JS$_isReady(v);
 /// @hidden
 external num get JS$_currentRenderId; external set JS$_currentRenderId(num v); external get JS$_parentRenderId; external set JS$_parentRenderId(v); external num get JS$_childRenderId; external set JS$_childRenderId(num v);
 /// @hidden
 external String/*String|Null*/ get JS$_waitingParentId; external set JS$_waitingParentId(String/*String|Null*/ v); external get JS$_scene; external set JS$_scene(v);
 /// @hidden
 external dynamic get JS$_cache; external set JS$_cache(dynamic v); external get JS$_parentNode; external set JS$_parentNode(v); external get JS$_children; external set JS$_children(v);
 /// Gets a boolean indicating if the node has been disposed
 external bool isDisposed();
 /// Gets or sets the parent of the node
 external Node/*Node|Null*/ get parent; external set parent(Node/*Node|Null*/ v); external get JS$_animationPropertiesOverride; external set JS$_animationPropertiesOverride(v);
 /// Gets or sets the animation properties override
 external AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ get animationPropertiesOverride; external set animationPropertiesOverride(AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ v);
 /// Gets a string idenfifying the name of the class
 external String getClassName();
 /// An event triggered when the mesh is disposed
 external Observable<Node> get onDisposeObservable; external set onDisposeObservable(Observable<Node> v); external get JS$_onDisposeObserver; external set JS$_onDisposeObserver(v);
 /// Sets a callback that will be raised when the node will be disposed
 external VoidFunc0 get onDispose; external set onDispose(VoidFunc0 v);
 /// Creates a new Node
 external factory Node(String name, [Scene/*Scene|Null*/ scene]);
 /// Gets the scene of the node
 external Scene getScene();
 /// Gets the engine of the node
 external Engine getEngine(); external get JS$_behaviors; external set JS$_behaviors(v);
 /// Attach a behavior to the node
 /// @see http://doc.babylonjs.com/features/behaviour
 external Node addBehavior(Behavior<Node> behavior);
 /// Remove an attached behavior
 /// @see http://doc.babylonjs.com/features/behaviour
 external Node removeBehavior(Behavior<Node> behavior);
 /// Gets the list of attached behaviors
 /// @see http://doc.babylonjs.com/features/behaviour
 external List<Behavior<Node>> get behaviors; external set behaviors(List<Behavior<Node>> v);
 /// Gets an attached behavior by name
 /// @see http://doc.babylonjs.com/features/behaviour
 external Behavior<Node>/*Behavior<Node>|Null*/ getBehaviorByName(String name);
 /// Returns the world matrix of the node
 external Matrix getWorldMatrix();
 /// @hidden
 external num JS$_getWorldMatrixDeterminant();
 /// @hidden
 external void JS$_initCache();
 /// @hidden
 external void updateCache([bool force]);
 /// @hidden
 external void JS$_updateCache([bool ignoreParentClass]);
 /// @hidden
 external bool JS$_isSynchronized();
 /// @hidden
 external void JS$_markSyncedWithParent();
 /// @hidden
 external bool isSynchronizedWithParent();
 /// @hidden
 external bool isSynchronized([bool updateCache]);
 /// @hidden
 external bool hasNewParent([bool update]);
 /// Is this node ready to be used/rendered
 external bool isReady([bool completeCheck]);
 /// Is this node enabled?
 /// If the node has a parent, all ancestors will be checked and false will be returned if any are false (not enabled), otherwise will return true
 external bool isEnabled([bool checkAncestors]);
 /// Set the enabled state of this node
 external void setEnabled(bool value);
 /// Is this node a descendant of the given node?
 /// The function will iterate up the hierarchy until the ancestor was found or no more parents defined
 external bool isDescendantOf(Node ancestor);
 /// @hidden
 external void JS$_getDescendants(List<Node> results, [bool directDescendantsOnly, bool predicate(Node node)]);
 /// Will return all nodes that have this node as ascendant
 external List<Node> getDescendants([bool directDescendantsOnly, bool predicate(Node node)]);
 /// Get all child-meshes of this node
 external List<AbstractMesh> getChildMeshes([bool directDescendantsOnly, bool predicate(Node node)]);
 /// Get all child-transformNodes of this node
 external List<TransformNode> getChildTransformNodes([bool directDescendantsOnly, bool predicate(Node node)]);
 /// Get all direct children of this node
 external List<Node> getChildren([bool predicate(Node node)]);
 /// @hidden
 external void JS$_setReady(bool state);
 /// Get an animation by name
 external Animation/*Animation|Null*/ getAnimationByName(String name);
 /// Creates an animation range for this node
 external void createAnimationRange(String name, num from, num to);
 /// Delete a specific animation range
 external void deleteAnimationRange(String name, [bool deleteFrames]);
 /// Get an animation range by name
 external AnimationRange/*AnimationRange|Null*/ getAnimationRange(String name);
 /// Will start the animation sequence
 external Animatable/*Animatable|Null*/ beginAnimation(String name, [bool loop, num speedRatio, void onAnimationEnd()]);
 /// Serialize animation ranges into a JSON compatible object
 external dynamic serializeAnimationRanges();
 /// Computes the world matrix of the node
 external Matrix computeWorldMatrix([bool force]);
 /// Releases resources associated with this node.
 external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);
 /// Parse animation range data from a serialization object and store them into a given node
 external static void ParseAnimationRanges(Node node, dynamic parsedNode, Scene scene); }

 /// Define an interface for all classes that will hold resources
 @anonymous @JS() abstract class IDisposable {
 /// Releases all held resources
 external void dispose(); }

 /// Interface used to let developers provide their own mesh selection mechanism
 @anonymous @JS() abstract class IActiveMeshCandidateProvider {
 /// Return the list of active meshes
 external List<AbstractMesh> getMeshes(Scene scene);
 /// Indicates if the meshes have been checked to make sure they are isEnabled()
 external bool get checksIsEnabled; external set checksIsEnabled(bool v); }

 /// This class is used by the onRenderingGroupObservable
 @JS("BABYLON.RenderingGroupInfo" ) class RenderingGroupInfo { // @Ignore
 RenderingGroupInfo .fakeConstructor$() ;
 /// The Scene that being rendered
 external Scene get scene; external set scene(Scene v);
 /// The camera currently used for the rendering pass
 external Camera/*Camera|Null*/ get camera; external set camera(Camera/*Camera|Null*/ v);
 /// The ID of the renderingGroup being processed
 external num get renderingGroupId; external set renderingGroupId(num v);
 /// The rendering stage, can be either STAGE_PRECLEAR, STAGE_PREOPAQUE, STAGE_PRETRANSPARENT, STAGE_POSTTRANSPARENT
 external num get renderStage; external set renderStage(num v);
 /// Stage corresponding to the very first hook in the renderingGroup phase: before the render buffer may be cleared
 /// This stage will be fired no matter what
 external static num get STAGE_PRECLEAR; external static set STAGE_PRECLEAR(num v);
 /// Called before opaque object are rendered.
 /// This stage will be fired only if there's 3D Opaque content to render
 external static num get STAGE_PREOPAQUE; external static set STAGE_PREOPAQUE(num v);
 /// Called after the opaque objects are rendered and before the transparent ones
 /// This stage will be fired only if there's 3D transparent content to render
 external static num get STAGE_PRETRANSPARENT; external static set STAGE_PRETRANSPARENT(num v);
 /// Called after the transparent object are rendered, last hook of the renderingGroup phase
 /// This stage will be fired no matter what
 external static num get STAGE_POSTTRANSPARENT; external static set STAGE_POSTTRANSPARENT(num v); }

 /// Represents a scene to be rendered by the engine.
 /// @see http://doc.babylonjs.com/features/scene
 @JS("BABYLON.Scene" ) class Scene implements IAnimatable { // @Ignore
 Scene .fakeConstructor$() ;
 external static get JS$_FOGMODE_NONE; external static set JS$_FOGMODE_NONE(v); external static get JS$_FOGMODE_EXP; external static set JS$_FOGMODE_EXP(v); external static get JS$_FOGMODE_EXP2; external static set JS$_FOGMODE_EXP2(v); external static get JS$_FOGMODE_LINEAR; external static set JS$_FOGMODE_LINEAR(v); external static get JS$_uniqueIdCounter; external static set JS$_uniqueIdCounter(v);
 /// Gets or sets the minimum deltatime when deterministic lock step is enabled
 /// @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
 external static num get MinDeltaTime; external static set MinDeltaTime(num v);
 /// Gets or sets the maximum deltatime when deterministic lock step is enabled
 /// @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
 external static num get MaxDeltaTime; external static set MaxDeltaTime(num v);
 /// The fog is deactivated
 external static num get FOGMODE_NONE; external static set FOGMODE_NONE(num v);
 /// The fog density is following an exponential function
 external static num get FOGMODE_EXP; external static set FOGMODE_EXP(num v);
 /// The fog density is following an exponential function faster than FOGMODE_EXP
 external static num get FOGMODE_EXP2; external static set FOGMODE_EXP2(num v);
 /// The fog density is following a linear function.
 external static num get FOGMODE_LINEAR; external static set FOGMODE_LINEAR(num v);
 /// Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame
 external bool get autoClear; external set autoClear(bool v);
 /// Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame
 external bool get autoClearDepthAndStencil; external set autoClearDepthAndStencil(bool v);
 /// Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))
 external Color4 get clearColor; external set clearColor(Color4 v);
 /// Defines the color used to simulate the ambient color (Default is (0, 0, 0))
 external Color3 get ambientColor; external set ambientColor(Color3 v);
 /// @hidden
 external BaseTexture get JS$_environmentBRDFTexture; external set JS$_environmentBRDFTexture(BaseTexture v);
 /// @hidden
 external BaseTexture get JS$_environmentTexture; external set JS$_environmentTexture(BaseTexture v);
 /// Texture used in all pbr material as the reflection texture.
 /// As in the majority of the scene they are the same (exception for multi room and so on),
 /// this is easier to reference from here than from all the materials.
 /// Texture used in all pbr material as the reflection texture.
 /// As in the majority of the scene they are the same (exception for multi room and so on),
 /// this is easier to set here than in all the materials.
 external BaseTexture get environmentTexture; external set environmentTexture(BaseTexture v);
 /// @hidden
 external ImageProcessingConfiguration get JS$_imageProcessingConfiguration; external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);
 /// Default image processing configuration used either in the rendering
 /// Forward main pass or through the imageProcessingPostProcess if present.
 /// As in the majority of the scene they are the same (exception for multi camera),
 /// this is easier to reference from here than from all the materials and post process.
 /// No setter as we it is a shared configuration, you can set the values instead.
 external ImageProcessingConfiguration get imageProcessingConfiguration; external set imageProcessingConfiguration(ImageProcessingConfiguration v); external get JS$_forceWireframe; external set JS$_forceWireframe(v);
 /// Gets or sets a boolean indicating if all rendering must be done in wireframe
 external bool get forceWireframe; external set forceWireframe(bool v); external get JS$_forcePointsCloud; external set JS$_forcePointsCloud(v);
 /// Gets or sets a boolean indicating if all rendering must be done in point cloud
 external bool get forcePointsCloud; external set forcePointsCloud(bool v);
 /// Gets or sets a boolean indicating if all bounding boxes must be rendered
 external bool get forceShowBoundingBoxes; external set forceShowBoundingBoxes(bool v);
 /// Gets or sets the active clipplane
 external Plane/*Plane|Null*/ get clipPlane; external set clipPlane(Plane/*Plane|Null*/ v);
 /// Gets or sets a boolean indicating if animations are enabled
 external bool get animationsEnabled; external set animationsEnabled(bool v); external get JS$_animationPropertiesOverride; external set JS$_animationPropertiesOverride(v);
 /// Gets or sets the animation properties override
 external AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ get animationPropertiesOverride; external set animationPropertiesOverride(AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ v);
 /// Gets or sets a boolean indicating if a constant deltatime has to be used
 /// This is mostly useful for testing purposes when you do not want the animations to scale with the framerate
 external bool get useConstantAnimationDeltaTime; external set useConstantAnimationDeltaTime(bool v);
 /// Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated
 /// Please note that it requires to run a ray cast through the scene on every frame
 external bool get constantlyUpdateMeshUnderPointer; external set constantlyUpdateMeshUnderPointer(bool v);
 /// Defines the HTML cursor to use when hovering over interactive elements
 external String get hoverCursor; external set hoverCursor(String v);
 /// Defines the HTML default cursor to use (empty by default)
 external String get defaultCursor; external set defaultCursor(String v);
 /// This is used to call preventDefault() on pointer down
 /// in order to block unwanted artifacts like system double clicks
 external bool get preventDefaultOnPointerDown; external set preventDefaultOnPointerDown(bool v);
 /// Gets or sets user defined metadata
 external dynamic get metadata; external set metadata(dynamic v);
 /// Gets the name of the plugin used to load this scene (null by default)
 external String get loadingPluginName; external set loadingPluginName(String v);
 /// Use this array to add regular expressions used to disable offline support for specific urls
 external List<RegExp> get disableOfflineSupportExceptionRules; external set disableOfflineSupportExceptionRules(List<RegExp> v); external get JS$_spritePredicate; external set JS$_spritePredicate(v);
 /// An event triggered when the scene is disposed.
 external Observable<Scene> get onDisposeObservable; external set onDisposeObservable(Observable<Scene> v); external get JS$_onDisposeObserver; external set JS$_onDisposeObserver(v);
 /// Sets a function to be executed when this scene is disposed.
 external VoidFunc0 get onDispose; external set onDispose(VoidFunc0 v);
 /// An event triggered before rendering the scene (right after animations and physics)
 external Observable<Scene> get onBeforeRenderObservable; external set onBeforeRenderObservable(Observable<Scene> v); external get JS$_onBeforeRenderObserver; external set JS$_onBeforeRenderObserver(v);
 /// Sets a function to be executed before rendering this scene
 external VoidFunc0/*VoidFunc0|Null*/ get beforeRender; external set beforeRender(VoidFunc0/*VoidFunc0|Null*/ v);
 /// An event triggered after rendering the scene
 external Observable<Scene> get onAfterRenderObservable; external set onAfterRenderObservable(Observable<Scene> v); external get JS$_onAfterRenderObserver; external set JS$_onAfterRenderObserver(v);
 /// Sets a function to be executed after rendering this scene
 external VoidFunc0/*VoidFunc0|Null*/ get afterRender; external set afterRender(VoidFunc0/*VoidFunc0|Null*/ v);
 /// An event triggered before animating the scene
 external Observable<Scene> get onBeforeAnimationsObservable; external set onBeforeAnimationsObservable(Observable<Scene> v);
 /// An event triggered after animations processing
 external Observable<Scene> get onAfterAnimationsObservable; external set onAfterAnimationsObservable(Observable<Scene> v);
 /// An event triggered before draw calls are ready to be sent
 external Observable<Scene> get onBeforeDrawPhaseObservable; external set onBeforeDrawPhaseObservable(Observable<Scene> v);
 /// An event triggered after draw calls have been sent
 external Observable<Scene> get onAfterDrawPhaseObservable; external set onAfterDrawPhaseObservable(Observable<Scene> v);
 /// An event triggered when physic simulation is about to be run
 external Observable<Scene> get onBeforePhysicsObservable; external set onBeforePhysicsObservable(Observable<Scene> v);
 /// An event triggered when physic simulation has been done
 external Observable<Scene> get onAfterPhysicsObservable; external set onAfterPhysicsObservable(Observable<Scene> v);
 /// An event triggered when the scene is ready
 external Observable<Scene> get onReadyObservable; external set onReadyObservable(Observable<Scene> v);
 /// An event triggered before rendering a camera
 external Observable<Camera> get onBeforeCameraRenderObservable; external set onBeforeCameraRenderObservable(Observable<Camera> v); external get JS$_onBeforeCameraRenderObserver; external set JS$_onBeforeCameraRenderObserver(v);
 /// Sets a function to be executed before rendering a camera
 external VoidFunc0 get beforeCameraRender; external set beforeCameraRender(VoidFunc0 v);
 /// An event triggered after rendering a camera
 external Observable<Camera> get onAfterCameraRenderObservable; external set onAfterCameraRenderObservable(Observable<Camera> v); external get JS$_onAfterCameraRenderObserver; external set JS$_onAfterCameraRenderObserver(v);
 /// Sets a function to be executed after rendering a camera
 external VoidFunc0 get afterCameraRender; external set afterCameraRender(VoidFunc0 v);
 /// An event triggered when active meshes evaluation is about to start
 external Observable<Scene> get onBeforeActiveMeshesEvaluationObservable; external set onBeforeActiveMeshesEvaluationObservable(Observable<Scene> v);
 /// An event triggered when active meshes evaluation is done
 external Observable<Scene> get onAfterActiveMeshesEvaluationObservable; external set onAfterActiveMeshesEvaluationObservable(Observable<Scene> v);
 /// An event triggered when particles rendering is about to start
 /// Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
 external Observable<Scene> get onBeforeParticlesRenderingObservable; external set onBeforeParticlesRenderingObservable(Observable<Scene> v);
 /// An event triggered when particles rendering is done
 /// Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
 external Observable<Scene> get onAfterParticlesRenderingObservable; external set onAfterParticlesRenderingObservable(Observable<Scene> v);
 /// An event triggered when sprites rendering is about to start
 /// Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
 external Observable<Scene> get onBeforeSpritesRenderingObservable; external set onBeforeSpritesRenderingObservable(Observable<Scene> v);
 /// An event triggered when sprites rendering is done
 /// Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
 external Observable<Scene> get onAfterSpritesRenderingObservable; external set onAfterSpritesRenderingObservable(Observable<Scene> v);
 /// An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed
 external Observable<Scene> get onDataLoadedObservable; external set onDataLoadedObservable(Observable<Scene> v);
 /// An event triggered when a camera is created
 external Observable<Camera> get onNewCameraAddedObservable; external set onNewCameraAddedObservable(Observable<Camera> v);
 /// An event triggered when a camera is removed
 external Observable<Camera> get onCameraRemovedObservable; external set onCameraRemovedObservable(Observable<Camera> v);
 /// An event triggered when a light is created
 external Observable<Light> get onNewLightAddedObservable; external set onNewLightAddedObservable(Observable<Light> v);
 /// An event triggered when a light is removed
 external Observable<Light> get onLightRemovedObservable; external set onLightRemovedObservable(Observable<Light> v);
 /// An event triggered when a geometry is created
 external Observable<Geometry> get onNewGeometryAddedObservable; external set onNewGeometryAddedObservable(Observable<Geometry> v);
 /// An event triggered when a geometry is removed
 external Observable<Geometry> get onGeometryRemovedObservable; external set onGeometryRemovedObservable(Observable<Geometry> v);
 /// An event triggered when a transform node is created
 external Observable<TransformNode> get onNewTransformNodeAddedObservable; external set onNewTransformNodeAddedObservable(Observable<TransformNode> v);
 /// An event triggered when a transform node is removed
 external Observable<TransformNode> get onTransformNodeRemovedObservable; external set onTransformNodeRemovedObservable(Observable<TransformNode> v);
 /// An event triggered when a mesh is created
 external Observable<AbstractMesh> get onNewMeshAddedObservable; external set onNewMeshAddedObservable(Observable<AbstractMesh> v);
 /// An event triggered when a mesh is removed
 external Observable<AbstractMesh> get onMeshRemovedObservable; external set onMeshRemovedObservable(Observable<AbstractMesh> v);
 /// An event triggered when render targets are about to be rendered
 /// Can happen multiple times per frame.
 external Observable<Scene> get onBeforeRenderTargetsRenderObservable; external set onBeforeRenderTargetsRenderObservable(Observable<Scene> v);
 /// An event triggered when render targets were rendered.
 /// Can happen multiple times per frame.
 external Observable<Scene> get onAfterRenderTargetsRenderObservable; external set onAfterRenderTargetsRenderObservable(Observable<Scene> v);
 /// An event triggered before calculating deterministic simulation step
 external Observable<Scene> get onBeforeStepObservable; external set onBeforeStepObservable(Observable<Scene> v);
 /// An event triggered after calculating deterministic simulation step
 external Observable<Scene> get onAfterStepObservable; external set onAfterStepObservable(Observable<Scene> v);
 /// This Observable will be triggered for each stage of each renderingGroup of each rendered camera.
 /// The RenderinGroupInfo class contains all the information about the context in which the observable is called
 /// If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)
 external Observable<RenderingGroupInfo> get onRenderingGroupObservable; external set onRenderingGroupObservable(Observable<RenderingGroupInfo> v);
 /// Gets a list of Animations associated with the scene
 external List<Animation> get animations; external set animations(List<Animation> v); external get JS$_registeredForLateAnimationBindings; external set JS$_registeredForLateAnimationBindings(v);
 /// Gets or sets a predicate used to select candidate meshes for a pointer down event
 external Func1<AbstractMesh, bool> get pointerDownPredicate; external set pointerDownPredicate(Func1<AbstractMesh, bool> v);
 /// Gets or sets a predicate used to select candidate meshes for a pointer up event
 external Func1<AbstractMesh, bool> get pointerUpPredicate; external set pointerUpPredicate(Func1<AbstractMesh, bool> v);
 /// Gets or sets a predicate used to select candidate meshes for a pointer move event
 external Func1<AbstractMesh, bool> get pointerMovePredicate; external set pointerMovePredicate(Func1<AbstractMesh, bool> v); external get JS$_onPointerMove; external set JS$_onPointerMove(v); external get JS$_onPointerDown; external set JS$_onPointerDown(v); external get JS$_onPointerUp; external set JS$_onPointerUp(v);
 /// Deprecated. Use onPointerObservable instead
 external VoidFunc3<PointerEvent, PickingInfo, PointerEventTypes> get onPointerMove; external set onPointerMove(VoidFunc3<PointerEvent, PickingInfo, PointerEventTypes> v);
 /// Deprecated. Use onPointerObservable instead
 external VoidFunc3<PointerEvent, PickingInfo, PointerEventTypes> get onPointerDown; external set onPointerDown(VoidFunc3<PointerEvent, PickingInfo, PointerEventTypes> v);
 /// Deprecated. Use onPointerObservable instead
 external VoidFunc3<PointerEvent, PickingInfo/*PickingInfo|Null*/, PointerEventTypes> get onPointerUp; external set onPointerUp(VoidFunc3<PointerEvent, PickingInfo/*PickingInfo|Null*/, PointerEventTypes> v);
 /// Deprecated. Use onPointerObservable instead
 external VoidFunc2<PointerEvent, PickingInfo> get onPointerPick; external set onPointerPick(VoidFunc2<PointerEvent, PickingInfo> v); external get JS$_gamepadManager; external set JS$_gamepadManager(v);
 /// Gets the gamepad manager associated with the scene
 /// @see http://doc.babylonjs.com/how_to/how_to_use_gamepads
 external GamepadManager get gamepadManager; external set gamepadManager(GamepadManager v);
 /// This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).
 /// You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true
 external Observable<PointerInfoPre> get onPrePointerObservable; external set onPrePointerObservable(Observable<PointerInfoPre> v);
 /// Observable event triggered each time an input event is received from the rendering canvas
 external Observable<PointerInfo> get onPointerObservable; external set onPointerObservable(Observable<PointerInfo> v);
 /// Gets the pointer coordinates without any translation (ie. straight out of the pointer event)
 external Vector2 get unTranslatedPointer; external set unTranslatedPointer(Vector2 v);
 /// The distance in pixel that you have to move to prevent some events
 external static num get DragMovementThreshold; external static set DragMovementThreshold(num v);
 /// Time in milliseconds to wait to raise long press events if button is still pressed
 external static num get LongPressDelay; external static set LongPressDelay(num v);
 /// Time in milliseconds with two consecutive clicks will be considered as a double click
 external static num get DoubleClickDelay; external static set DoubleClickDelay(num v);
 /// If you need to check double click without raising a single click at first click, enable this flag
 external static bool get ExclusiveDoubleClickMode; external static set ExclusiveDoubleClickMode(bool v); external get JS$_initClickEvent; external set JS$_initClickEvent(v); external get JS$_initActionManager; external set JS$_initActionManager(v); external get JS$_delayedSimpleClick; external set JS$_delayedSimpleClick(v); external get JS$_delayedSimpleClickTimeout; external set JS$_delayedSimpleClickTimeout(v); external get JS$_previousDelayedSimpleClickTimeout; external set JS$_previousDelayedSimpleClickTimeout(v); external get JS$_meshPickProceed; external set JS$_meshPickProceed(v); external get JS$_previousButtonPressed; external set JS$_previousButtonPressed(v); external get JS$_currentPickResult; external set JS$_currentPickResult(v); external get JS$_previousPickResult; external set JS$_previousPickResult(v); external get JS$_totalPointersPressed; external set JS$_totalPointersPressed(v); external get JS$_doubleClickOccured; external set JS$_doubleClickOccured(v);
 /// Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position
 external Camera/*Camera|Null*/ get cameraToUseForPointers; external set cameraToUseForPointers(Camera/*Camera|Null*/ v); external get JS$_pointerX; external set JS$_pointerX(v); external get JS$_pointerY; external set JS$_pointerY(v); external get JS$_unTranslatedPointerX; external set JS$_unTranslatedPointerX(v); external get JS$_unTranslatedPointerY; external set JS$_unTranslatedPointerY(v); external get JS$_startingPointerPosition; external set JS$_startingPointerPosition(v); external get JS$_previousStartingPointerPosition; external set JS$_previousStartingPointerPosition(v); external get JS$_startingPointerTime; external set JS$_startingPointerTime(v); external get JS$_previousStartingPointerTime; external set JS$_previousStartingPointerTime(v); external get JS$_pointerCaptures; external set JS$_pointerCaptures(v); external get JS$_timeAccumulator; external set JS$_timeAccumulator(v); external get JS$_currentStepId; external set JS$_currentStepId(v); external get JS$_currentInternalStep; external set JS$_currentInternalStep(v);
 /// @hidden
 external Vector3/*Vector3|Null*/ get JS$_mirroredCameraPosition; external set JS$_mirroredCameraPosition(Vector3/*Vector3|Null*/ v);
 /// This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()
 /// You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true
 external Observable<KeyboardInfoPre> get onPreKeyboardObservable; external set onPreKeyboardObservable(Observable<KeyboardInfoPre> v);
 /// Observable event triggered each time an keyboard event is received from the hosting window
 external Observable<KeyboardInfo> get onKeyboardObservable; external set onKeyboardObservable(Observable<KeyboardInfo> v); external get JS$_onKeyDown; external set JS$_onKeyDown(v); external get JS$_onKeyUp; external set JS$_onKeyUp(v); external get JS$_onCanvasFocusObserver; external set JS$_onCanvasFocusObserver(v); external get JS$_onCanvasBlurObserver; external set JS$_onCanvasBlurObserver(v); external get JS$_useRightHandedSystem; external set JS$_useRightHandedSystem(v);
 /// Gets or sets a boolean indicating if the scene must use right-handed coordinates system
 external bool get useRightHandedSystem; external set useRightHandedSystem(bool v);
 /// Sets the step Id used by deterministic lock step
 /// @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
 external void setStepId(num newStepId);
 /// Gets the step Id used by deterministic lock step
 /// @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
 external num getStepId();
 /// Gets the internal step used by deterministic lock step
 /// @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
 external num getInternalStep(); external get JS$_fogEnabled; external set JS$_fogEnabled(v);
 /// Gets or sets a boolean indicating if fog is enabled on this scene
 /// @see http://doc.babylonjs.com/babylon101/environment#fog
 external bool get fogEnabled; external set fogEnabled(bool v); external get JS$_fogMode; external set JS$_fogMode(v);
 /// Gets or sets the fog mode to use
 /// @see http://doc.babylonjs.com/babylon101/environment#fog
 external num get fogMode; external set fogMode(num v);
 /// Gets or sets the fog color to use
 /// @see http://doc.babylonjs.com/babylon101/environment#fog
 external Color3 get fogColor; external set fogColor(Color3 v);
 /// Gets or sets the fog density to use
 /// @see http://doc.babylonjs.com/babylon101/environment#fog
 external num get fogDensity; external set fogDensity(num v);
 /// Gets or sets the fog start distance to use
 /// @see http://doc.babylonjs.com/babylon101/environment#fog
 external num get fogStart; external set fogStart(num v);
 /// Gets or sets the fog end distance to use
 /// @see http://doc.babylonjs.com/babylon101/environment#fog
 external num get fogEnd; external set fogEnd(num v); external get JS$_shadowsEnabled; external set JS$_shadowsEnabled(v);
 /// Gets or sets a boolean indicating if shadows are enabled on this scene
 external bool get shadowsEnabled; external set shadowsEnabled(bool v); external get JS$_lightsEnabled; external set JS$_lightsEnabled(v);
 /// Gets or sets a boolean indicating if lights are enabled on this scene
 external bool get lightsEnabled; external set lightsEnabled(bool v);
 /// All of the lights added to this scene
 /// @see http://doc.babylonjs.com/babylon101/lights
 external List<Light> get lights; external set lights(List<Light> v);
 /// All of the cameras added to this scene.
 /// @see http://doc.babylonjs.com/babylon101/cameras
 external List<Camera> get cameras; external set cameras(List<Camera> v);
 /// All of the active cameras added to this scene.
 external List<Camera> get activeCameras; external set activeCameras(List<Camera> v);
 /// The current active camera
 external Camera/*Camera|Null*/ get activeCamera; external set activeCamera(Camera/*Camera|Null*/ v);
 /// All of the tranform nodes added to this scene
 /// @see http://doc.babylonjs.com/how_to/transformnode
 external List<TransformNode> get transformNodes; external set transformNodes(List<TransformNode> v);
 /// All of the (abstract) meshes added to this scene
 external List<AbstractMesh> get meshes; external set meshes(List<AbstractMesh> v);
 /// All of the animation groups added to this scene
 /// @see http://doc.babylonjs.com/how_to/group
 external List<AnimationGroup> get animationGroups; external set animationGroups(List<AnimationGroup> v); external get JS$_geometries; external set JS$_geometries(v);
 /// All of the materials added to this scene
 /// @see http://doc.babylonjs.com/babylon101/materials
 external List<Material> get materials; external set materials(List<Material> v);
 /// All of the multi-materials added to this scene
 /// @see http://doc.babylonjs.com/how_to/multi_materials
 external List<MultiMaterial> get multiMaterials; external set multiMaterials(List<MultiMaterial> v); external get JS$_defaultMaterial; external set JS$_defaultMaterial(v);
 /// The default material used on meshes when no material is affected
 /// The default material used on meshes when no material is affected
 external Material get defaultMaterial; external set defaultMaterial(Material v); external get JS$_texturesEnabled; external set JS$_texturesEnabled(v);
 /// Gets or sets a boolean indicating if textures are enabled on this scene
 external bool get texturesEnabled; external set texturesEnabled(bool v);
 /// All of the textures added to this scene
 external List<BaseTexture> get textures; external set textures(List<BaseTexture> v);
 /// Gets or sets a boolean indicating if particles are enabled on this scene
 external bool get particlesEnabled; external set particlesEnabled(bool v);
 /// All of the particle systems added to this scene
 /// @see http://doc.babylonjs.com/babylon101/particles
 external List<IParticleSystem> get particleSystems; external set particleSystems(List<IParticleSystem> v);
 /// Gets or sets a boolean indicating if sprites are enabled on this scene
 external bool get spritesEnabled; external set spritesEnabled(bool v);
 /// All of the sprite managers added to this scene
 /// @see http://doc.babylonjs.com/babylon101/sprites
 external List<SpriteManager> get spriteManagers; external set spriteManagers(List<SpriteManager> v);
 /// The list of layers (background and foreground) of the scene
 external List<Layer> get layers; external set layers(List<Layer> v);
 /// The list of effect layers (highlights/glow) added to the scene
 /// @see http://doc.babylonjs.com/how_to/highlight_layer
 /// @see http://doc.babylonjs.com/how_to/glow_layer
 external List<EffectLayer> get effectLayers; external set effectLayers(List<EffectLayer> v); external get JS$_skeletonsEnabled; external set JS$_skeletonsEnabled(v);
 /// Gets or sets a boolean indicating if skeletons are enabled on this scene
 external bool get skeletonsEnabled; external set skeletonsEnabled(bool v);
 /// The list of skeletons added to the scene
 /// @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
 external List<Skeleton> get skeletons; external set skeletons(List<Skeleton> v);
 /// The list of morph target managers added to the scene
 /// @see http://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh
 external List<MorphTargetManager> get morphTargetManagers; external set morphTargetManagers(List<MorphTargetManager> v);
 /// Gets or sets a boolean indicating if lens flares are enabled on this scene
 external bool get lensFlaresEnabled; external set lensFlaresEnabled(bool v);
 /// The list of lens flare system added to the scene
 /// @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
 external List<LensFlareSystem> get lensFlareSystems; external set lensFlareSystems(List<LensFlareSystem> v);
 /// Gets or sets a boolean indicating if collisions are enabled on this scene
 /// @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
 external bool get collisionsEnabled; external set collisionsEnabled(bool v); external get JS$_workerCollisions; external set JS$_workerCollisions(v);
 /// @hidden
 external ICollisionCoordinator get collisionCoordinator; external set collisionCoordinator(ICollisionCoordinator v);
 /// Defines the gravity applied to this scene (used only for collisions)
 /// @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
 external Vector3 get gravity; external set gravity(Vector3 v);
 /// Gets or sets a boolean indicating if postprocesses are enabled on this scene
 external bool get postProcessesEnabled; external set postProcessesEnabled(bool v);
 /// The list of postprocesses added to the scene
 external List<PostProcess> get postProcesses; external set postProcesses(List<PostProcess> v);
 /// Gets the current postprocess manager
 external PostProcessManager get postProcessManager; external set postProcessManager(PostProcessManager v); external get JS$_postProcessRenderPipelineManager; external set JS$_postProcessRenderPipelineManager(v);
 /// Gets the postprocess render pipeline manager
 /// @see http://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
 /// @see http://doc.babylonjs.com/how_to/using_default_rendering_pipeline
 external PostProcessRenderPipelineManager get postProcessRenderPipelineManager; external set postProcessRenderPipelineManager(PostProcessRenderPipelineManager v);
 /// Gets or sets a boolean indicating if render targets are enabled on this scene
 external bool get renderTargetsEnabled; external set renderTargetsEnabled(bool v);
 /// Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes
 /// We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com
 external bool get dumpNextRenderTargets; external set dumpNextRenderTargets(bool v);
 /// The list of user defined render targets added to the scene
 external List<RenderTargetTexture> get customRenderTargets; external set customRenderTargets(List<RenderTargetTexture> v);
 /// Defines if texture loading must be delayed
 /// If true, textures will only be loaded when they need to be rendered
 external bool get useDelayedTextureLoading; external set useDelayedTextureLoading(bool v);
 /// Gets the list of meshes imported to the scene through SceneLoader
 external List<String> get importedMeshesFiles; external set importedMeshesFiles(List<String> v);
 /// Gets or sets a boolean indicating if probes are enabled on this scene
 external bool get probesEnabled; external set probesEnabled(bool v);
 /// The list of reflection probes added to the scene
 /// @see http://doc.babylonjs.com/how_to/how_to_use_reflection_probes
 external List<ReflectionProbe> get reflectionProbes; external set reflectionProbes(List<ReflectionProbe> v);
 /// @hidden
 external Database get database; external set database(Database v);
 /// Gets or sets the action manager associated with the scene
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions
 external ActionManager get actionManager; external set actionManager(ActionManager v);
 /// @hidden
 external List<ActionManager> get JS$_actionManagers; external set JS$_actionManagers(List<ActionManager> v); external get JS$_meshesForIntersections; external set JS$_meshesForIntersections(v);
 /// Gets or sets a boolean indicating if procedural textures are enabled on this scene
 external bool get proceduralTexturesEnabled; external set proceduralTexturesEnabled(bool v);
 /// The list of procedural textures added to the scene
 /// @see http://doc.babylonjs.com/how_to/how_to_use_procedural_textures
 external List<ProceduralTexture> get proceduralTextures; external set proceduralTextures(List<ProceduralTexture> v); external get JS$_mainSoundTrack; external set JS$_mainSoundTrack(v);
 /// The list of sound tracks added to the scene
 /// @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
 external List<SoundTrack> get soundTracks; external set soundTracks(List<SoundTrack> v); external get JS$_audioEnabled; external set JS$_audioEnabled(v); external get JS$_headphone; external set JS$_headphone(v);
 /// Gets the main soundtrack associated with the scene
 external SoundTrack get mainSoundTrack; external set mainSoundTrack(SoundTrack v);
 /// Gets or sets the VRExperienceHelper attached to the scene
 /// @see http://doc.babylonjs.com/how_to/webvr_helper
 /// @ignorenaming
 external VRExperienceHelper get VRHelper; external set VRHelper(VRExperienceHelper v);
 /// Gets or sets the simplification queue attached to the scene
 /// @see http://doc.babylonjs.com/how_to/in-browser_mesh_simplification
 external SimplificationQueue get simplificationQueue; external set simplificationQueue(SimplificationQueue v); external get JS$_engine; external set JS$_engine(v); external get JS$_totalVertices; external set JS$_totalVertices(v);
 /// @hidden
 external PerfCounter get JS$_activeIndices; external set JS$_activeIndices(PerfCounter v);
 /// @hidden
 external PerfCounter get JS$_activeParticles; external set JS$_activeParticles(PerfCounter v);
 /// @hidden
 external PerfCounter get JS$_activeBones; external set JS$_activeBones(PerfCounter v); external get JS$_animationRatio; external set JS$_animationRatio(v); external get JS$_animationTimeLast; external set JS$_animationTimeLast(v); external get JS$_animationTime; external set JS$_animationTime(v);
 /// Gets or sets a general scale for animation speed
 /// @see https://www.babylonjs-playground.com/#IBU2W7#3
 external num get animationTimeScale; external set animationTimeScale(num v);
 /// @hidden
 external Material/*Material|Null*/ get JS$_cachedMaterial; external set JS$_cachedMaterial(Material/*Material|Null*/ v);
 /// @hidden
 external Effect/*Effect|Null*/ get JS$_cachedEffect; external set JS$_cachedEffect(Effect/*Effect|Null*/ v);
 /// @hidden
 external num/*num|Null*/ get JS$_cachedVisibility; external set JS$_cachedVisibility(num/*num|Null*/ v); external get JS$_renderId; external set JS$_renderId(v); external get JS$_executeWhenReadyTimeoutId; external set JS$_executeWhenReadyTimeoutId(v); external get JS$_intermediateRendering; external set JS$_intermediateRendering(v); external get JS$_viewUpdateFlag; external set JS$_viewUpdateFlag(v); external get JS$_projectionUpdateFlag; external set JS$_projectionUpdateFlag(v); external get JS$_alternateViewUpdateFlag; external set JS$_alternateViewUpdateFlag(v); external get JS$_alternateProjectionUpdateFlag; external set JS$_alternateProjectionUpdateFlag(v);
 /// @hidden
 external SmartArray<IDisposable/*IDisposable|Null*/> get JS$_toBeDisposed; external set JS$_toBeDisposed(SmartArray<IDisposable/*IDisposable|Null*/> v); external get JS$_activeRequests; external set JS$_activeRequests(v); external get JS$_pendingData; external set JS$_pendingData(v); external get JS$_isDisposed; external set JS$_isDisposed(v);
 /// Gets or sets a boolean indicating that all submeshes of active meshes must be rendered
 /// Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)
 external bool get dispatchAllSubMeshesOfActiveMeshes; external set dispatchAllSubMeshesOfActiveMeshes(bool v); external get JS$_activeMeshes; external set JS$_activeMeshes(v); external get JS$_processedMaterials; external set JS$_processedMaterials(v); external get JS$_renderTargets; external set JS$_renderTargets(v);
 /// @hidden
 external SmartArray<IParticleSystem> get JS$_activeParticleSystems; external set JS$_activeParticleSystems(SmartArray<IParticleSystem> v); external get JS$_activeSkeletons; external set JS$_activeSkeletons(v); external get JS$_softwareSkinnedMeshes; external set JS$_softwareSkinnedMeshes(v); external get JS$_renderingManager; external set JS$_renderingManager(v); external get JS$_physicsEngine; external set JS$_physicsEngine(v);
 /// @hidden
 external List<Animatable> get JS$_activeAnimatables; external set JS$_activeAnimatables(List<Animatable> v); external get JS$_transformMatrix; external set JS$_transformMatrix(v); external get JS$_sceneUbo; external set JS$_sceneUbo(v); external get JS$_alternateSceneUbo; external set JS$_alternateSceneUbo(v); external get JS$_pickWithRayInverseMatrix; external set JS$_pickWithRayInverseMatrix(v); external get JS$_boundingBoxRenderer; external set JS$_boundingBoxRenderer(v); external get JS$_outlineRenderer; external set JS$_outlineRenderer(v); external get JS$_viewMatrix; external set JS$_viewMatrix(v); external get JS$_projectionMatrix; external set JS$_projectionMatrix(v); external get JS$_alternateViewMatrix; external set JS$_alternateViewMatrix(v); external get JS$_alternateProjectionMatrix; external set JS$_alternateProjectionMatrix(v); external get JS$_alternateTransformMatrix; external set JS$_alternateTransformMatrix(v); external get JS$_useAlternateCameraConfiguration; external set JS$_useAlternateCameraConfiguration(v); external get JS$_alternateRendering; external set JS$_alternateRendering(v);
 /// @hidden
 external Vector3/*Vector3|Null*/ get JS$_forcedViewPosition; external set JS$_forcedViewPosition(Vector3/*Vector3|Null*/ v);
 /// @hidden
 external bool get JS$_isAlternateRenderingEnabled; external set JS$_isAlternateRenderingEnabled(bool v); external get JS$_frustumPlanes; external set JS$_frustumPlanes(v);
 /// Gets the list of frustum planes (built from the active camera)
 external List<Plane> get frustumPlanes; external set frustumPlanes(List<Plane> v);
 /// Gets or sets a boolean indicating if lights must be sorted by priority (off by default)
 /// This is useful if there are more lights that the maximum simulteanous authorized
 external bool get requireLightSorting; external set requireLightSorting(bool v); external get JS$_selectionOctree; external set JS$_selectionOctree(v); external get JS$_pointerOverMesh; external set JS$_pointerOverMesh(v); external get JS$_pointerOverSprite; external set JS$_pointerOverSprite(v); external get JS$_debugLayer; external set JS$_debugLayer(v); external get JS$_depthRenderer; external set JS$_depthRenderer(v); external get JS$_geometryBufferRenderer; external set JS$_geometryBufferRenderer(v);
 /// Gets the current geometry buffer associated to the scene.
 /// Sets the current geometry buffer for the scene.
 external GeometryBufferRenderer/*GeometryBufferRenderer|Null*/ get geometryBufferRenderer; external set geometryBufferRenderer(GeometryBufferRenderer/*GeometryBufferRenderer|Null*/ v); external get JS$_pickedDownMesh; external set JS$_pickedDownMesh(v); external get JS$_pickedUpMesh; external set JS$_pickedUpMesh(v); external get JS$_pickedDownSprite; external set JS$_pickedDownSprite(v); external get JS$_externalData; external set JS$_externalData(v); external get JS$_uid; external set JS$_uid(v);
 /// Creates a new Scene
 external factory Scene(Engine engine);
 /// Gets the debug layer associated with the scene
 /// @see http://doc.babylonjs.com/features/playground_debuglayer
 external DebugLayer get debugLayer; external set debugLayer(DebugLayer v);
 /// Gets a boolean indicating if collisions are processed on a web worker
 /// @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity#web-worker-based-collision-system-since-21
 external bool get workerCollisions; external set workerCollisions(bool v);
 /// Gets the octree used to boost mesh selection (picking)
 /// @see http://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
 external Octree<AbstractMesh> get selectionOctree; external set selectionOctree(Octree<AbstractMesh> v);
 /// Gets the mesh that is currently under the pointer
 external AbstractMesh/*AbstractMesh|Null*/ get meshUnderPointer; external set meshUnderPointer(AbstractMesh/*AbstractMesh|Null*/ v);
 /// Gets the current on-screen X position of the pointer
 external num get pointerX; external set pointerX(num v);
 /// Gets the current on-screen Y position of the pointer
 external num get pointerY; external set pointerY(num v);
 /// Gets the cached material (ie. the latest rendered one)
 external Material/*Material|Null*/ getCachedMaterial();
 /// Gets the cached effect (ie. the latest rendered one)
 external Effect/*Effect|Null*/ getCachedEffect();
 /// Gets the cached visibility state (ie. the latest rendered one)
 external num/*num|Null*/ getCachedVisibility();
 /// Gets a boolean indicating if the current material / effect / visibility must be bind again
 external bool isCachedMaterialInvalid(Material material, Effect effect, [num visibility]);
 /// Gets the bounding box renderer associated with the scene
 external BoundingBoxRenderer getBoundingBoxRenderer();
 /// Gets the outline renderer associated with the scene
 external OutlineRenderer getOutlineRenderer();
 /// Gets the engine associated with the scene
 external Engine getEngine();
 /// Gets the total number of vertices rendered per frame
 external num getTotalVertices();
 /// Gets the performance counter for total vertices
 /// @see http://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
 external PerfCounter get totalVerticesPerfCounter; external set totalVerticesPerfCounter(PerfCounter v);
 /// Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)
 external num getActiveIndices();
 /// Gets the performance counter for active indices
 /// @see http://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
 external PerfCounter get totalActiveIndicesPerfCounter; external set totalActiveIndicesPerfCounter(PerfCounter v);
 /// Gets the total number of active particles rendered per frame
 external num getActiveParticles();
 /// Gets the performance counter for active particles
 /// @see http://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
 external PerfCounter get activeParticlesPerfCounter; external set activeParticlesPerfCounter(PerfCounter v);
 /// Gets the total number of active bones rendered per frame
 external num getActiveBones();
 /// Gets the performance counter for active bones
 /// @see http://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation
 external PerfCounter get activeBonesPerfCounter; external set activeBonesPerfCounter(PerfCounter v);
 /// @hidden
 external num getInterFramePerfCounter();
 /// @hidden
 external PerfCounter/*PerfCounter|Null*/ get interFramePerfCounter; external set interFramePerfCounter(PerfCounter/*PerfCounter|Null*/ v);
 /// @hidden
 external num getLastFrameDuration();
 /// @hidden
 external PerfCounter/*PerfCounter|Null*/ get lastFramePerfCounter; external set lastFramePerfCounter(PerfCounter/*PerfCounter|Null*/ v);
 /// @hidden
 external num getEvaluateActiveMeshesDuration();
 /// @hidden
 external PerfCounter/*PerfCounter|Null*/ get evaluateActiveMeshesDurationPerfCounter; external set evaluateActiveMeshesDurationPerfCounter(PerfCounter/*PerfCounter|Null*/ v);
 /// Gets the array of active meshes
 external SmartArray<AbstractMesh> getActiveMeshes();
 /// @hidden
 external num getRenderTargetsDuration();
 /// @hidden
 external num getRenderDuration();
 /// @hidden
 external PerfCounter/*PerfCounter|Null*/ get renderDurationPerfCounter; external set renderDurationPerfCounter(PerfCounter/*PerfCounter|Null*/ v);
 /// @hidden
 external num getParticlesDuration();
 /// @hidden
 external PerfCounter/*PerfCounter|Null*/ get particlesDurationPerfCounter; external set particlesDurationPerfCounter(PerfCounter/*PerfCounter|Null*/ v);
 /// @hidden
 external num getSpritesDuration();
 /// @hidden
 external PerfCounter/*PerfCounter|Null*/ get spriteDuractionPerfCounter; external set spriteDuractionPerfCounter(PerfCounter/*PerfCounter|Null*/ v);
 /// Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)
 external num getAnimationRatio();
 /// Gets an unique Id for the current frame
 external num getRenderId();
 /// Call this function if you want to manually increment the render Id
 external void incrementRenderId(); external JS$_updatePointerPosition(evt); external JS$_createUbo(); external JS$_createAlternateUbo();
 /// Use this method to simulate a pointer move on a mesh
 /// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
 external Scene simulatePointerMove(PickingInfo pickResult, [PointerEventInit pointerEventInit]); external JS$_processPointerMove(pickResult, evt);
 /// Use this method to simulate a pointer down on a mesh
 /// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
 external Scene simulatePointerDown(PickingInfo pickResult, [PointerEventInit pointerEventInit]); external JS$_processPointerDown(pickResult, evt);
 /// Use this method to simulate a pointer up on a mesh
 /// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
 external Scene simulatePointerUp(PickingInfo pickResult, [PointerEventInit pointerEventInit]); external JS$_processPointerUp(pickResult, evt, clickInfo);
 /// Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
 external void attachControl([bool attachUp, bool attachDown, bool attachMove]);
 /// Detaches all event handlers
 external void detachControl();
 /// This function will check if the scene can be rendered (textures are loaded, shaders are compiled)
 /// Delay loaded resources are not taking in account
 external bool isReady();
 /// Resets all cached information relative to material (including effect and visibility)
 external void resetCachedMaterial();
 /// Registers a function to be called before every frame render
 external void registerBeforeRender(void func());
 /// Unregisters a function called before every frame render
 external void unregisterBeforeRender(void func());
 /// Registers a function to be called after every frame render
 external void registerAfterRender(void func());
 /// Unregisters a function called after every frame render
 external void unregisterAfterRender(void func()); external JS$_executeOnceBeforeRender(func);
 /// The provided function will run before render once and will be disposed afterwards.
 /// A timeout delay can be provided so that the function will be executed in N ms.
 /// The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.
 external void executeOnceBeforeRender(void func(), [num timeout]);
 /// @hidden
 external void JS$_addPendingData(dynamic data);
 /// @hidden
 external void JS$_removePendingData(dynamic data);
 /// Returns the number of items waiting to be loaded
 external num getWaitingItemsCount();
 /// Returns a boolean indicating if the scene is still loading data
 external bool get isLoading; external set isLoading(bool v);
 /// Registers a function to be executed when the scene is ready
 external void executeWhenReady(void func());
 /// Returns a promise that resolves when the scene is ready
 external Promise<Null> whenReadyAsync();
 /// @hidden
 external void JS$_checkIsReady();
 /// Will start the animation sequence of a given target
 external Animatable beginWeightedAnimation(dynamic target, num from, num to, [num weight, bool loop, num speedRatio, void onAnimationEnd(), Animatable animatable]);
 /// Will start the animation sequence of a given target
 external Animatable beginAnimation(dynamic target, num from, num to, [bool loop, num speedRatio, void onAnimationEnd(), Animatable animatable, bool stopCurrent]);
 /// Begin a new animation on a given node
 external Animatable beginDirectAnimation(dynamic target, List<Animation> animations, num from, num to, [bool loop, num speedRatio, void onAnimationEnd()]);
 /// Begin a new animation on a given node and its hierarchy
 external List<Animatable> beginDirectHierarchyAnimation(Node target, bool directDescendantsOnly, List<Animation> animations, num from, num to, [bool loop, num speedRatio, void onAnimationEnd()]);
 /// Gets the animatable associated with a specific target
 external Animatable/*Animatable|Null*/ getAnimatableByTarget(dynamic target);
 /// Gets all animatables associated with a given target
 external List<Animatable> getAllAnimatablesByTarget(dynamic target);
 /// Gets all animatable attached to the scene
 external List<Animatable> get animatables; external set animatables(List<Animatable> v);
 /// Will stop the animation of the given target
 external void stopAnimation(dynamic target, [String animationName]);
 /// Stops and removes all animations that have been applied to the scene
 external void stopAllAnimations(); external JS$_animate();
 /// @hidden
 external void JS$_registerTargetForLateAnimationBinding(RuntimeAnimation runtimeAnimation, dynamic originalValue); external JS$_processLateAnimationBindingsForMatrices(holder); external JS$_processLateAnimationBindingsForQuaternions(holder); external JS$_processLateAnimationBindings();
 /// @hidden
 external void JS$_switchToAlternateCameraConfiguration(bool active);
 /// Gets the current view matrix
 external Matrix getViewMatrix();
 /// Gets the current projection matrix
 external Matrix getProjectionMatrix();
 /// Gets the current transform matrix
 external Matrix getTransformMatrix();
 /// Sets the current transform matrix
 external void setTransformMatrix(Matrix view, Matrix projection);
 /// @hidden
 external void JS$_setAlternateTransformMatrix(Matrix view, Matrix projection);
 /// Gets the uniform buffer used to store scene data
 external UniformBuffer getSceneUniformBuffer();
 /// Gets an unique (relatively to the current scene) Id
 external num getUniqueId();
 /// Add a mesh to the list of scene's meshes
 external void addMesh(AbstractMesh newMesh);
 /// Remove a mesh for the list of scene's meshes
 external num removeMesh(AbstractMesh toRemove, [bool recursive]);
 /// Add a transform node to the list of scene's transform nodes
 external void addTransformNode(TransformNode newTransformNode);
 /// Remove a transform node for the list of scene's transform nodes
 external num removeTransformNode(TransformNode toRemove);
 /// Remove a skeleton for the list of scene's skeletons
 external num removeSkeleton(Skeleton toRemove);
 /// Remove a morph target for the list of scene's morph targets
 external num removeMorphTargetManager(MorphTargetManager toRemove);
 /// Remove a light for the list of scene's lights
 external num removeLight(Light toRemove);
 /// Remove a camera for the list of scene's cameras
 external num removeCamera(Camera toRemove);
 /// Remove a particle system for the list of scene's particle systems
 external num removeParticleSystem(IParticleSystem toRemove);
 /// Remove a animation for the list of scene's animations
 external num removeAnimation(Animation toRemove);
 /// Removes the given animation group from this scene.
 external num removeAnimationGroup(AnimationGroup toRemove);
 /// Removes the given multi-material from this scene.
 external num removeMultiMaterial(MultiMaterial toRemove);
 /// Removes the given material from this scene.
 external num removeMaterial(Material toRemove);
 /// Removes the given lens flare system from this scene.
 external num removeLensFlareSystem(LensFlareSystem toRemove);
 /// Removes the given action manager from this scene.
 external num removeActionManager(ActionManager toRemove);
 /// Removes the given effect layer from this scene.
 external num removeEffectLayer(EffectLayer toRemove);
 /// Removes the given texture from this scene.
 external num removeTexture(BaseTexture toRemove);
 /// Adds the given light to this scene
 external void addLight(Light newLight);
 /// Sorts the list list based on light priorities
 external void sortLightsByPriority();
 /// Adds the given camera to this scene
 external void addCamera(Camera newCamera);
 /// Adds the given skeleton to this scene
 external void addSkeleton(Skeleton newSkeleton);
 /// Adds the given particle system to this scene
 external void addParticleSystem(IParticleSystem newParticleSystem);
 /// Adds the given animation to this scene
 external void addAnimation(Animation newAnimation);
 /// Adds the given animation group to this scene.
 external void addAnimationGroup(AnimationGroup newAnimationGroup);
 /// Adds the given multi-material to this scene
 external void addMultiMaterial(MultiMaterial newMultiMaterial);
 /// Adds the given material to this scene
 external void addMaterial(Material newMaterial);
 /// Adds the given morph target to this scene
 external void addMorphTargetManager(MorphTargetManager newMorphTargetManager);
 /// Adds the given geometry to this scene
 external void addGeometry(Geometry newGeometry);
 /// Adds the given lens flare system to this scene
 external void addLensFlareSystem(LensFlareSystem newLensFlareSystem);
 /// Adds the given effect layer to this scene
 external void addEffectLayer(EffectLayer newEffectLayer);
 /// Adds the given action manager to this scene
 external void addActionManager(ActionManager newActionManager);
 /// Adds the given texture to this scene.
 external void addTexture(BaseTexture newTexture);
 /// Switch active camera
 external void switchActiveCamera(Camera newCamera, [bool attachControl]);
 /// sets the active camera of the scene using its ID
 external Camera/*Camera|Null*/ setActiveCameraByID(String id);
 /// sets the active camera of the scene using its name
 external Camera/*Camera|Null*/ setActiveCameraByName(String name);
 /// get an animation group using its name
 external AnimationGroup/*AnimationGroup|Null*/ getAnimationGroupByName(String name);
 /// get a material using its id
 external Material/*Material|Null*/ getMaterialByID(String id);
 /// Gets a material using its name
 external Material/*Material|Null*/ getMaterialByName(String name);
 /// Gets a lens flare system using its name
 external LensFlareSystem/*LensFlareSystem|Null*/ getLensFlareSystemByName(String name);
 /// Gets a lens flare system using its id
 external LensFlareSystem/*LensFlareSystem|Null*/ getLensFlareSystemByID(String id);
 /// Gets a camera using its id
 external Camera/*Camera|Null*/ getCameraByID(String id);
 /// Gets a camera using its unique id
 external Camera/*Camera|Null*/ getCameraByUniqueID(num uniqueId);
 /// Gets a camera using its name
 external Camera/*Camera|Null*/ getCameraByName(String name);
 /// Gets a bone using its id
 external Bone/*Bone|Null*/ getBoneByID(String id);
 /// Gets a bone using its id
 external Bone/*Bone|Null*/ getBoneByName(String name);
 /// Gets a light node using its name
 external Light/*Light|Null*/ getLightByName(String name);
 /// Gets a light node using its id
 external Light/*Light|Null*/ getLightByID(String id);
 /// Gets a light node using its scene-generated unique ID
 external Light/*Light|Null*/ getLightByUniqueID(num uniqueId);
 /// Gets a particle system by id
 external IParticleSystem/*IParticleSystem|Null*/ getParticleSystemByID(String id);
 /// Gets a geometry using its ID
 external Geometry/*Geometry|Null*/ getGeometryByID(String id);
 /// Add a new geometry to this scene
 external bool pushGeometry(Geometry geometry, [bool force]);
 /// Removes an existing geometry
 external bool removeGeometry(Geometry geometry);
 /// Gets the list of geometries attached to the scene
 external List<Geometry> getGeometries();
 /// Gets the first added mesh found of a given ID
 external AbstractMesh/*AbstractMesh|Null*/ getMeshByID(String id);
 /// Gets a list of meshes using their id
 external List<AbstractMesh> getMeshesByID(String id);
 /// Gets the first added transform node found of a given ID
 external TransformNode/*TransformNode|Null*/ getTransformNodeByID(String id);
 /// Gets a list of transform nodes using their id
 external List<TransformNode> getTransformNodesByID(String id);
 /// Gets a mesh with its auto-generated unique id
 external AbstractMesh/*AbstractMesh|Null*/ getMeshByUniqueID(num uniqueId);
 /// Gets a the last added mesh using a given id
 external AbstractMesh/*AbstractMesh|Null*/ getLastMeshByID(String id);
 /// Gets a the last added node (Mesh, Camera, Light) using a given id
 external Node/*Node|Null*/ getLastEntryByID(String id);
 /// Gets a node (Mesh, Camera, Light) using a given id
 external Node/*Node|Null*/ getNodeByID(String id);
 /// Gets a node (Mesh, Camera, Light) using a given name
 external Node/*Node|Null*/ getNodeByName(String name);
 /// Gets a mesh using a given name
 external AbstractMesh/*AbstractMesh|Null*/ getMeshByName(String name);
 /// Gets a transform node using a given name
 external TransformNode/*TransformNode|Null*/ getTransformNodeByName(String name);
 /// Gets a sound using a given name
 external Sound/*Sound|Null*/ getSoundByName(String name);
 /// Gets a skeleton using a given id (if many are found, this function will pick the last one)
 external Skeleton/*Skeleton|Null*/ getLastSkeletonByID(String id);
 /// Gets a skeleton using a given id (if many are found, this function will pick the first one)
 external Skeleton/*Skeleton|Null*/ getSkeletonById(String id);
 /// Gets a skeleton using a given name
 external Skeleton/*Skeleton|Null*/ getSkeletonByName(String name);
 /// Gets a morph target manager  using a given id (if many are found, this function will pick the last one)
 external MorphTargetManager/*MorphTargetManager|Null*/ getMorphTargetManagerById(num id);
 /// Gets a boolean indicating if the given mesh is active
 external bool isActiveMesh(AbstractMesh mesh);
 /// Return a the first highlight layer of the scene with a given name.
 external HighlightLayer/*HighlightLayer|Null*/ getHighlightLayerByName(String name);
 /// Return a the first highlight layer of the scene with a given name.
 external GlowLayer/*GlowLayer|Null*/ getGlowLayerByName(String name);
 /// Return a unique id as a string which can serve as an identifier for the scene
 external String get uid; external set uid(String v);
 /// Add an externaly attached data from its key.
 /// This method call will fail and return false, if such key already exists.
 /// If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.
 external bool addExternalData /*<T>*/(String key, dynamic/*=T*/ data);
 /// Get an externaly attached data from its key
 external dynamic/*T|Null*/ getExternalData /*<T>*/(String key);
 /// Get an externaly attached data from its key, create it using a factory if it's not already present
 external dynamic/*=T*/ getOrAddExternalDataWithFactory /*<T>*/(String key, dynamic/*=T*/ JS$factory(String k));
 /// Remove an externaly attached data from the Engine instance
 external bool removeExternalData(String key); external JS$_evaluateSubMesh(subMesh, mesh);
 /// Clear the processed materials smart array preventing retention point in material dispose.
 external void freeProcessedMaterials();
 /// Clear the active meshes smart array preventing retention point in mesh dispose.
 external void freeActiveMeshes();
 /// Clear the info related to rendering groups preventing retention points during dispose.
 external void freeRenderingGroups();
 /// @hidden
 external bool JS$_isInIntermediateRendering(); external get JS$_activeMeshCandidateProvider; external set JS$_activeMeshCandidateProvider(v);
 /// Defines the current active mesh candidate provider
 external void setActiveMeshCandidateProvider(IActiveMeshCandidateProvider provider);
 /// Gets the current active mesh candidate provider
 external IActiveMeshCandidateProvider getActiveMeshCandidateProvider(); external get JS$_activeMeshesFrozen; external set JS$_activeMeshesFrozen(v);
 /// Use this function to stop evaluating active meshes. The current list will be keep alive between frames
 external Scene freezeActiveMeshes();
 /// Use this function to restart evaluating active meshes on every frame
 external Scene unfreezeActiveMeshes(); external JS$_evaluateActiveMeshes(); external JS$_activeMesh(sourceMesh, mesh);
 /// Update the transform matrix to update from the current active camera
 external void updateTransformMatrix([bool force]);
 /// Defines an alternate camera (used mostly in VR-like scenario where two cameras can render the same scene from a slightly different point of view)
 external void updateAlternateTransformMatrix(Camera alternateCamera); external JS$_renderForCamera(camera, [rigParent]); external JS$_processSubCameras(camera); external JS$_checkIntersections();
 /// Render the scene
 external void render(); external JS$_updateAudioParameters();
 /// Gets or sets if audio support is enabled
 /// @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
 external bool get audioEnabled; external set audioEnabled(bool v); external JS$_disableAudio(); external JS$_enableAudio();
 /// Gets or sets if audio will be output to headphones
 /// @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
 external bool get headphone; external set headphone(bool v); external JS$_switchAudioModeForHeadphones(); external JS$_switchAudioModeForNormalSpeakers();
 /// Creates a depth renderer a given camera which contains a depth map which can be used for post processing.
 external DepthRenderer enableDepthRenderer([Camera/*Camera|Null*/ camera]);
 /// Disables a depth renderer for a given camera
 external void disableDepthRenderer([Camera/*Camera|Null*/ camera]);
 /// Enables a GeometryBufferRender and associates it with the scene
 external GeometryBufferRenderer/*GeometryBufferRenderer|Null*/ enableGeometryBufferRenderer([num ratio]);
 /// Disables the GeometryBufferRender associated with the scene
 external void disableGeometryBufferRenderer();
 /// Freeze all materials
 /// A frozen material will not be updatable but should be faster to render
 external void freezeMaterials();
 /// Unfreeze all materials
 /// A frozen material will not be updatable but should be faster to render
 external void unfreezeMaterials();
 /// Releases all held ressources
 external void dispose();
 /// Gets if the scene is already disposed
 external bool get isDisposed; external set isDisposed(bool v);
 /// Releases sounds & soundtracks
 external void disposeSounds();
 /// Get the world extend vectors with an optional filter
 external dynamic/*{
            min: Vector3;
            max: Vector3;
        }*/ getWorldExtends([bool filterPredicate(AbstractMesh mesh)]);
 /// Creates or updates the octree used to boost selection (picking)
 /// @see http://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
 external Octree<AbstractMesh> createOrUpdateSelectionOctree([num maxCapacity, num maxDepth]);
 /// Creates a ray that can be used to pick in the scene
 external Ray createPickingRay(num x, num y, Matrix world, Camera/*Camera|Null*/ camera, [bool cameraViewSpace]);
 /// Creates a ray that can be used to pick in the scene
 external Scene createPickingRayToRef(num x, num y, Matrix world, Ray result, Camera/*Camera|Null*/ camera, [bool cameraViewSpace]);
 /// Creates a ray that can be used to pick in the scene
 external Ray createPickingRayInCameraSpace(num x, num y, [Camera camera]);
 /// Creates a ray that can be used to pick in the scene
 external Scene createPickingRayInCameraSpaceToRef(num x, num y, Ray result, [Camera camera]); external JS$_internalPick(rayFunction, [predicate, fastCheck]); external JS$_internalMultiPick(rayFunction, [predicate]); external JS$_internalPickSprites(ray, [predicate, fastCheck, camera]); external get JS$_tempPickingRay; external set JS$_tempPickingRay(v);
 /// Launch a ray to try to pick a mesh in the scene
 external PickingInfo/*PickingInfo|Null*/ pick(num x, num y, [bool predicate(AbstractMesh mesh), bool fastCheck, Camera/*Camera|Null*/ camera]);
 /// Launch a ray to try to pick a sprite in the scene
 external PickingInfo/*PickingInfo|Null*/ pickSprite(num x, num y, [bool predicate(Sprite sprite), bool fastCheck, Camera camera]); external get JS$_cachedRayForTransform; external set JS$_cachedRayForTransform(v);
 /// Use the given ray to pick a mesh in the scene
 external PickingInfo/*PickingInfo|Null*/ pickWithRay(Ray ray, bool predicate(AbstractMesh mesh), [bool fastCheck]);
 /// Launch a ray to try to pick a mesh in the scene
 external List<PickingInfo>/*List<PickingInfo>|Null*/ multiPick(num x, num y, [bool predicate(AbstractMesh mesh), Camera camera]);
 /// Launch a ray to try to pick a mesh in the scene
 external List<PickingInfo>/*List<PickingInfo>|Null*/ multiPickWithRay(Ray ray, bool predicate(AbstractMesh mesh));
 /// Force the value of meshUnderPointer
 external void setPointerOverMesh(AbstractMesh/*AbstractMesh|Null*/ mesh);
 /// Gets the mesh under the pointer
 external AbstractMesh/*AbstractMesh|Null*/ getPointerOverMesh();
 /// Force the sprite under the pointer
 external void setPointerOverSprite(Sprite/*Sprite|Null*/ sprite);
 /// Gets the sprite under the pointer
 external Sprite/*Sprite|Null*/ getPointerOverSprite();
 /// Gets the current physics engine
 external PhysicsEngine/*PhysicsEngine|Null*/ getPhysicsEngine();
 /// Enables physics to the current scene
 external bool enablePhysics([Vector3/*Vector3|Null*/ gravity, IPhysicsEnginePlugin plugin]);
 /// Disables and disposes the physics engine associated with the scene
 external void disablePhysicsEngine();
 /// Gets a boolean indicating if there is an active physics engine
 external bool isPhysicsEnabled();
 /// Deletes a physics compound impostor
 external void deleteCompoundImpostor(dynamic compound);
 /// @hidden
 external void JS$_rebuildGeometries();
 /// @hidden
 external void JS$_rebuildTextures();
 /// Creates a default light for the scene.
 external void createDefaultLight([bool replace]);
 /// Creates a default camera for the scene.
 external void createDefaultCamera([bool createArcRotateCamera, bool replace, bool attachCameraControls]);
 /// Creates a default camera and a default light
 external void createDefaultCameraOrLight([bool createArcRotateCamera, bool replace, bool attachCameraControls]);
 /// Creates a new sky box
 /// @see http://doc.babylonjs.com/babylon101/environment#skybox
 external Mesh/*Mesh|Null*/ createDefaultSkybox([BaseTexture environmentTexture, bool pbr, num scale, num blur, bool setGlobalEnvTexture]);
 /// Creates a new environment
 /// @see http://doc.babylonjs.com/babylon101/environment#skybox
 external EnvironmentHelper/*EnvironmentHelper|Null*/ createDefaultEnvironment(Partial<IEnvironmentHelperOptions> options);
 /// Creates a new VREXperienceHelper
 /// @see http://doc.babylonjs.com/how_to/webvr_helper
 external VRExperienceHelper createDefaultVRExperience([VRExperienceHelperOptions webVROptions]); external JS$_getByTags(list, tagsQuery, [forEach]);
 /// Get a list of meshes by tags
 external List<Mesh> getMeshesByTags(String tagsQuery, [void forEach(AbstractMesh mesh)]);
 /// Get a list of cameras by tags
 external List<Camera> getCamerasByTags(String tagsQuery, [void forEach(Camera camera)]);
 /// Get a list of lights by tags
 external List<Light> getLightsByTags(String tagsQuery, [void forEach(Light light)]);
 /// Get a list of materials by tags
 external List<Material> getMaterialByTags(String tagsQuery, [void forEach(Material material)]);
 /// Overrides the default sort function applied in the renderging group to prepare the meshes.
 /// This allowed control for front to back rendering or reversly depending of the special needs.
 external void setRenderingOrder(num renderingGroupId, [Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ opaqueSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ alphaTestSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ transparentSortCompareFn]);
 /// Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
 external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil, [bool depth, bool stencil]);
 /// Will flag all materials as dirty to trigger new shader compilation
 external void markAllMaterialsAsDirty(num flag, [bool predicate(Material mat)]);
 /// @hidden
 external IFileRequest JS$_loadFile(String url, void onSuccess(dynamic/*String|ByteBuffer*/ data, [String responseURL]), [void onProgress(dynamic data), bool useDatabase, bool useArrayBuffer, void onError([HttpRequest request, dynamic exception])]);
 /// @hidden
 external Promise<dynamic/*String|ByteBuffer*/> JS$_loadFileAsync(String url, [bool useDatabase, bool useArrayBuffer]); }

 /*type Nullable<T> = T | null;*/ 
 /*type float = number;*/ 
 /*type double = number;*/ 
 /*type int = number;*/ 
 /*type FloatArray = number[] | Float32Array;*/ 
 /*type IndicesArray = number[] | Int32Array | Uint32Array | Uint16Array;*/ 
 /// Alias for types that can be used by a Buffer or VertexBuffer.
 /*type DataArray = number[] | ArrayBuffer | ArrayBufferView;*/ 
 /// The action to be carried out following a trigger
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#available-actions
 @JS("BABYLON.Action" ) class Action { // @Ignore
 Action .fakeConstructor$() ;
 /// the trigger, with or without parameters, for the action
 external dynamic get triggerOptions; external set triggerOptions(dynamic v);
 /// Trigger for the action
 external num get trigger; external set trigger(num v);
 /// Internal only - manager for action
 /// @hidden
 external ActionManager get JS$_actionManager; external set JS$_actionManager(ActionManager v); external get JS$_nextActiveAction; external set JS$_nextActiveAction(v); external get JS$_child; external set JS$_child(v); external get JS$_condition; external set JS$_condition(v); external get JS$_triggerParameter; external set JS$_triggerParameter(v);
 /// An event triggered prior to action being executed.
 external Observable<Action> get onBeforeExecuteObservable; external set onBeforeExecuteObservable(Observable<Action> v);
 /// Creates a new Action
 external factory Action(
 /// the trigger, with or without parameters, for the action
 dynamic triggerOptions, [Condition condition]);
 /// Internal only
 /// @hidden
 external void JS$_prepare();
 /// Gets the trigger parameters
 external dynamic getTriggerParameter();
 /// Internal only - executes current action event
 /// @hidden
 external void JS$_executeCurrent([ActionEvent evt]);
 /// Execute placeholder for child classes
 external void execute([ActionEvent evt]);
 /// Skips to next active action
 external void skipToNextActiveAction();
 /// Adds action to chain of actions, may be a DoNothingAction
 /// @see https://www.babylonjs-playground.com/#1T30HR#0
 external Action then(Action action);
 /// Internal only
 /// @hidden
 external String JS$_getProperty(String propertyPath);
 /// Internal only
 /// @hidden
 external dynamic JS$_getEffectiveTarget(dynamic target, String propertyPath);
 /// Serialize placeholder for child classes
 external dynamic serialize(dynamic parent);
 /// Internal only called by serialize
 /// @hidden
 external dynamic JS$_serialize(dynamic serializedAction, [dynamic parent]);
 /// Internal only
 /// @hidden
 external static Func1<dynamic, String> get JS$_SerializeValueAsString; external static set JS$_SerializeValueAsString(Func1<dynamic, String> v);
 /// Internal only
 /// @hidden
 external static Func1<dynamic/*Scene|Node*/, dynamic/*{
            name: string;
            targetType: string;
            value: string;
        }*/> get JS$_GetTargetProperty; external static set JS$_GetTargetProperty(Func1<dynamic/*Scene|Node*/, dynamic/*{
            name: string;
            targetType: string;
            value: string;
        }*/> v); }

 /// ActionEvent is the event being sent when an action is triggered.
 @JS("BABYLON.ActionEvent" ) class ActionEvent { // @Ignore
 ActionEvent .fakeConstructor$() ;
 /// The mesh or sprite that triggered the action
 external dynamic get source; external set source(dynamic v);
 /// The X mouse cursor position at the time of the event
 external num get pointerX; external set pointerX(num v);
 /// The Y mouse cursor position at the time of the event
 external num get pointerY; external set pointerY(num v);
 /// The mesh that is currently pointed at (can be null)
 external AbstractMesh/*AbstractMesh|Null*/ get meshUnderPointer; external set meshUnderPointer(AbstractMesh/*AbstractMesh|Null*/ v);
 /// the original (browser) event that triggered the ActionEvent
 external dynamic get sourceEvent; external set sourceEvent(dynamic v);
 /// additional data for the event
 external dynamic get additionalData; external set additionalData(dynamic v);
 /// Creates a new ActionEvent
 external factory ActionEvent(
 /// The mesh or sprite that triggered the action
 dynamic source,
 /// The X mouse cursor position at the time of the event
 num pointerX,
 /// The Y mouse cursor position at the time of the event
 num pointerY,
 /// The mesh that is currently pointed at (can be null)
 AbstractMesh/*AbstractMesh|Null*/ meshUnderPointer, [
 /// the original (browser) event that triggered the ActionEvent
 dynamic sourceEvent,
 /// additional data for the event
 dynamic additionalData]);
 /// Helper function to auto-create an ActionEvent from a source mesh.
 external static ActionEvent CreateNew(AbstractMesh source, [Event evt, dynamic additionalData]);
 /// Helper function to auto-create an ActionEvent from a source sprite
 external static ActionEvent CreateNewFromSprite(Sprite source, Scene scene, [Event evt, dynamic additionalData]);
 /// Helper function to auto-create an ActionEvent from a scene. If triggered by a mesh use ActionEvent.CreateNew
 external static ActionEvent CreateNewFromScene(Scene scene, Event evt);
 /// Helper function to auto-create an ActionEvent from a primitive
 external static ActionEvent CreateNewFromPrimitive(dynamic prim, Vector2 pointerPos, [Event evt, dynamic additionalData]); }

 /// Action Manager manages all events to be triggered on a given mesh or the global scene.
 /// A single scene can have many Action Managers to handle predefined actions on specific meshes.
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions
 @JS("BABYLON.ActionManager" ) class ActionManager { // @Ignore
 ActionManager .fakeConstructor$() ;
 external static get JS$_NothingTrigger; external static set JS$_NothingTrigger(v); external static get JS$_OnPickTrigger; external static set JS$_OnPickTrigger(v); external static get JS$_OnLeftPickTrigger; external static set JS$_OnLeftPickTrigger(v); external static get JS$_OnRightPickTrigger; external static set JS$_OnRightPickTrigger(v); external static get JS$_OnCenterPickTrigger; external static set JS$_OnCenterPickTrigger(v); external static get JS$_OnPickDownTrigger; external static set JS$_OnPickDownTrigger(v); external static get JS$_OnDoublePickTrigger; external static set JS$_OnDoublePickTrigger(v); external static get JS$_OnPickUpTrigger; external static set JS$_OnPickUpTrigger(v); external static get JS$_OnLongPressTrigger; external static set JS$_OnLongPressTrigger(v); external static get JS$_OnPointerOverTrigger; external static set JS$_OnPointerOverTrigger(v); external static get JS$_OnPointerOutTrigger; external static set JS$_OnPointerOutTrigger(v); external static get JS$_OnEveryFrameTrigger; external static set JS$_OnEveryFrameTrigger(v); external static get JS$_OnIntersectionEnterTrigger; external static set JS$_OnIntersectionEnterTrigger(v); external static get JS$_OnIntersectionExitTrigger; external static set JS$_OnIntersectionExitTrigger(v); external static get JS$_OnKeyDownTrigger; external static set JS$_OnKeyDownTrigger(v); external static get JS$_OnKeyUpTrigger; external static set JS$_OnKeyUpTrigger(v); external static get JS$_OnPickOutTrigger; external static set JS$_OnPickOutTrigger(v);
 /// Nothing
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get NothingTrigger; external static set NothingTrigger(num v);
 /// On pick
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnPickTrigger; external static set OnPickTrigger(num v);
 /// On left pick
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnLeftPickTrigger; external static set OnLeftPickTrigger(num v);
 /// On right pick
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnRightPickTrigger; external static set OnRightPickTrigger(num v);
 /// On center pick
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnCenterPickTrigger; external static set OnCenterPickTrigger(num v);
 /// On pick down
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnPickDownTrigger; external static set OnPickDownTrigger(num v);
 /// On double pick
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnDoublePickTrigger; external static set OnDoublePickTrigger(num v);
 /// On pick up
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnPickUpTrigger; external static set OnPickUpTrigger(num v);
 /// On pick out.
 /// This trigger will only be raised if you also declared a OnPickDown
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnPickOutTrigger; external static set OnPickOutTrigger(num v);
 /// On long press
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnLongPressTrigger; external static set OnLongPressTrigger(num v);
 /// On pointer over
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnPointerOverTrigger; external static set OnPointerOverTrigger(num v);
 /// On pointer out
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnPointerOutTrigger; external static set OnPointerOutTrigger(num v);
 /// On every frame
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnEveryFrameTrigger; external static set OnEveryFrameTrigger(num v);
 /// On intersection enter
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnIntersectionEnterTrigger; external static set OnIntersectionEnterTrigger(num v);
 /// On intersection exit
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnIntersectionExitTrigger; external static set OnIntersectionExitTrigger(num v);
 /// On key down
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnKeyDownTrigger; external static set OnKeyDownTrigger(num v);
 /// On key up
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions#triggers
 external static num get OnKeyUpTrigger; external static set OnKeyUpTrigger(num v);
 /// Gets the list of active triggers
 external static dynamic/*JSMap of <String,num>*/ get Triggers; external static set Triggers(dynamic/*JSMap of <String,num>*/ v);
 /// Gets the list of actions
 external List<Action> get actions; external set actions(List<Action> v);
 /// Gets the cursor to use when hovering items
 external String get hoverCursor; external set hoverCursor(String v); external get JS$_scene; external set JS$_scene(v);
 /// Creates a new action manager
 external factory ActionManager(Scene scene);
 /// Releases all associated resources
 external void dispose();
 /// Gets hosting scene
 external Scene getScene();
 /// Does this action manager handles actions of any of the given triggers
 external bool hasSpecificTriggers(List<num> triggers);
 /// Does this action manager handles actions of a given trigger
 external bool hasSpecificTrigger(num trigger, [bool parameterPredicate(dynamic parameter)]);
 /// Does this action manager has pointer triggers
 external bool get hasPointerTriggers; external set hasPointerTriggers(bool v);
 /// Does this action manager has pick triggers
 external bool get hasPickTriggers; external set hasPickTriggers(bool v);
 /// Does exist one action manager with at least one trigger
 external static bool get HasTriggers; external static set HasTriggers(bool v);
 /// Does exist one action manager with at least one pick trigger
 external static bool get HasPickTriggers; external static set HasPickTriggers(bool v);
 /// Does exist one action manager that handles actions of a given trigger
 external static bool HasSpecificTrigger(num trigger);
 /// Registers an action to this action manager
 external Action/*Action|Null*/ registerAction(Action action);
 /// Unregisters an action to this action manager
 external bool unregisterAction(Action action);
 /// Process a specific trigger
 external void processTrigger(num trigger, [ActionEvent evt]);
 /// @hidden
 external dynamic JS$_getEffectiveTarget(dynamic target, String propertyPath);
 /// @hidden
 external String JS$_getProperty(String propertyPath);
 /// Serialize this manager to a JSON object
 external dynamic serialize(String name);
 /// Creates a new ActionManager from a JSON data
 external static void Parse(dynamic parsedActions, AbstractMesh/*AbstractMesh|Null*/ object, Scene scene);
 /// Get a trigger name by index
 external static String GetTriggerName(num trigger); }

 /// A Condition applied to an Action
 @JS("BABYLON.Condition" ) class Condition { // @Ignore
 Condition .fakeConstructor$() ;
 /// Internal only - manager for action
 /// @hidden
 external ActionManager get JS$_actionManager; external set JS$_actionManager(ActionManager v);
 /// Internal only
 /// @hidden
 external num get JS$_evaluationId; external set JS$_evaluationId(num v);
 /// Internal only
 /// @hidden
 external bool get JS$_currentResult; external set JS$_currentResult(bool v);
 /// Creates a new Condition
 external factory Condition(ActionManager actionManager);
 /// Check if the current condition is valid
 external bool isValid();
 /// Internal only
 /// @hidden
 external String JS$_getProperty(String propertyPath);
 /// Internal only
 /// @hidden
 external dynamic JS$_getEffectiveTarget(dynamic target, String propertyPath);
 /// Serialize placeholder for child classes
 external dynamic serialize();
 /// Internal only
 /// @hidden
 external dynamic JS$_serialize(dynamic serializedCondition); }

 /// Defines specific conditional operators as extensions of Condition
 @JS("BABYLON.ValueCondition" ) class ValueCondition extends Condition { // @Ignore
 ValueCondition .fakeConstructor$() : super.fakeConstructor$() ;
 /// path to specify the property of the target the conditional operator uses
 external String get propertyPath; external set propertyPath(String v);
 /// the value compared by the conditional operator against the current value of the property
 external dynamic get value; external set value(dynamic v);
 /// the conditional operator, default ValueCondition.IsEqual
 external num get JS$operator; external set JS$operator(num v);
 /// Internal only
 /// @hidden
 external static get JS$_IsEqual; external static set JS$_IsEqual(v);
 /// Internal only
 /// @hidden
 external static get JS$_IsDifferent; external static set JS$_IsDifferent(v);
 /// Internal only
 /// @hidden
 external static get JS$_IsGreater; external static set JS$_IsGreater(v);
 /// Internal only
 /// @hidden
 external static get JS$_IsLesser; external static set JS$_IsLesser(v);
 /// returns the number for IsEqual
 external static num get IsEqual; external static set IsEqual(num v);
 /// Returns the number for IsDifferent
 external static num get IsDifferent; external static set IsDifferent(num v);
 /// Returns the number for IsGreater
 external static num get IsGreater; external static set IsGreater(num v);
 /// Returns the number for IsLesser
 external static num get IsLesser; external static set IsLesser(num v);
 /// Internal only The action manager for the condition
 /// @hidden
 external ActionManager get JS$_actionManager; external set JS$_actionManager(ActionManager v);
 /// Internal only
 /// @hidden
 external get JS$_target; external set JS$_target(v);
 /// Internal only
 /// @hidden
 external get JS$_effectiveTarget; external set JS$_effectiveTarget(v);
 /// Internal only
 /// @hidden
 external get JS$_property; external set JS$_property(v);
 /// Creates a new ValueCondition
 external factory ValueCondition(ActionManager actionManager, dynamic target,
 /// path to specify the property of the target the conditional operator uses
 String propertyPath,
 /// the value compared by the conditional operator against the current value of the property
 dynamic value, [
 /// the conditional operator, default ValueCondition.IsEqual
 num JS$operator]);
 /// Compares the given value with the property value for the specified conditional operator
 external bool isValid();
 /// Serialize the ValueCondition into a JSON compatible object
 external dynamic serialize();
 /// Gets the name of the conditional operator for the ValueCondition
 external static String GetOperatorName(num JS$operator); }

 /// Defines a predicate condition as an extension of Condition
 @JS("BABYLON.PredicateCondition" ) class PredicateCondition extends Condition { // @Ignore
 PredicateCondition .fakeConstructor$() : super.fakeConstructor$() ;
 /// defines the predicate function used to validate the condition
 external Func0<bool> get predicate; external set predicate(Func0<bool> v);
 /// Internal only - manager for action
 /// @hidden
 external ActionManager get JS$_actionManager; external set JS$_actionManager(ActionManager v);
 /// Creates a new PredicateCondition
 external factory PredicateCondition(ActionManager actionManager,
 /// defines the predicate function used to validate the condition
 bool predicate());
 external bool isValid(); }

 /// Defines a state condition as an extension of Condition
 @JS("BABYLON.StateCondition" ) class StateCondition extends Condition { // @Ignore
 StateCondition .fakeConstructor$() : super.fakeConstructor$() ;
 external String get value; external set value(String v);
 /// Internal only - manager for action
 /// @hidden
 external ActionManager get JS$_actionManager; external set JS$_actionManager(ActionManager v);
 /// Internal only
 /// @hidden
 external get JS$_target; external set JS$_target(v);
 /// Creates a new StateCondition
 external factory StateCondition(ActionManager actionManager, dynamic target, String value);
 external bool isValid();
 /// Serialize the StateCondition into a JSON compatible object
 external dynamic serialize(); }

 @JS("BABYLON.SwitchBooleanAction" ) class SwitchBooleanAction extends Action { // @Ignore
 SwitchBooleanAction .fakeConstructor$() : super.fakeConstructor$() ;
 external String get propertyPath; external set propertyPath(String v); external get JS$_target; external set JS$_target(v); external get JS$_effectiveTarget; external set JS$_effectiveTarget(v); external get JS$_property; external set JS$_property(v); external factory SwitchBooleanAction(dynamic triggerOptions, dynamic target, String propertyPath, [Condition condition]); external void JS$_prepare(); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.SetStateAction" ) class SetStateAction extends Action { // @Ignore
 SetStateAction .fakeConstructor$() : super.fakeConstructor$() ;
 external String get value; external set value(String v); external get JS$_target; external set JS$_target(v); external factory SetStateAction(dynamic triggerOptions, dynamic target, String value, [Condition condition]); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.SetValueAction" ) class SetValueAction extends Action { // @Ignore
 SetValueAction .fakeConstructor$() : super.fakeConstructor$() ;
 external String get propertyPath; external set propertyPath(String v); external dynamic get value; external set value(dynamic v); external get JS$_target; external set JS$_target(v); external get JS$_effectiveTarget; external set JS$_effectiveTarget(v); external get JS$_property; external set JS$_property(v); external factory SetValueAction(dynamic triggerOptions, dynamic target, String propertyPath, dynamic value, [Condition condition]); external void JS$_prepare(); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.IncrementValueAction" ) class IncrementValueAction extends Action { // @Ignore
 IncrementValueAction .fakeConstructor$() : super.fakeConstructor$() ;
 external String get propertyPath; external set propertyPath(String v); external dynamic get value; external set value(dynamic v); external get JS$_target; external set JS$_target(v); external get JS$_effectiveTarget; external set JS$_effectiveTarget(v); external get JS$_property; external set JS$_property(v); external factory IncrementValueAction(dynamic triggerOptions, dynamic target, String propertyPath, dynamic value, [Condition condition]); external void JS$_prepare(); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.PlayAnimationAction" ) class PlayAnimationAction extends Action { // @Ignore
 PlayAnimationAction .fakeConstructor$() : super.fakeConstructor$() ;
 external num get from; external set from(num v); external num get to; external set to(num v); external dynamic/*bool|dynamic*/ get loop; external set loop(dynamic/*bool|dynamic*/ v); external get JS$_target; external set JS$_target(v); external factory PlayAnimationAction(dynamic triggerOptions, dynamic target, num from, num to, [dynamic/*bool|dynamic*/ loop, Condition condition]); external void JS$_prepare(); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.StopAnimationAction" ) class StopAnimationAction extends Action { // @Ignore
 StopAnimationAction .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_target; external set JS$_target(v); external factory StopAnimationAction(dynamic triggerOptions, dynamic target, [Condition condition]); external void JS$_prepare(); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.DoNothingAction" ) class DoNothingAction extends Action { // @Ignore
 DoNothingAction .fakeConstructor$() : super.fakeConstructor$() ;
 external factory DoNothingAction([dynamic triggerOptions, Condition condition]); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.CombineAction" ) class CombineAction extends Action { // @Ignore
 CombineAction .fakeConstructor$() : super.fakeConstructor$() ;
 external List<Action> get children; external set children(List<Action> v); external factory CombineAction(dynamic triggerOptions, List<Action> children, [Condition condition]); external void JS$_prepare(); external void execute(ActionEvent evt); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.ExecuteCodeAction" ) class ExecuteCodeAction extends Action { // @Ignore
 ExecuteCodeAction .fakeConstructor$() : super.fakeConstructor$() ;
 external VoidFunc1<ActionEvent> get func; external set func(VoidFunc1<ActionEvent> v); external factory ExecuteCodeAction(dynamic triggerOptions, void func(ActionEvent evt), [Condition condition]); external void execute(ActionEvent evt); }

 @JS("BABYLON.SetParentAction" ) class SetParentAction extends Action { // @Ignore
 SetParentAction .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_parent; external set JS$_parent(v); external get JS$_target; external set JS$_target(v); external factory SetParentAction(dynamic triggerOptions, dynamic target, dynamic parent, [Condition condition]); external void JS$_prepare(); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.PlaySoundAction" ) class PlaySoundAction extends Action { // @Ignore
 PlaySoundAction .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_sound; external set JS$_sound(v); external factory PlaySoundAction(dynamic triggerOptions, Sound sound, [Condition condition]); external void JS$_prepare(); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.StopSoundAction" ) class StopSoundAction extends Action { // @Ignore
 StopSoundAction .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_sound; external set JS$_sound(v); external factory StopSoundAction(dynamic triggerOptions, Sound sound, [Condition condition]); external void JS$_prepare(); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.InterpolateValueAction" ) class InterpolateValueAction extends Action { // @Ignore
 InterpolateValueAction .fakeConstructor$() : super.fakeConstructor$() ;
 external String get propertyPath; external set propertyPath(String v); external dynamic get value; external set value(dynamic v); external num get duration; external set duration(num v); external dynamic/*bool|dynamic*/ get stopOtherAnimations; external set stopOtherAnimations(dynamic/*bool|dynamic*/ v); external dynamic/*VoidFunc0|dynamic*/ get onInterpolationDone; external set onInterpolationDone(dynamic/*VoidFunc0|dynamic*/ v); external get JS$_target; external set JS$_target(v); external get JS$_effectiveTarget; external set JS$_effectiveTarget(v); external get JS$_property; external set JS$_property(v); external Observable<InterpolateValueAction> get onInterpolationDoneObservable; external set onInterpolationDoneObservable(Observable<InterpolateValueAction> v); external factory InterpolateValueAction(dynamic triggerOptions, dynamic target, String propertyPath, dynamic value, [num duration, Condition condition, dynamic/*bool|dynamic*/ stopOtherAnimations, dynamic/*VoidFunc0|dynamic*/ onInterpolationDone]); external void JS$_prepare(); external void execute(); external dynamic serialize(dynamic parent); }

 @JS("BABYLON.Animatable" ) class Animatable { // @Ignore
 Animatable .fakeConstructor$() ;
 external dynamic get target; external set target(dynamic v); external num get fromFrame; external set fromFrame(num v); external num get toFrame; external set toFrame(num v); external bool get loopAnimation; external set loopAnimation(bool v); external dynamic/*VoidFunc0|Null|dynamic*/ get onAnimationEnd; external set onAnimationEnd(dynamic/*VoidFunc0|Null|dynamic*/ v); external get JS$_localDelayOffset; external set JS$_localDelayOffset(v); external get JS$_pausedDelay; external set JS$_pausedDelay(v); external get JS$_runtimeAnimations; external set JS$_runtimeAnimations(v); external get JS$_paused; external set JS$_paused(v); external get JS$_scene; external set JS$_scene(v); external get JS$_speedRatio; external set JS$_speedRatio(v); external get JS$_weight; external set JS$_weight(v); external get JS$_syncRoot; external set JS$_syncRoot(v); external bool get animationStarted; external set animationStarted(bool v);
 /// Gets the root Animatable used to synchronize and normalize animations
 external Animatable get syncRoot; external set syncRoot(Animatable v);
 /// Gets the current frame of the first RuntimeAnimation
 /// Used to synchronize Animatables
 external num get masterFrame; external set masterFrame(num v);
 /// Gets or sets the animatable weight (-1.0 by default meaning not weighted)
 external num get weight; external set weight(num v);
 /// Gets or sets the speed ratio to apply to the animatable (1.0 by default)
 external num get speedRatio; external set speedRatio(num v); external factory Animatable(Scene scene, dynamic target, [num fromFrame, num toFrame, bool loopAnimation, num speedRatio, dynamic/*VoidFunc0|Null|dynamic*/ onAnimationEnd, dynamic animations]);
 /// Synchronize and normalize current Animatable with a source Animatable
 /// This is useful when using animation weights and when animations are not of the same length
 external Animatable syncWith(Animatable root); external List<RuntimeAnimation> getAnimations(); external void appendAnimations(dynamic target, List<Animation> animations); external Animation/*Animation|Null*/ getAnimationByTargetProperty(String property); external RuntimeAnimation/*RuntimeAnimation|Null*/ getRuntimeAnimationByTargetProperty(String property); external void reset(); external void enableBlending(num blendingSpeed); external void disableBlending(); external void goToFrame(num frame); external void pause(); external void restart(); external void stop([String animationName]); external bool JS$_animate(num delay); }

 /// Represents the range of an animation
 @JS("BABYLON.AnimationRange" ) class AnimationRange { // @Ignore
 AnimationRange .fakeConstructor$() ;
 /// The name of the animation range*
 external String get name; external set name(String v);
 /// The starting frame of the animation
 external num get from; external set from(num v);
 /// The ending frame of the animation
 external num get to; external set to(num v);
 /// Initializes the range of an animation
 external factory AnimationRange(
 /// The name of the animation range*
 String name,
 /// The starting frame of the animation
 num from,
 /// The ending frame of the animation
 num to);
 /// Makes a copy of the animation range
 external AnimationRange clone(); }

 /// Composed of a frame, and an action function
 @JS("BABYLON.AnimationEvent" ) class AnimationEvent { // @Ignore
 AnimationEvent .fakeConstructor$() ;
 /// The frame for which the event is triggered *
 external num get frame; external set frame(num v);
 /// The event to perform when triggered *
 external VoidFunc0 get action; external set action(VoidFunc0 v);
 /// Specifies if the event should be triggered only once*
 external dynamic/*bool|dynamic*/ get onlyOnce; external set onlyOnce(dynamic/*bool|dynamic*/ v);
 /// Specifies if the animation event is done
 external bool get isDone; external set isDone(bool v);
 /// Initializes the animation event
 external factory AnimationEvent(
 /// The frame for which the event is triggered *
 num frame,
 /// The event to perform when triggered *
 void action(), [
 /// Specifies if the event should be triggered only once*
 dynamic/*bool|dynamic*/ onlyOnce]); }

 /// A cursor which tracks a point on a path
 @JS("BABYLON.PathCursor" ) class PathCursor { // @Ignore
 PathCursor .fakeConstructor$() ;
 external get path; external set path(v);
 /// Stores path cursor callbacks for when an onchange event is triggered
 external get JS$_onchange; external set JS$_onchange(v);
 /// The value of the path cursor
 external num get value; external set value(num v);
 /// The animation array of the path cursor
 external List<Animation> get animations; external set animations(List<Animation> v);
 /// Initializes the path cursor
 external factory PathCursor(Path2 path);
 /// Gets the cursor point on the path
 external Vector3 getPoint();
 /// Moves the cursor ahead by the step amount
 external PathCursor moveAhead([num step]);
 /// Moves the cursor behind by the step amount
 external PathCursor moveBack([num step]);
 /// Moves the cursor by the step amount
 /// If the step amount is greater than one, an exception is thrown
 external PathCursor move(num step);
 /// Ensures that the value is limited between zero and one
 external ensureLimits();
 /// Runs onchange callbacks on change (used by the animation engine)
 external raiseOnChange();
 /// Executes a function on change
 external PathCursor onchange(void f(PathCursor cursor)); }

 /// Defines an interface which represents an animation key frame
 @anonymous @JS() abstract class IAnimationKey {
 /// Frame of the key frame
 external num get frame; external set frame(num v);
 /// Value at the specifies key frame
 external dynamic get value; external set value(dynamic v);
 /// The input tangent for the cubic hermite spline
 external dynamic get inTangent; external set inTangent(dynamic v);
 /// The output tangent for the cubic hermite spline
 external dynamic get outTangent; external set outTangent(dynamic v);
 /// The animation interpolation type
 external num/*enum AnimationKeyInterpolation*/ get interpolation; external set interpolation(num/*enum AnimationKeyInterpolation*/ v); external factory IAnimationKey({ num frame, dynamic value, dynamic inTangent, dynamic outTangent, num/*enum AnimationKeyInterpolation*/ interpolation}); }

 /// Enum for the animation key frame interpolation type
 @JS("BABYLON.AnimationKeyInterpolation" ) class AnimationKeyInterpolation { external static num get
 /// Do not interpolate between keys and use the start key value only. Tangents are ignored
 STEP; }
 /// Class used to store any kind of animation
 @JS("BABYLON.Animation" ) class Animation { // @Ignore
 Animation .fakeConstructor$() ;
 /// Name of the animation
 external String get name; external set name(String v);
 /// Property to animate
 external String get targetProperty; external set targetProperty(String v);
 /// The frames per second of the animation
 external num get framePerSecond; external set framePerSecond(num v);
 /// The data type of the animation
 external num get dataType; external set dataType(num v);
 /// The loop mode of the animation
 external dynamic/*num|dynamic*/ get loopMode; external set loopMode(dynamic/*num|dynamic*/ v);
 /// Specifies if blending should be enabled
 external dynamic/*bool|dynamic*/ get enableBlending; external set enableBlending(dynamic/*bool|dynamic*/ v);
 /// Use matrix interpolation instead of using direct key value when animating matrices
 external static bool get AllowMatricesInterpolation; external static set AllowMatricesInterpolation(bool v);
 /// When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower
 external static bool get AllowMatrixDecomposeForInterpolation; external static set AllowMatrixDecomposeForInterpolation(bool v);
 /// Stores the key frames of the animation
 external get JS$_keys; external set JS$_keys(v);
 /// Stores the easing function of the animation
 external get JS$_easingFunction; external set JS$_easingFunction(v);
 /// @hidden Internal use only
 external List<RuntimeAnimation> get JS$_runtimeAnimations; external set JS$_runtimeAnimations(List<RuntimeAnimation> v);
 /// The set of event that will be linked to this animation
 external get JS$_events; external set JS$_events(v);
 /// Stores an array of target property paths
 external List<String> get targetPropertyPath; external set targetPropertyPath(List<String> v);
 /// Stores the blending speed of the animation
 external num get blendingSpeed; external set blendingSpeed(num v);
 /// Stores the animation ranges for the animation
 external get JS$_ranges; external set JS$_ranges(v);
 /// @hidden Internal use
 external static Animation/*Animation|Null*/ JS$_PrepareAnimation(String name, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num loopMode, EasingFunction easingFunction]);
 /// Sets up an animation
 external static Animation CreateAnimation(String property, num animationType, num framePerSecond, EasingFunction easingFunction);
 /// Create and start an animation on a node
 external static Animatable/*Animatable|Null*/ CreateAndStartAnimation(String name, Node node, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num loopMode, EasingFunction easingFunction, void onAnimationEnd()]);
 /// Create and start an animation on a node and its descendants
 /// @example https://www.babylonjs-playground.com/#MH0VLI
 external static List<Animatable>/*List<Animatable>|Null*/ CreateAndStartHierarchyAnimation(String name, Node node, bool directDescendantsOnly, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num loopMode, EasingFunction easingFunction, void onAnimationEnd()]);
 /// Creates a new animation, merges it with the existing animations and starts it
 external static Animatable/*Animatable|Null*/ CreateMergeAndStartAnimation(String name, Node node, String targetProperty, num framePerSecond, num totalFrame, dynamic from, dynamic to, [num loopMode, EasingFunction easingFunction, void onAnimationEnd()]);
 /// Transition property of the Camera to the target Value
 external static Animatable/*Animatable|Null*/ TransitionTo(String property, dynamic targetValue, dynamic host, Scene scene, num frameRate, Animation transition, num duration, [VoidFunc0/*VoidFunc0|Null*/ onAnimationEnd]);
 /// Return the array of runtime animations currently using this animation
 external List<RuntimeAnimation> get runtimeAnimations; external set runtimeAnimations(List<RuntimeAnimation> v);
 /// Specifies if any of the runtime animations are currently running
 external bool get hasRunningRuntimeAnimations; external set hasRunningRuntimeAnimations(bool v);
 /// Initializes the animation
 external factory Animation(
 /// Name of the animation
 String name,
 /// Property to animate
 String targetProperty,
 /// The frames per second of the animation
 num framePerSecond,
 /// The data type of the animation
 num dataType, [
 /// The loop mode of the animation
 dynamic/*num|dynamic*/ loopMode,
 /// Specifies if blending should be enabled
 dynamic/*bool|dynamic*/ enableBlending]);
 /// Converts the animation to a string
 external String toString([bool fullDetails]);
 /// Add an event to this animation
 external void addEvent(AnimationEvent event);
 /// Remove all events found at the given frame
 external void removeEvents(num frame);
 /// Retrieves all the events from the animation
 external List<AnimationEvent> getEvents();
 /// Creates an animation range
 external void createRange(String name, num from, num to);
 /// Deletes an animation range by name
 external void deleteRange(String name, [bool deleteFrames]);
 /// Gets the animation range by name, or null if not defined
 external AnimationRange/*AnimationRange|Null*/ getRange(String name);
 /// Gets the key frames from the animation
 external List<IAnimationKey> getKeys();
 /// Gets the highest frame rate of the animation
 external num getHighestFrame();
 /// Gets the easing function of the animation
 external IEasingFunction getEasingFunction();
 /// Sets the easing function of the animation
 external void setEasingFunction(EasingFunction easingFunction);
 /// Interpolates a scalar linearly
 external num floatInterpolateFunction(num startValue, num endValue, num gradient);
 /// Interpolates a scalar cubically
 external num floatInterpolateFunctionWithTangents(num startValue, num outTangent, num endValue, num inTangent, num gradient);
 /// Interpolates a quaternion using a spherical linear interpolation
 external Quaternion quaternionInterpolateFunction(Quaternion startValue, Quaternion endValue, num gradient);
 /// Interpolates a quaternion cubically
 external Quaternion quaternionInterpolateFunctionWithTangents(Quaternion startValue, Quaternion outTangent, Quaternion endValue, Quaternion inTangent, num gradient);
 /// Interpolates a Vector3 linearl
 external Vector3 vector3InterpolateFunction(Vector3 startValue, Vector3 endValue, num gradient);
 /// Interpolates a Vector3 cubically
 external Vector3 vector3InterpolateFunctionWithTangents(Vector3 startValue, Vector3 outTangent, Vector3 endValue, Vector3 inTangent, num gradient);
 /// Interpolates a Vector2 linearly
 external Vector2 vector2InterpolateFunction(Vector2 startValue, Vector2 endValue, num gradient);
 /// Interpolates a Vector2 cubically
 external Vector2 vector2InterpolateFunctionWithTangents(Vector2 startValue, Vector2 outTangent, Vector2 endValue, Vector2 inTangent, num gradient);
 /// Interpolates a size linearly
 external Size sizeInterpolateFunction(Size startValue, Size endValue, num gradient);
 /// Interpolates a Color3 linearly
 external Color3 color3InterpolateFunction(Color3 startValue, Color3 endValue, num gradient);
 /// @hidden Internal use only
 external dynamic JS$_getKeyValue(dynamic value);
 /// @hidden Internal use only
 external dynamic JS$_interpolate(num currentFrame, num repeatCount, [dynamic workValue, num loopMode, dynamic offsetValue, dynamic highLimitValue]);
 /// Defines the function to use to interpolate matrices
 external Matrix matrixInterpolateFunction(Matrix startValue, Matrix endValue, num gradient, [Matrix result]);
 /// Makes a copy of the animation
 external Animation clone();
 /// Sets the key frames of the animation
 external void setKeys(List<IAnimationKey> values);
 /// Serializes the animation to an object
 external dynamic serialize();
 /// Float animation type
 external static get JS$_ANIMATIONTYPE_FLOAT; external static set JS$_ANIMATIONTYPE_FLOAT(v);
 /// Vector3 animation type
 external static get JS$_ANIMATIONTYPE_VECTOR3; external static set JS$_ANIMATIONTYPE_VECTOR3(v);
 /// Quaternion animation type
 external static get JS$_ANIMATIONTYPE_QUATERNION; external static set JS$_ANIMATIONTYPE_QUATERNION(v);
 /// Matrix animation type
 external static get JS$_ANIMATIONTYPE_MATRIX; external static set JS$_ANIMATIONTYPE_MATRIX(v);
 /// Color3 animation type
 external static get JS$_ANIMATIONTYPE_COLOR3; external static set JS$_ANIMATIONTYPE_COLOR3(v);
 /// Vector2 animation type
 external static get JS$_ANIMATIONTYPE_VECTOR2; external static set JS$_ANIMATIONTYPE_VECTOR2(v);
 /// Size animation type
 external static get JS$_ANIMATIONTYPE_SIZE; external static set JS$_ANIMATIONTYPE_SIZE(v);
 /// Relative Loop Mode
 external static get JS$_ANIMATIONLOOPMODE_RELATIVE; external static set JS$_ANIMATIONLOOPMODE_RELATIVE(v);
 /// Cycle Loop Mode
 external static get JS$_ANIMATIONLOOPMODE_CYCLE; external static set JS$_ANIMATIONLOOPMODE_CYCLE(v);
 /// Constant Loop Mode
 external static get JS$_ANIMATIONLOOPMODE_CONSTANT; external static set JS$_ANIMATIONLOOPMODE_CONSTANT(v);
 /// Get the float animation type
 external static num get ANIMATIONTYPE_FLOAT; external static set ANIMATIONTYPE_FLOAT(num v);
 /// Get the Vector3 animation type
 external static num get ANIMATIONTYPE_VECTOR3; external static set ANIMATIONTYPE_VECTOR3(num v);
 /// Get the Vectpr2 animation type
 external static num get ANIMATIONTYPE_VECTOR2; external static set ANIMATIONTYPE_VECTOR2(num v);
 /// Get the Size animation type
 external static num get ANIMATIONTYPE_SIZE; external static set ANIMATIONTYPE_SIZE(num v);
 /// Get the Quaternion animation type
 external static num get ANIMATIONTYPE_QUATERNION; external static set ANIMATIONTYPE_QUATERNION(num v);
 /// Get the Matrix animation type
 external static num get ANIMATIONTYPE_MATRIX; external static set ANIMATIONTYPE_MATRIX(num v);
 /// Get the Color3 animation type
 external static num get ANIMATIONTYPE_COLOR3; external static set ANIMATIONTYPE_COLOR3(num v);
 /// Get the Relative Loop Mode
 external static num get ANIMATIONLOOPMODE_RELATIVE; external static set ANIMATIONLOOPMODE_RELATIVE(num v);
 /// Get the Cycle Loop Mode
 external static num get ANIMATIONLOOPMODE_CYCLE; external static set ANIMATIONLOOPMODE_CYCLE(num v);
 /// Get the Constant Loop Mode
 external static num get ANIMATIONLOOPMODE_CONSTANT; external static set ANIMATIONLOOPMODE_CONSTANT(num v);
 /// @hidden
 external static dynamic JS$_UniversalLerp(dynamic left, dynamic right, num amount);
 /// Parses an animation object and creates an animation
 external static Animation Parse(dynamic parsedAnimation);
 /// Appends the serialized animations from the source animations
 external static void AppendSerializedAnimations(IAnimatable source, dynamic destination); }

 /// This class defines the direct association between an animation and a target
 @JS("BABYLON.TargetedAnimation" ) class TargetedAnimation { // @Ignore
 TargetedAnimation .fakeConstructor$() ;
 external Animation get animation; external set animation(Animation v); external dynamic get target; external set target(dynamic v); }

 /// Use this class to create coordinated animations on multiple targets
 @JS("BABYLON.AnimationGroup" ) class AnimationGroup implements IDisposable { // @Ignore
 AnimationGroup .fakeConstructor$() ;
 external String get name; external set name(String v); external get JS$_scene; external set JS$_scene(v); external get JS$_targetedAnimations; external set JS$_targetedAnimations(v); external get JS$_animatables; external set JS$_animatables(v); external get JS$_from; external set JS$_from(v); external get JS$_to; external set JS$_to(v); external get JS$_isStarted; external set JS$_isStarted(v); external get JS$_speedRatio; external set JS$_speedRatio(v); external Observable<TargetedAnimation> get onAnimationEndObservable; external set onAnimationEndObservable(Observable<TargetedAnimation> v);
 /// Gets the first frame
 external num get from; external set from(num v);
 /// Gets the last frame
 external num get to; external set to(num v);
 /// Define if the animations are started
 external bool get isStarted; external set isStarted(bool v);
 /// Gets or sets the speed ratio to use for all animations
 /// Gets or sets the speed ratio to use for all animations
 external num get speedRatio; external set speedRatio(num v);
 /// Gets the targeted animations for this animation group
 external List<TargetedAnimation> get targetedAnimations; external set targetedAnimations(List<TargetedAnimation> v);
 /// returning the list of animatables controlled by this animation group.
 external List<Animatable> get animatables; external set animatables(List<Animatable> v); external factory AnimationGroup(String name, [Scene/*Scene|Null*/ scene]);
 /// Add an animation (with its target) in the group
 external TargetedAnimation addTargetedAnimation(Animation animation, dynamic target);
 /// This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame
 /// It can add constant keys at begin or end
 external AnimationGroup normalize([num/*num|Null*/ beginFrame, num/*num|Null*/ endFrame]);
 /// Start all animations on given targets
 external AnimationGroup start([bool loop, num speedRatio, num from, num to]);
 /// Pause all animations
 external AnimationGroup pause();
 /// Play all animations to initial state
 /// This function will start() the animations if they were not started or will restart() them if they were paused
 external AnimationGroup play([bool loop]);
 /// Reset all animations to initial state
 external AnimationGroup reset();
 /// Restart animations from key 0
 external AnimationGroup restart();
 /// Stop all animations
 external AnimationGroup stop();
 /// Set animation weight for all animatables
 /// @see http://doc.babylonjs.com/babylon101/animations#animation-weights
 external AnimationGroup setWeightForAllAnimatables(num weight);
 /// Synchronize and normalize all animatables with a source animatable
 /// @see http://doc.babylonjs.com/babylon101/animations#animation-weights
 external AnimationGroup syncAllAnimationsWith(Animatable root);
 /// Goes to a specific frame in this animation group
 external AnimationGroup goToFrame(num frame);
 /// Dispose all associated resources
 external void dispose(); }

 /// Class used to override all child animations of a given target
 @JS("BABYLON.AnimationPropertiesOverride" ) class AnimationPropertiesOverride { // @Ignore
 AnimationPropertiesOverride .fakeConstructor$() ;
 /// Gets or sets a value indicating if animation blending must be used
 external bool get enableBlending; external set enableBlending(bool v);
 /// Gets or sets the blending speed to use when enableBlending is true
 external num get blendingSpeed; external set blendingSpeed(num v);
 /// Gets or sets the default loop mode to use
 external num get loopMode; external set loopMode(num v); }

 @anonymous @JS() abstract class IEasingFunction { external num ease(num gradient); }

 @JS("BABYLON.EasingFunction" ) class EasingFunction implements IEasingFunction { // @Ignore
 EasingFunction .fakeConstructor$() ;
 external static get JS$_EASINGMODE_EASEIN; external static set JS$_EASINGMODE_EASEIN(v); external static get JS$_EASINGMODE_EASEOUT; external static set JS$_EASINGMODE_EASEOUT(v); external static get JS$_EASINGMODE_EASEINOUT; external static set JS$_EASINGMODE_EASEINOUT(v); external static num get EASINGMODE_EASEIN; external static set EASINGMODE_EASEIN(num v); external static num get EASINGMODE_EASEOUT; external static set EASINGMODE_EASEOUT(num v); external static num get EASINGMODE_EASEINOUT; external static set EASINGMODE_EASEINOUT(num v); external get JS$_easingMode; external set JS$_easingMode(v); external void setEasingMode(num easingMode); external num getEasingMode(); external num easeInCore(num gradient); external num ease(num gradient); }

 @JS("BABYLON.CircleEase" ) class CircleEase extends EasingFunction implements IEasingFunction { // @Ignore
 CircleEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num easeInCore(num gradient); }

 @JS("BABYLON.BackEase" ) class BackEase extends EasingFunction implements IEasingFunction { // @Ignore
 BackEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num get amplitude; external set amplitude(num v); external factory BackEase([num amplitude]); external num easeInCore(num gradient); }

 @JS("BABYLON.BounceEase" ) class BounceEase extends EasingFunction implements IEasingFunction { // @Ignore
 BounceEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num get bounces; external set bounces(num v); external num get bounciness; external set bounciness(num v); external factory BounceEase([num bounces, num bounciness]); external num easeInCore(num gradient); }

 @JS("BABYLON.CubicEase" ) class CubicEase extends EasingFunction implements IEasingFunction { // @Ignore
 CubicEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num easeInCore(num gradient); }

 @JS("BABYLON.ElasticEase" ) class ElasticEase extends EasingFunction implements IEasingFunction { // @Ignore
 ElasticEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num get oscillations; external set oscillations(num v); external num get springiness; external set springiness(num v); external factory ElasticEase([num oscillations, num springiness]); external num easeInCore(num gradient); }

 @JS("BABYLON.ExponentialEase" ) class ExponentialEase extends EasingFunction implements IEasingFunction { // @Ignore
 ExponentialEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num get exponent; external set exponent(num v); external factory ExponentialEase([num exponent]); external num easeInCore(num gradient); }

 @JS("BABYLON.PowerEase" ) class PowerEase extends EasingFunction implements IEasingFunction { // @Ignore
 PowerEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num get power; external set power(num v); external factory PowerEase([num power]); external num easeInCore(num gradient); }

 @JS("BABYLON.QuadraticEase" ) class QuadraticEase extends EasingFunction implements IEasingFunction { // @Ignore
 QuadraticEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num easeInCore(num gradient); }

 @JS("BABYLON.QuarticEase" ) class QuarticEase extends EasingFunction implements IEasingFunction { // @Ignore
 QuarticEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num easeInCore(num gradient); }

 @JS("BABYLON.QuinticEase" ) class QuinticEase extends EasingFunction implements IEasingFunction { // @Ignore
 QuinticEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num easeInCore(num gradient); }

 @JS("BABYLON.SineEase" ) class SineEase extends EasingFunction implements IEasingFunction { // @Ignore
 SineEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num easeInCore(num gradient); }

 @JS("BABYLON.BezierCurveEase" ) class BezierCurveEase extends EasingFunction implements IEasingFunction { // @Ignore
 BezierCurveEase .fakeConstructor$() : super.fakeConstructor$() ;
 external num get x1; external set x1(num v); external num get y1; external set y1(num v); external num get x2; external set x2(num v); external num get y2; external set y2(num v); external factory BezierCurveEase([num x1, num y1, num x2, num y2]); external num easeInCore(num gradient); }

 /// Defines a runtime animation
 @JS("BABYLON.RuntimeAnimation" ) class RuntimeAnimation { // @Ignore
 RuntimeAnimation .fakeConstructor$() ;
 /// The current frame of the runtime animation
 external get JS$_currentFrame; external set JS$_currentFrame(v);
 /// The animation used by the runtime animation
 external get JS$_animation; external set JS$_animation(v);
 /// The target of the runtime animation
 external get JS$_target; external set JS$_target(v);
 /// The initiating animatable
 external get JS$_host; external set JS$_host(v);
 /// The original value of the runtime animation
 external get JS$_originalValue; external set JS$_originalValue(v);
 /// The original blend value of the runtime animation
 external get JS$_originalBlendValue; external set JS$_originalBlendValue(v);
 /// The offsets cache of the runtime animation
 external get JS$_offsetsCache; external set JS$_offsetsCache(v);
 /// The high limits cache of the runtime animation
 external get JS$_highLimitsCache; external set JS$_highLimitsCache(v);
 /// Specifies if the runtime animation has been stopped
 external get JS$_stopped; external set JS$_stopped(v);
 /// The blending factor of the runtime animation
 external get JS$_blendingFactor; external set JS$_blendingFactor(v);
 /// The BabylonJS scene
 external get JS$_scene; external set JS$_scene(v);
 /// The current value of the runtime animation
 external get JS$_currentValue; external set JS$_currentValue(v);
 /// @hidden
 external dynamic get JS$_workValue; external set JS$_workValue(dynamic v);
 /// The active target of the runtime animation
 external get JS$_activeTarget; external set JS$_activeTarget(v);
 /// The target path of the runtime animation
 external get JS$_targetPath; external set JS$_targetPath(v);
 /// The weight of the runtime animation
 external get JS$_weight; external set JS$_weight(v);
 /// The ratio offset of the runtime animation
 external get JS$_ratioOffset; external set JS$_ratioOffset(v);
 /// The previous delay of the runtime animation
 external get JS$_previousDelay; external set JS$_previousDelay(v);
 /// The previous ratio of the runtime animation
 external get JS$_previousRatio; external set JS$_previousRatio(v);
 /// Gets the current frame of the runtime animation
 external num get currentFrame; external set currentFrame(num v);
 /// Gets the weight of the runtime animation
 external num get weight; external set weight(num v);
 /// Gets the current value of the runtime animation
 external dynamic get currentValue; external set currentValue(dynamic v);
 /// Gets the target path of the runtime animation
 external String get targetPath; external set targetPath(String v);
 /// Gets the actual target of the runtime animation
 external dynamic get target; external set target(dynamic v);
 /// Create a new RuntimeAnimation object
 external factory RuntimeAnimation(dynamic target, Animation animation, Scene scene, Animatable host);
 /// Gets the animation from the runtime animation
 external Animation get animation; external set animation(Animation v);
 /// Resets the runtime animation to the beginning
 external void reset([bool restoreOriginal]);
 /// Specifies if the runtime animation is stopped
 external bool isStopped();
 /// Disposes of the runtime animation
 external void dispose();
 /// Interpolates the animation from the current frame
 external JS$_interpolate(currentFrame, repeatCount, [loopMode, offsetValue, highLimitValue]);
 /// Apply the interpolated value to the target
 external void setValue(dynamic currentValue, [num weight]); external JS$_setValue(target, currentValue, weight, [targetIndex]);
 /// Gets the loop pmode of the runtime animation
 external JS$_getCorrectLoopMode();
 /// Move the current animation to a given frame
 external void goToFrame(num frame);
 /// @hidden Internal use only
 external void JS$_prepareForSpeedRatioChange(num newSpeedRatio);
 /// Execute the current animation
 external bool animate(num delay, num from, num to, bool loop, num speedRatio, [num weight]); }

 /// Class used to work with sound analyzer using fast fourier transform (FFT)
 /// @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
 @JS("BABYLON.Analyser" ) class Analyser { // @Ignore
 Analyser .fakeConstructor$() ;
 /// Gets or sets the smoothing
 /// @ignorenaming
 external num get SMOOTHING; external set SMOOTHING(num v);
 /// Gets or sets the FFT table size
 /// @ignorenaming
 external num get FFT_SIZE; external set FFT_SIZE(num v);
 /// Gets or sets the bar graph amplitude
 /// @ignorenaming
 external num get BARGRAPHAMPLITUDE; external set BARGRAPHAMPLITUDE(num v);
 /// Gets or sets the position of the debug canvas
 /// @ignorenaming
 external dynamic/*{
            x: number;
            y: number;
        }*/ get DEBUGCANVASPOS; external set DEBUGCANVASPOS(dynamic/*{
            x: number;
            y: number;
        }*/ v);
 /// Gets or sets the debug canvas size
 /// @ignorenaming
 external dynamic/*{
            width: number;
            height: number;
        }*/ get DEBUGCANVASSIZE; external set DEBUGCANVASSIZE(dynamic/*{
            width: number;
            height: number;
        }*/ v); external get JS$_byteFreqs; external set JS$_byteFreqs(v); external get JS$_byteTime; external set JS$_byteTime(v); external get JS$_floatFreqs; external set JS$_floatFreqs(v); external get JS$_webAudioAnalyser; external set JS$_webAudioAnalyser(v); external get JS$_debugCanvas; external set JS$_debugCanvas(v); external get JS$_debugCanvasContext; external set JS$_debugCanvasContext(v); external get JS$_scene; external set JS$_scene(v); external get JS$_registerFunc; external set JS$_registerFunc(v); external get JS$_audioEngine; external set JS$_audioEngine(v);
 /// Creates a new analyser
 external factory Analyser(Scene scene);
 /// Get the number of data values you will have to play with for the visualization
 /// @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/frequencyBinCount
 external num getFrequencyBinCount();
 /// Gets the current frequency data as a byte array
 /// @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
 external Uint8List getByteFrequencyData();
 /// Gets the current waveform as a byte array
 /// @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteTimeDomainData
 external Uint8List getByteTimeDomainData();
 /// Gets the current frequency data as a float array
 /// @see https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode/getByteFrequencyData
 external Float32List getFloatFrequencyData();
 /// Renders the debug canvas
 external void drawDebugCanvas();
 /// Stops rendering the debug canvas and removes it
 external void stopDebugCanvas();
 /// Connects two audio nodes
 external void connectAudioNodes(AudioNode inputAudioNode, AudioNode outputAudioNode);
 /// Releases all associated resources
 external void dispose(); }

 @JS("BABYLON.AudioEngine" ) class AudioEngine { // @Ignore
 AudioEngine .fakeConstructor$() ;
 external get JS$_audioContext; external set JS$_audioContext(v); external get JS$_audioContextInitialized; external set JS$_audioContextInitialized(v); external bool get canUseWebAudio; external set canUseWebAudio(bool v); external GainNode get masterGain; external set masterGain(GainNode v); external get JS$_connectedAnalyser; external set JS$_connectedAnalyser(v); external bool get WarnedWebAudioUnsupported; external set WarnedWebAudioUnsupported(bool v); external bool get unlocked; external set unlocked(bool v); external Func0<dynamic> get onAudioUnlocked; external set onAudioUnlocked(Func0<dynamic> v); external bool get isMP3supported; external set isMP3supported(bool v); external bool get isOGGsupported; external set isOGGsupported(bool v); external AudioContext/*AudioContext|Null*/ get audioContext; external set audioContext(AudioContext/*AudioContext|Null*/ v); external factory AudioEngine(); external JS$_unlockiOSaudio(); external JS$_initializeAudioContext(); external void dispose(); external num getGlobalVolume(); external void setGlobalVolume(num newVolume); external void connectToAnalyser(Analyser analyser); }

 @JS("BABYLON.Sound" ) class Sound { // @Ignore
 Sound .fakeConstructor$() ;
 external String get name; external set name(String v); external bool get autoplay; external set autoplay(bool v); external bool get loop; external set loop(bool v); external bool get useCustomAttenuation; external set useCustomAttenuation(bool v); external num get soundTrackId; external set soundTrackId(num v); external bool get spatialSound; external set spatialSound(bool v); external num get refDistance; external set refDistance(num v); external num get rolloffFactor; external set rolloffFactor(num v); external num get maxDistance; external set maxDistance(num v); external String get distanceModel; external set distanceModel(String v); external get JS$_panningModel; external set JS$_panningModel(v); external Func0<dynamic> get onended; external set onended(Func0<dynamic> v); external get JS$_playbackRate; external set JS$_playbackRate(v); external get JS$_streaming; external set JS$_streaming(v); external get JS$_startTime; external set JS$_startTime(v); external get JS$_startOffset; external set JS$_startOffset(v); external get JS$_position; external set JS$_position(v); external get JS$_localDirection; external set JS$_localDirection(v); external get JS$_volume; external set JS$_volume(v); external get JS$_isReadyToPlay; external set JS$_isReadyToPlay(v); external bool get isPlaying; external set isPlaying(bool v); external bool get isPaused; external set isPaused(bool v); external get JS$_isDirectional; external set JS$_isDirectional(v); external get JS$_readyToPlayCallback; external set JS$_readyToPlayCallback(v); external get JS$_audioBuffer; external set JS$_audioBuffer(v); external get JS$_soundSource; external set JS$_soundSource(v); external get JS$_streamingSource; external set JS$_streamingSource(v); external get JS$_soundPanner; external set JS$_soundPanner(v); external get JS$_soundGain; external set JS$_soundGain(v); external get JS$_inputAudioNode; external set JS$_inputAudioNode(v); external get JS$_ouputAudioNode; external set JS$_ouputAudioNode(v); external get JS$_coneInnerAngle; external set JS$_coneInnerAngle(v); external get JS$_coneOuterAngle; external set JS$_coneOuterAngle(v); external get JS$_coneOuterGain; external set JS$_coneOuterGain(v); external get JS$_scene; external set JS$_scene(v); external get JS$_connectedMesh; external set JS$_connectedMesh(v); external get JS$_customAttenuationFunction; external set JS$_customAttenuationFunction(v); external get JS$_registerFunc; external set JS$_registerFunc(v); external get JS$_isOutputConnected; external set JS$_isOutputConnected(v); external get JS$_htmlAudioElement; external set JS$_htmlAudioElement(v); external get JS$_urlType; external set JS$_urlType(v);
 /// Create a sound and attach it to a scene
 external factory Sound(String name, dynamic urlOrArrayBuffer, Scene scene, [VoidFunc0/*VoidFunc0|Null*/ readyToPlayCallback, dynamic options]); external void dispose(); external bool isReady(); external JS$_soundLoaded(audioData); external void setAudioBuffer(AudioBuffer audioBuffer); external void updateOptions(dynamic options); external JS$_createSpatialParameters(); external JS$_updateSpatialParameters(); external void switchPanningModelToHRTF(); external void switchPanningModelToEqualPower(); external JS$_switchPanningModel(); external void connectToSoundTrackAudioNode(AudioNode soundTrackAudioNode);
 /// Transform this sound into a directional source
 external void setDirectionalCone(num coneInnerAngle, num coneOuterAngle, num coneOuterGain); external void setPosition(Vector3 newPosition); external void setLocalDirectionToMesh(Vector3 newLocalDirection); external JS$_updateDirection(); external void updateDistanceFromListener(); external void setAttenuationFunction(num callback(num currentVolume, num currentDistance, num maxDistance, num refDistance, num rolloffFactor));
 /// Play the sound
 external void play([num time, num offset]); external JS$_onended();
 /// Stop the sound
 external void stop([num time]); external void pause(); external void setVolume(num newVolume, [num time]); external void setPlaybackRate(num newPlaybackRate); external num getVolume(); external void attachToMesh(AbstractMesh meshToConnectTo); external void detachFromMesh(); external JS$_onRegisterAfterWorldMatrixUpdate(node); external Sound/*Sound|Null*/ clone(); external AudioBuffer/*AudioBuffer|Null*/ getAudioBuffer(); external dynamic serialize(); external static Sound Parse(dynamic parsedSound, Scene scene, String rootUrl, [Sound sourceSound]); }

 @JS("BABYLON.SoundTrack" ) class SoundTrack { // @Ignore
 SoundTrack .fakeConstructor$() ;
 external get JS$_outputAudioNode; external set JS$_outputAudioNode(v); external get JS$_scene; external set JS$_scene(v); external num get id; external set id(num v); external List<Sound> get soundCollection; external set soundCollection(List<Sound> v); external get JS$_isMainTrack; external set JS$_isMainTrack(v); external get JS$_connectedAnalyser; external set JS$_connectedAnalyser(v); external get JS$_options; external set JS$_options(v); external get JS$_isInitialized; external set JS$_isInitialized(v); external factory SoundTrack(Scene scene, [dynamic options]); external JS$_initializeSoundTrackAudioGraph(); external void dispose(); external void AddSound(Sound sound); external void RemoveSound(Sound sound); external void setVolume(num newVolume); external void switchPanningModelToHRTF(); external void switchPanningModelToEqualPower(); external void connectToAnalyser(Analyser analyser); }

 @anonymous @JS() abstract class Behavior <T extends Node > { external String get name; external set name(String v); external void init(); external void attach(T node); external void detach(); }

 /// Class used to store bone information
 /// @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
 @JS("BABYLON.Bone" ) class Bone extends Node { // @Ignore
 Bone .fakeConstructor$() : super.fakeConstructor$() ;
 /// defines the bone name
 external String get name; external set name(String v); external static get JS$_tmpVecs; external static set JS$_tmpVecs(v); external static get JS$_tmpQuat; external static set JS$_tmpQuat(v); external static get JS$_tmpMats; external static set JS$_tmpMats(v);
 /// Gets the list of child bones
 external List<Bone> get children; external set children(List<Bone> v);
 /// Gets the animations associated with this bone
 external List<Animation> get animations; external set animations(List<Animation> v);
 /// Gets or sets bone length
 external num get length; external set length(num v);
 /// @hidden Internal only
 /// Set this value to map this bone to a different index in the transform matrices
 /// Set this value to -1 to exclude the bone from the transform matrices
 external num/*num|Null*/ get JS$_index; external set JS$_index(num/*num|Null*/ v); external get JS$_skeleton; external set JS$_skeleton(v); external get JS$_localMatrix; external set JS$_localMatrix(v); external get JS$_restPose; external set JS$_restPose(v); external get JS$_baseMatrix; external set JS$_baseMatrix(v); external get JS$_absoluteTransform; external set JS$_absoluteTransform(v); external get JS$_invertedAbsoluteTransform; external set JS$_invertedAbsoluteTransform(v); external get JS$_parent; external set JS$_parent(v); external get JS$_scalingDeterminant; external set JS$_scalingDeterminant(v); external get JS$_worldTransform; external set JS$_worldTransform(v); external get JS$_localScaling; external set JS$_localScaling(v); external get JS$_localRotation; external set JS$_localRotation(v); external get JS$_localPosition; external set JS$_localPosition(v); external get JS$_needToDecompose; external set JS$_needToDecompose(v); external get JS$_needToCompose; external set JS$_needToCompose(v);
 /// @hidden
 /// @hidden
 external Matrix get JS$_matrix; external set JS$_matrix(Matrix v);
 /// Create a new bone
 external factory Bone(
 /// defines the bone name
 String name, Skeleton skeleton, [Bone/*Bone|Null*/ parentBone, Matrix/*Matrix|Null*/ localMatrix, Matrix/*Matrix|Null*/ restPose, Matrix/*Matrix|Null*/ baseMatrix, num/*num|Null*/ index]);
 /// Gets the parent skeleton
 external Skeleton getSkeleton();
 /// Gets parent bone
 external Bone/*Bone|Null*/ getParent();
 /// Sets the parent bone
 external void setParent(Bone/*Bone|Null*/ parent, [bool updateDifferenceMatrix]);
 /// Gets the local matrix
 external Matrix getLocalMatrix();
 /// Gets the base matrix (initial matrix which remains unchanged)
 external Matrix getBaseMatrix();
 /// Gets the rest pose matrix
 external Matrix getRestPose();
 /// Gets a matrix used to store world matrix (ie. the matrix sent to shaders)
 external Matrix getWorldMatrix();
 /// Sets the local matrix to rest pose matrix
 external void returnToRest();
 /// Gets the inverse of the absolute transform matrix.
 /// This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)
 external Matrix getInvertedAbsoluteTransform();
 /// Gets the absolute transform matrix (ie base matrix * parent world matrix)
 external Matrix getAbsoluteTransform();
 /// Gets or sets current position (in local space)
 external Vector3 get position; external set position(Vector3 v);
 /// Gets or sets current rotation (in local space)
 external Vector3 get rotation; external set rotation(Vector3 v);
 /// Gets or sets current rotation quaternion (in local space)
 external Quaternion get rotationQuaternion; external set rotationQuaternion(Quaternion v);
 /// Gets or sets current scaling (in local space)
 external Vector3 get scaling; external set scaling(Vector3 v);
 /// Gets the animation properties override
 external AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ get animationPropertiesOverride; external set animationPropertiesOverride(AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ v); external JS$_decompose(); external JS$_compose();
 /// Update the base and local matrices
 external void updateMatrix(Matrix matrix, [bool updateDifferenceMatrix, bool updateLocalMatrix]);
 /// @hidden
 external void JS$_updateDifferenceMatrix([Matrix rootMatrix, bool updateChildren]);
 /// Flag the bone as dirty (Forcing it to update everything)
 external void markAsDirty(); external JS$_markAsDirtyAndCompose(); external JS$_markAsDirtyAndDecompose();
 /// Copy an animation range from another bone
 external bool copyAnimationRange(Bone source, String rangeName, num frameOffset, [bool rescaleAsRequired, Vector3/*Vector3|Null*/ skelDimensionsRatio]);
 /// Translate the bone in local or world space
 external void translate(Vector3 vec, [num/*enum Space*/ space, AbstractMesh mesh]);
 /// Set the postion of the bone in local or world space
 external void setPosition(Vector3 position, [num/*enum Space*/ space, AbstractMesh mesh]);
 /// Set the absolute position of the bone (world space)
 external void setAbsolutePosition(Vector3 position, [AbstractMesh mesh]);
 /// Scale the bone on the x, y and z axes (in local space)
 external void scale(num x, num y, num z, [bool scaleChildren]);
 /// Set the bone scaling in local space
 external void setScale(Vector3 scale);
 /// Gets the current scaling in local space
 external Vector3 getScale();
 /// Gets the current scaling in local space and stores it in a target vector
 external void getScaleToRef(Vector3 result);
 /// Set the yaw, pitch, and roll of the bone in local or world space
 external void setYawPitchRoll(num yaw, num pitch, num roll, [num/*enum Space*/ space, AbstractMesh mesh]);
 /// Add a rotation to the bone on an axis in local or world space
 external void rotate(Vector3 axis, num amount, [num/*enum Space*/ space, AbstractMesh mesh]);
 /// Set the rotation of the bone to a particular axis angle in local or world space
 external void setAxisAngle(Vector3 axis, num angle, [num/*enum Space*/ space, AbstractMesh mesh]);
 /// Set the euler rotation of the bone in local of world space
 external void setRotation(Vector3 rotation, [num/*enum Space*/ space, AbstractMesh mesh]);
 /// Set the quaternion rotation of the bone in local of world space
 external void setRotationQuaternion(Quaternion quat, [num/*enum Space*/ space, AbstractMesh mesh]);
 /// Set the rotation matrix of the bone in local of world space
 external void setRotationMatrix(Matrix rotMat, [num/*enum Space*/ space, AbstractMesh mesh]); external JS$_rotateWithMatrix(rmat, [space, mesh]); external JS$_getNegativeRotationToRef(rotMatInv, [mesh]);
 /// Get the position of the bone in local or world space
 external Vector3 getPosition([num/*enum Space*/ space, AbstractMesh/*AbstractMesh|Null*/ mesh]);
 /// Copy the position of the bone to a vector3 in local or world space
 external void getPositionToRef(dynamic/*enum Space|dynamic*/ space, AbstractMesh/*AbstractMesh|Null*/ mesh, Vector3 result);
 /// Get the absolute position of the bone (world space)
 external Vector3 getAbsolutePosition([AbstractMesh/*AbstractMesh|Null*/ mesh]);
 /// Copy the absolute position of the bone (world space) to the result param
 external void getAbsolutePositionToRef(AbstractMesh mesh, Vector3 result);
 /// Compute the absolute transforms of this bone and its children
 external void computeAbsoluteTransforms();
 /// Get the world direction from an axis that is in the local space of the bone
 external Vector3 getDirection(Vector3 localAxis, [AbstractMesh/*AbstractMesh|Null*/ mesh]);
 /// Copy the world direction to a vector3 from an axis that is in the local space of the bone
 external void getDirectionToRef(Vector3 localAxis, dynamic/*AbstractMesh|Null|dynamic*/ mesh, Vector3 result);
 /// Get the euler rotation of the bone in local or world space
 external Vector3 getRotation([num/*enum Space*/ space, AbstractMesh/*AbstractMesh|Null*/ mesh]);
 /// Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space
 external void getRotationToRef(dynamic/*enum Space|dynamic*/ space, dynamic/*AbstractMesh|Null|dynamic*/ mesh, Vector3 result);
 /// Get the quaternion rotation of the bone in either local or world space
 external Quaternion getRotationQuaternion([num/*enum Space*/ space, AbstractMesh/*AbstractMesh|Null*/ mesh]);
 /// Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space
 external void getRotationQuaternionToRef(dynamic/*enum Space|dynamic*/ space, dynamic/*AbstractMesh|Null|dynamic*/ mesh, Quaternion result);
 /// Get the rotation matrix of the bone in local or world space
 external Matrix getRotationMatrix(dynamic/*enum Space|dynamic*/ space, AbstractMesh mesh);
 /// Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space
 external void getRotationMatrixToRef(dynamic/*enum Space|dynamic*/ space, AbstractMesh mesh, Matrix result);
 /// Get the world position of a point that is in the local space of the bone
 external Vector3 getAbsolutePositionFromLocal(Vector3 position, [AbstractMesh/*AbstractMesh|Null*/ mesh]);
 /// Get the world position of a point that is in the local space of the bone and copy it to the result param
 external void getAbsolutePositionFromLocalToRef(Vector3 position, dynamic/*AbstractMesh|Null|dynamic*/ mesh, Vector3 result);
 /// Get the local position of a point that is in world space
 external Vector3 getLocalPositionFromAbsolute(Vector3 position, [AbstractMesh/*AbstractMesh|Null*/ mesh]);
 /// Get the local position of a point that is in world space and copy it to the result param
 external void getLocalPositionFromAbsoluteToRef(Vector3 position, dynamic/*AbstractMesh|Null|dynamic*/ mesh, Vector3 result); }

 /// Class used to apply inverse kinematics to bones
 /// @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#boneikcontroller
 @JS("BABYLON.BoneIKController" ) class BoneIKController { // @Ignore
 BoneIKController .fakeConstructor$() ;
 external static get JS$_tmpVecs; external static set JS$_tmpVecs(v); external static get JS$_tmpQuat; external static set JS$_tmpQuat(v); external static get JS$_tmpMats; external static set JS$_tmpMats(v);
 /// Gets or sets the target mesh
 external AbstractMesh get targetMesh; external set targetMesh(AbstractMesh v);
 /// Gets or sets the mesh used as pole
 external AbstractMesh get poleTargetMesh; external set poleTargetMesh(AbstractMesh v);
 /// Gets or sets the bone used as pole
 external Bone/*Bone|Null*/ get poleTargetBone; external set poleTargetBone(Bone/*Bone|Null*/ v);
 /// Gets or sets the target position
 external Vector3 get targetPosition; external set targetPosition(Vector3 v);
 /// Gets or sets the pole target position
 external Vector3 get poleTargetPosition; external set poleTargetPosition(Vector3 v);
 /// Gets or sets the pole target local offset
 external Vector3 get poleTargetLocalOffset; external set poleTargetLocalOffset(Vector3 v);
 /// Gets or sets the pole angle
 external num get poleAngle; external set poleAngle(num v);
 /// Gets or sets the mesh associated with the controller
 external AbstractMesh get mesh; external set mesh(AbstractMesh v);
 /// The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
 external num get slerpAmount; external set slerpAmount(num v); external get JS$_bone1Quat; external set JS$_bone1Quat(v); external get JS$_bone1Mat; external set JS$_bone1Mat(v); external get JS$_bone2Ang; external set JS$_bone2Ang(v); external get JS$_bone1; external set JS$_bone1(v); external get JS$_bone2; external set JS$_bone2(v); external get JS$_bone1Length; external set JS$_bone1Length(v); external get JS$_bone2Length; external set JS$_bone2Length(v); external get JS$_maxAngle; external set JS$_maxAngle(v); external get JS$_maxReach; external set JS$_maxReach(v); external get JS$_rightHandedSystem; external set JS$_rightHandedSystem(v); external get JS$_bendAxis; external set JS$_bendAxis(v); external get JS$_slerping; external set JS$_slerping(v); external get JS$_adjustRoll; external set JS$_adjustRoll(v);
 /// Gets or sets maximum allowed angle
 external num get maxAngle; external set maxAngle(num v);
 /// Creates a new BoneIKController
 external factory BoneIKController(AbstractMesh mesh, Bone bone, [dynamic/*{
            targetMesh?: AbstractMesh;
            poleTargetMesh?: AbstractMesh;
            poleTargetBone?: Bone;
            poleTargetLocalOffset?: Vector3;
            poleAngle?: number;
            bendAxis?: Vector3;
            maxAngle?: number;
            slerpAmount?: number;
        }*/ options]); external JS$_setMaxAngle(ang);
 /// Force the controller to update the bones
 external void update(); }

 /// Class used to make a bone look toward a point in space
 /// @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons#bonelookcontroller
 @JS("BABYLON.BoneLookController" ) class BoneLookController { // @Ignore
 BoneLookController .fakeConstructor$() ;
 external static get JS$_tmpVecs; external static set JS$_tmpVecs(v); external static get JS$_tmpQuat; external static set JS$_tmpQuat(v); external static get JS$_tmpMats; external static set JS$_tmpMats(v);
 /// The target Vector3 that the bone will look at
 external Vector3 get target; external set target(Vector3 v);
 /// The mesh that the bone is attached to
 external AbstractMesh get mesh; external set mesh(AbstractMesh v);
 /// The bone that will be looking to the target
 external Bone get bone; external set bone(Bone v);
 /// The up axis of the coordinate system that is used when the bone is rotated
 external Vector3 get upAxis; external set upAxis(Vector3 v);
 /// The space that the up axis is in - BABYLON.Space.BONE, BABYLON.Space.LOCAL (default), or BABYLON.Space.WORLD
 external num/*enum Space*/ get upAxisSpace; external set upAxisSpace(num/*enum Space*/ v);
 /// Used to make an adjustment to the yaw of the bone
 external num get adjustYaw; external set adjustYaw(num v);
 /// Used to make an adjustment to the pitch of the bone
 external num get adjustPitch; external set adjustPitch(num v);
 /// Used to make an adjustment to the roll of the bone
 external num get adjustRoll; external set adjustRoll(num v);
 /// The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
 external num get slerpAmount; external set slerpAmount(num v); external get JS$_minYaw; external set JS$_minYaw(v); external get JS$_maxYaw; external set JS$_maxYaw(v); external get JS$_minPitch; external set JS$_minPitch(v); external get JS$_maxPitch; external set JS$_maxPitch(v); external get JS$_minYawSin; external set JS$_minYawSin(v); external get JS$_minYawCos; external set JS$_minYawCos(v); external get JS$_maxYawSin; external set JS$_maxYawSin(v); external get JS$_maxYawCos; external set JS$_maxYawCos(v); external get JS$_midYawConstraint; external set JS$_midYawConstraint(v); external get JS$_minPitchTan; external set JS$_minPitchTan(v); external get JS$_maxPitchTan; external set JS$_maxPitchTan(v); external get JS$_boneQuat; external set JS$_boneQuat(v); external get JS$_slerping; external set JS$_slerping(v); external get JS$_transformYawPitch; external set JS$_transformYawPitch(v); external get JS$_transformYawPitchInv; external set JS$_transformYawPitchInv(v); external get JS$_firstFrameSkipped; external set JS$_firstFrameSkipped(v); external get JS$_yawRange; external set JS$_yawRange(v); external get JS$_fowardAxis; external set JS$_fowardAxis(v);
 /// Gets or sets the minimum yaw angle that the bone can look to
 external num get minYaw; external set minYaw(num v);
 /// Gets or sets the maximum yaw angle that the bone can look to
 external num get maxYaw; external set maxYaw(num v);
 /// Gets or sets the minimum pitch angle that the bone can look to
 external num get minPitch; external set minPitch(num v);
 /// Gets or sets the maximum pitch angle that the bone can look to
 external num get maxPitch; external set maxPitch(num v);
 /// Create a BoneLookController
 /// * maxYaw: the maximum angle the bone will yaw to
 /// * minYaw: the minimum angle the bone will yaw to
 /// * maxPitch: the maximum angle the bone will pitch to
 /// * minPitch: the minimum angle the bone will yaw to
 /// * slerpAmount: set the between 0 and 1 to make the bone slerp to the target.
 /// * upAxis: the up axis of the coordinate system
 /// * upAxisSpace: the space that the up axis is in - BABYLON.Space.BONE, BABYLON.Space.LOCAL (default), or BABYLON.Space.WORLD.
 /// * yawAxis: set yawAxis if the bone does not yaw on the y axis
 /// * pitchAxis: set pitchAxis if the bone does not pitch on the x axis
 /// * adjustYaw: used to make an adjustment to the yaw of the bone
 /// * adjustPitch: used to make an adjustment to the pitch of the bone
 /// * adjustRoll: used to make an adjustment to the roll of the bone
 external factory BoneLookController(AbstractMesh mesh, Bone bone, Vector3 target, [dynamic/*{
            maxYaw?: number;
            minYaw?: number;
            maxPitch?: number;
            minPitch?: number;
            slerpAmount?: number;
            upAxis?: Vector3;
            upAxisSpace?: Space;
            yawAxis?: Vector3;
            pitchAxis?: Vector3;
            adjustYaw?: number;
            adjustPitch?: number;
            adjustRoll?: number;
        }*/ options]);
 /// Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())
 external void update(); external JS$_getAngleDiff(ang1, ang2); external JS$_getAngleBetween(ang1, ang2); external JS$_isAngleBetween(ang, ang1, ang2); }

 /// Class used to handle skinning animations
 /// @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
 @JS("BABYLON.Skeleton" ) class Skeleton implements IAnimatable { // @Ignore
 Skeleton .fakeConstructor$() ;
 /// defines the skeleton name
 external String get name; external set name(String v);
 /// defines the skeleton Id
 external String get id; external set id(String v);
 /// Gets the list of child bones
 external List<Bone> get bones; external set bones(List<Bone> v);
 /// Gets an estimate of the dimension of the skeleton at rest
 external Vector3 get dimensionsAtRest; external set dimensionsAtRest(Vector3 v);
 /// Gets a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)
 external bool get needInitialSkinMatrix; external set needInitialSkinMatrix(bool v);
 /// Gets the list of animations attached to this skeleton
 external List<Animation> get animations; external set animations(List<Animation> v); external get JS$_scene; external set JS$_scene(v); external get JS$_isDirty; external set JS$_isDirty(v); external get JS$_transformMatrices; external set JS$_transformMatrices(v); external get JS$_meshesWithPoseMatrix; external set JS$_meshesWithPoseMatrix(v); external get JS$_animatables; external set JS$_animatables(v); external get JS$_identity; external set JS$_identity(v); external get JS$_synchronizedWithMesh; external set JS$_synchronizedWithMesh(v); external get JS$_ranges; external set JS$_ranges(v); external get JS$_lastAbsoluteTransformsUpdateId; external set JS$_lastAbsoluteTransformsUpdateId(v);
 /// Specifies if the skeleton should be serialized
 external bool get doNotSerialize; external set doNotSerialize(bool v); external get JS$_animationPropertiesOverride; external set JS$_animationPropertiesOverride(v);
 /// Gets or sets the animation properties override
 external AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ get animationPropertiesOverride; external set animationPropertiesOverride(AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ v);
 /// An observable triggered before computing the skeleton's matrices
 external Observable<Skeleton> get onBeforeComputeObservable; external set onBeforeComputeObservable(Observable<Skeleton> v);
 /// Creates a new skeleton
 external factory Skeleton(
 /// defines the skeleton name
 String name,
 /// defines the skeleton Id
 String id, Scene scene);
 /// Gets the list of transform matrices to send to shaders (one matrix per bone)
 external Float32List getTransformMatrices(AbstractMesh mesh);
 /// Gets the current hosting scene
 external Scene getScene();
 /// Gets a string representing the current skeleton data
 external String toString([bool fullDetails]);
 /// Get bone's index searching by name
 external num getBoneIndexByName(String name);
 /// Creater a new animation range
 external void createAnimationRange(String name, num from, num to);
 /// Delete a specific animation range
 external void deleteAnimationRange(String name, [bool deleteFrames]);
 /// Gets a specific animation range
 external AnimationRange/*AnimationRange|Null*/ getAnimationRange(String name);
 /// Gets the list of all animation ranges defined on this skeleton
 external List<AnimationRange/*AnimationRange|Null*/> getAnimationRanges();
 /// Copy animation range from a source skeleton.
 /// This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences
 external bool copyAnimationRange(Skeleton source, String name, [bool rescaleAsRequired]);
 /// Forces the skeleton to go to rest pose
 external void returnToRest(); external JS$_getHighestAnimationFrame();
 /// Begin a specific animation range
 external Animatable/*Animatable|Null*/ beginAnimation(String name, [bool loop, num speedRatio, void onAnimationEnd()]);
 /// @hidden
 external void JS$_markAsDirty();
 /// @hidden
 external void JS$_registerMeshWithPoseMatrix(AbstractMesh mesh);
 /// @hidden
 external void JS$_unregisterMeshWithPoseMatrix(AbstractMesh mesh);
 /// @hidden
 external void JS$_computeTransformMatrices(Float32List targetMatrix, Matrix/*Matrix|Null*/ initialSkinMatrix);
 /// Build all resources required to render a skeleton
 external void prepare();
 /// Gets the list of animatables currently running for this skeleton
 external List<IAnimatable> getAnimatables();
 /// Clone the current skeleton
 external Skeleton clone(String name, String id);
 /// Enable animation blending for this skeleton
 /// @see http://doc.babylonjs.com/babylon101/animations#animation-blending
 external void enableBlending([num blendingSpeed]);
 /// Releases all resources associated with the current skeleton
 external void dispose();
 /// Serialize the skeleton in a JSON object
 external dynamic serialize();
 /// Creates a new skeleton from serialized data
 external static Skeleton Parse(dynamic parsedSkeleton, Scene scene);
 /// Compute all node absolute transforms
 external void computeAbsoluteTransforms([bool forceUpdate]);
 /// Gets the root pose matrix
 external Matrix/*Matrix|Null*/ getPoseMatrix();
 /// Sorts bones per internal index
 external void sortBones(); external JS$_sortBones(index, bones, visited); }

 @JS("BABYLON.Collider" ) class Collider { // @Ignore
 Collider .fakeConstructor$() ;
 /// Define if a collision was found
 external bool get collisionFound; external set collisionFound(bool v);
 /// Define last intersection point in local space
 external Vector3 get intersectionPoint; external set intersectionPoint(Vector3 v);
 /// Define last collided mesh
 external AbstractMesh/*AbstractMesh|Null*/ get collidedMesh; external set collidedMesh(AbstractMesh/*AbstractMesh|Null*/ v); external get JS$_collisionPoint; external set JS$_collisionPoint(v); external get JS$_planeIntersectionPoint; external set JS$_planeIntersectionPoint(v); external get JS$_tempVector; external set JS$_tempVector(v); external get JS$_tempVector2; external set JS$_tempVector2(v); external get JS$_tempVector3; external set JS$_tempVector3(v); external get JS$_tempVector4; external set JS$_tempVector4(v); external get JS$_edge; external set JS$_edge(v); external get JS$_baseToVertex; external set JS$_baseToVertex(v); external get JS$_destinationPoint; external set JS$_destinationPoint(v); external get JS$_slidePlaneNormal; external set JS$_slidePlaneNormal(v); external get JS$_displacementVector; external set JS$_displacementVector(v); external Vector3 get JS$_radius; external set JS$_radius(Vector3 v); external num get JS$_retry; external set JS$_retry(num v); external get JS$_velocity; external set JS$_velocity(v); external get JS$_basePoint; external set JS$_basePoint(v); external get JS$_epsilon; external set JS$_epsilon(v); external num get JS$_velocityWorldLength; external set JS$_velocityWorldLength(num v); external Vector3 get JS$_basePointWorld; external set JS$_basePointWorld(Vector3 v); external get JS$_velocityWorld; external set JS$_velocityWorld(v); external get JS$_normalizedVelocity; external set JS$_normalizedVelocity(v); external Vector3 get JS$_initialVelocity; external set JS$_initialVelocity(Vector3 v); external Vector3 get JS$_initialPosition; external set JS$_initialPosition(Vector3 v); external get JS$_nearestDistance; external set JS$_nearestDistance(v); external get JS$_collisionMask; external set JS$_collisionMask(v); external num get collisionMask; external set collisionMask(num v);
 /// Gets the plane normal used to compute the sliding response (in local space)
 external Vector3 get slidePlaneNormal; external set slidePlaneNormal(Vector3 v); external void JS$_initialize(Vector3 source, Vector3 dir, num e); external bool JS$_checkPointInTriangle(Vector3 point, Vector3 pa, Vector3 pb, Vector3 pc, Vector3 n); external bool JS$_canDoCollision(Vector3 sphereCenter, num sphereRadius, Vector3 vecMin, Vector3 vecMax); external void JS$_testTriangle(num faceIndex, List<Plane> trianglePlaneArray, Vector3 p1, Vector3 p2, Vector3 p3, bool hasMaterial); external void JS$_collide(List<Plane> trianglePlaneArray, List<Vector3> pts, dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, num indexStart, num indexEnd, num decal, bool hasMaterial); external void JS$_getResponse(Vector3 pos, Vector3 vel); }

 @JS("BABYLON.CollisionWorker" ) external String get CollisionWorker; @JS("BABYLON.CollisionWorker" ) external set CollisionWorker(String v); @anonymous @JS() abstract class ICollisionCoordinator { external void getNewPosition(Vector3 position, Vector3 displacement, Collider collider, num maximumRetry, AbstractMesh/*AbstractMesh|Null*/ excludedMesh, void onNewPosition(num collisionIndex, Vector3 newPosition, AbstractMesh/*AbstractMesh|Null*/ collidedMesh), num collisionIndex); external void init(Scene scene); external void destroy(); external void onMeshAdded(AbstractMesh mesh); external void onMeshUpdated(AbstractMesh mesh); external void onMeshRemoved(AbstractMesh mesh); external void onGeometryAdded(Geometry geometry); external void onGeometryUpdated(Geometry geometry); external void onGeometryDeleted(Geometry geometry); }

 @anonymous @JS() abstract class SerializedMesh { external String get id; external set id(String v); external String get name; external set name(String v); external num get uniqueId; external set uniqueId(num v); external String/*String|Null*/ get geometryId; external set geometryId(String/*String|Null*/ v); external List<num> get sphereCenter; external set sphereCenter(List<num> v); external num get sphereRadius; external set sphereRadius(num v); external List<num> get boxMinimum; external set boxMinimum(List<num> v); external List<num> get boxMaximum; external set boxMaximum(List<num> v); external dynamic get worldMatrixFromCache; external set worldMatrixFromCache(dynamic v); external List<SerializedSubMesh> get subMeshes; external set subMeshes(List<SerializedSubMesh> v); external bool get checkCollisions; external set checkCollisions(bool v); external factory SerializedMesh({ String id, String name, num uniqueId, String/*String|Null*/ geometryId, List<num> sphereCenter, num sphereRadius, List<num> boxMinimum, List<num> boxMaximum, dynamic worldMatrixFromCache, List<SerializedSubMesh> subMeshes, bool checkCollisions}); }

 @anonymous @JS() abstract class SerializedSubMesh { external num get position; external set position(num v); external num get verticesStart; external set verticesStart(num v); external num get verticesCount; external set verticesCount(num v); external num get indexStart; external set indexStart(num v); external num get indexCount; external set indexCount(num v); external bool get hasMaterial; external set hasMaterial(bool v); external List<num> get sphereCenter; external set sphereCenter(List<num> v); external num get sphereRadius; external set sphereRadius(num v); external List<num> get boxMinimum; external set boxMinimum(List<num> v); external List<num> get boxMaximum; external set boxMaximum(List<num> v); external factory SerializedSubMesh({ num position, num verticesStart, num verticesCount, num indexStart, num indexCount, bool hasMaterial, List<num> sphereCenter, num sphereRadius, List<num> boxMinimum, List<num> boxMaximum}); }

 /// Interface describing the value associated with a geometry
 @anonymous @JS() abstract class SerializedGeometry {
 /// Defines the unique ID of the geometry
 external String get id; external set id(String v);
 /// Defines the array containing the positions
 external Float32List get positions; external set positions(Float32List v);
 /// Defines the array containing the indices
 external Uint32List get indices; external set indices(Uint32List v);
 /// Defines the array containing the normals
 external Float32List get normals; external set normals(Float32List v); external factory SerializedGeometry({ String id, Float32List positions, Uint32List indices, Float32List normals}); }

 @anonymous @JS() abstract class BabylonMessage { external num/*enum WorkerTaskType*/ get taskType; external set taskType(num/*enum WorkerTaskType*/ v); external dynamic/*InitPayload|CollidePayload|UpdatePayload*/ get payload; external set payload(dynamic/*InitPayload|CollidePayload|UpdatePayload*/ v); external factory BabylonMessage({ num/*enum WorkerTaskType*/ taskType, dynamic/*InitPayload|CollidePayload|UpdatePayload*/ payload}); }

 @anonymous @JS() abstract class SerializedColliderToWorker { external List<num> get position; external set position(List<num> v); external List<num> get velocity; external set velocity(List<num> v); external List<num> get radius; external set radius(List<num> v); external factory SerializedColliderToWorker({ List<num> position, List<num> velocity, List<num> radius}); }

 /// Defines supported task for worker process
 @JS("BABYLON.WorkerTaskType" ) class WorkerTaskType { external static num get
 /// Initialization
 INIT; external static num get
 /// Update of geometry
 UPDATE; external static num get
 /// Evaluate collision
 COLLIDE; } @anonymous @JS() abstract class WorkerReply { external num/*enum WorkerReplyType*/ get error; external set error(num/*enum WorkerReplyType*/ v); external num/*enum WorkerTaskType*/ get taskType; external set taskType(num/*enum WorkerTaskType*/ v); external dynamic get payload; external set payload(dynamic v); external factory WorkerReply({ num/*enum WorkerReplyType*/ error, num/*enum WorkerTaskType*/ taskType, dynamic payload}); }

 @anonymous @JS() abstract class CollisionReplyPayload { external List<num> get newPosition; external set newPosition(List<num> v); external num get collisionId; external set collisionId(num v); external num get collidedMeshUniqueId; external set collidedMeshUniqueId(num v); external factory CollisionReplyPayload({ List<num> newPosition, num collisionId, num collidedMeshUniqueId}); }

 @anonymous @JS() abstract class InitPayload { }

 @anonymous @JS() abstract class CollidePayload { external num get collisionId; external set collisionId(num v); external SerializedColliderToWorker get collider; external set collider(SerializedColliderToWorker v); external num get maximumRetry; external set maximumRetry(num v); external num/*num|Null*/ get excludedMeshUniqueId; external set excludedMeshUniqueId(num/*num|Null*/ v); external factory CollidePayload({ num collisionId, SerializedColliderToWorker collider, num maximumRetry, num/*num|Null*/ excludedMeshUniqueId}); }

 @anonymous @JS() abstract class UpdatePayload { external dynamic/*JSMap of <num,SerializedMesh>*/ get updatedMeshes; external set updatedMeshes(dynamic/*JSMap of <num,SerializedMesh>*/ v); external dynamic/*JSMap of <String,SerializedGeometry>*/ get updatedGeometries; external set updatedGeometries(dynamic/*JSMap of <String,SerializedGeometry>*/ v); external List<num> get removedMeshes; external set removedMeshes(List<num> v); external List<String> get removedGeometries; external set removedGeometries(List<String> v); external factory UpdatePayload({ dynamic/*JSMap of <num,SerializedMesh>*/ updatedMeshes, dynamic/*JSMap of <String,SerializedGeometry>*/ updatedGeometries, List<num> removedMeshes, List<String> removedGeometries}); }

 /// Defines kind of replies returned by worker
 @JS("BABYLON.WorkerReplyType" ) class WorkerReplyType { external static num get
 /// Success
 SUCCESS; external static num get
 /// Unkown error
 UNKNOWN_ERROR; } @JS("BABYLON.CollisionCoordinatorWorker" ) class CollisionCoordinatorWorker implements ICollisionCoordinator { // @Ignore
 CollisionCoordinatorWorker .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_scaledPosition; external set JS$_scaledPosition(v); external get JS$_scaledVelocity; external set JS$_scaledVelocity(v); external get JS$_collisionsCallbackArray; external set JS$_collisionsCallbackArray(v); external get JS$_init; external set JS$_init(v); external get JS$_runningUpdated; external set JS$_runningUpdated(v); external get JS$_worker; external set JS$_worker(v); external get JS$_addUpdateMeshesList; external set JS$_addUpdateMeshesList(v); external get JS$_addUpdateGeometriesList; external set JS$_addUpdateGeometriesList(v); external get JS$_toRemoveMeshesArray; external set JS$_toRemoveMeshesArray(v); external get JS$_toRemoveGeometryArray; external set JS$_toRemoveGeometryArray(v); external factory CollisionCoordinatorWorker(); external static Func1<AbstractMesh, SerializedMesh> get SerializeMesh; external static set SerializeMesh(Func1<AbstractMesh, SerializedMesh> v); external static Func1<Geometry, SerializedGeometry> get SerializeGeometry; external static set SerializeGeometry(Func1<Geometry, SerializedGeometry> v); external void getNewPosition(Vector3 position, Vector3 displacement, Collider collider, num maximumRetry, AbstractMesh excludedMesh, void onNewPosition(num collisionIndex, Vector3 newPosition, AbstractMesh/*AbstractMesh|Null*/ collidedMesh), num collisionIndex); external void init(Scene scene); external void destroy(); external void onMeshAdded(AbstractMesh mesh); external VoidFunc1<TransformNode> get onMeshUpdated; external set onMeshUpdated(VoidFunc1<TransformNode> v); external void onMeshRemoved(AbstractMesh mesh); external void onGeometryAdded(Geometry geometry); external VoidFunc1<Geometry> get onGeometryUpdated; external set onGeometryUpdated(VoidFunc1<Geometry> v); external void onGeometryDeleted(Geometry geometry); external get JS$_afterRender; external set JS$_afterRender(v); external get JS$_onMessageFromWorker; external set JS$_onMessageFromWorker(v); }

 @JS("BABYLON.CollisionCoordinatorLegacy" ) class CollisionCoordinatorLegacy implements ICollisionCoordinator { // @Ignore
 CollisionCoordinatorLegacy .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_scaledPosition; external set JS$_scaledPosition(v); external get JS$_scaledVelocity; external set JS$_scaledVelocity(v); external get JS$_finalPosition; external set JS$_finalPosition(v); external void getNewPosition(Vector3 position, Vector3 displacement, Collider collider, num maximumRetry, AbstractMesh excludedMesh, void onNewPosition(num collisionIndex, Vector3 newPosition, AbstractMesh/*AbstractMesh|Null*/ collidedMesh), num collisionIndex); external void init(Scene scene); external void destroy(); external void onMeshAdded(AbstractMesh mesh); external void onMeshUpdated(AbstractMesh mesh); external void onMeshRemoved(AbstractMesh mesh); external void onGeometryAdded(Geometry geometry); external void onGeometryUpdated(Geometry geometry); external void onGeometryDeleted(Geometry geometry); external JS$_collideWithWorld(position, velocity, collider, maximumRetry, finalPosition, [excludedMesh]); }

 @JS("BABYLON.WorkerIncluded" ) external bool get WorkerIncluded; @JS("BABYLON.WorkerIncluded" ) external set WorkerIncluded(bool v); @JS("BABYLON.CollisionCache" ) class CollisionCache { // @Ignore
 CollisionCache .fakeConstructor$() ;
 external get JS$_meshes; external set JS$_meshes(v); external get JS$_geometries; external set JS$_geometries(v); external dynamic/*JSMap of <num,SerializedMesh>*/ getMeshes(); external dynamic/*JSMap of <num,SerializedGeometry>*/ getGeometries(); external SerializedMesh getMesh(dynamic id); external void addMesh(SerializedMesh mesh); external void removeMesh(num uniqueId); external SerializedGeometry getGeometry(String id); external void addGeometry(SerializedGeometry geometry); external void removeGeometry(String id); }

 @JS("BABYLON.CollideWorker" ) class CollideWorker { // @Ignore
 CollideWorker .fakeConstructor$() ;
 external Collider get collider; external set collider(Collider v); external get JS$_collisionCache; external set JS$_collisionCache(v); external get finalPosition; external set finalPosition(v); external get collisionsScalingMatrix; external set collisionsScalingMatrix(v); external get collisionTranformationMatrix; external set collisionTranformationMatrix(v); external factory CollideWorker(Collider collider, CollisionCache JS$_collisionCache, Vector3 finalPosition); external void collideWithWorld(Vector3 position, Vector3 velocity, num maximumRetry, num/*num|Null*/ excludedMeshUniqueId); external checkCollision(mesh); external processCollisionsForSubMeshes(transformMatrix, mesh); external collideForSubMesh(subMesh, transformMatrix, meshGeometry); external checkSubmeshCollision(subMesh); }

 @anonymous @JS() abstract class ICollisionDetector { external void onInit(InitPayload payload); external void onUpdate(UpdatePayload payload); external void onCollision(CollidePayload payload); }

 @JS("BABYLON.CollisionDetectorTransferable" ) class CollisionDetectorTransferable implements ICollisionDetector { // @Ignore
 CollisionDetectorTransferable .fakeConstructor$() ;
 external get JS$_collisionCache; external set JS$_collisionCache(v); external void onInit(InitPayload payload); external void onUpdate(UpdatePayload payload); external void onCollision(CollidePayload payload); }

 @JS("BABYLON.IntersectionInfo" ) class IntersectionInfo { // @Ignore
 IntersectionInfo .fakeConstructor$() ;
 external num/*num|Null*/ get bu; external set bu(num/*num|Null*/ v); external num/*num|Null*/ get bv; external set bv(num/*num|Null*/ v); external num get distance; external set distance(num v); external num get faceId; external set faceId(num v); external num get subMeshId; external set subMeshId(num v); external factory IntersectionInfo(num/*num|Null*/ bu, num/*num|Null*/ bv, num distance); }

 @JS("BABYLON.PickingInfo" ) class PickingInfo { // @Ignore
 PickingInfo .fakeConstructor$() ;
 external bool get hit; external set hit(bool v); external num get distance; external set distance(num v); external Vector3/*Vector3|Null*/ get pickedPoint; external set pickedPoint(Vector3/*Vector3|Null*/ v); external AbstractMesh/*AbstractMesh|Null*/ get pickedMesh; external set pickedMesh(AbstractMesh/*AbstractMesh|Null*/ v); external num get bu; external set bu(num v); external num get bv; external set bv(num v); external num get faceId; external set faceId(num v); external num get subMeshId; external set subMeshId(num v); external Sprite/*Sprite|Null*/ get pickedSprite; external set pickedSprite(Sprite/*Sprite|Null*/ v); external Vector3/*Vector3|Null*/ getNormal([bool useWorldCoordinates, bool useVerticesNormals]); external Vector2/*Vector2|Null*/ getTextureCoordinates(); }

 @JS("BABYLON.ArcRotateCamera" ) class ArcRotateCamera extends TargetCamera { // @Ignore
 ArcRotateCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external num get alpha; external set alpha(num v); external num get beta; external set beta(num v); external num get radius; external set radius(num v); external Vector3 get JS$_target; external set JS$_target(Vector3 v); external AbstractMesh/*AbstractMesh|Null*/ get JS$_targetHost; external set JS$_targetHost(AbstractMesh/*AbstractMesh|Null*/ v); external Vector3 get target; external set target(Vector3 v); external num get inertialAlphaOffset; external set inertialAlphaOffset(num v); external num get inertialBetaOffset; external set inertialBetaOffset(num v); external num get inertialRadiusOffset; external set inertialRadiusOffset(num v); external num/*num|Null*/ get lowerAlphaLimit; external set lowerAlphaLimit(num/*num|Null*/ v); external num/*num|Null*/ get upperAlphaLimit; external set upperAlphaLimit(num/*num|Null*/ v); external num get lowerBetaLimit; external set lowerBetaLimit(num v); external num get upperBetaLimit; external set upperBetaLimit(num v); external num/*num|Null*/ get lowerRadiusLimit; external set lowerRadiusLimit(num/*num|Null*/ v); external num/*num|Null*/ get upperRadiusLimit; external set upperRadiusLimit(num/*num|Null*/ v); external num get inertialPanningX; external set inertialPanningX(num v); external num get inertialPanningY; external set inertialPanningY(num v); external num get pinchToPanMaxDistance; external set pinchToPanMaxDistance(num v); external num/*num|Null*/ get panningDistanceLimit; external set panningDistanceLimit(num/*num|Null*/ v); external Vector3 get panningOriginTarget; external set panningOriginTarget(Vector3 v); external num get panningInertia; external set panningInertia(num v); external num get angularSensibilityX; external set angularSensibilityX(num v); external num get angularSensibilityY; external set angularSensibilityY(num v); external num get pinchPrecision; external set pinchPrecision(num v); external num get pinchDeltaPercentage; external set pinchDeltaPercentage(num v); external num get panningSensibility; external set panningSensibility(num v); external List<num> get keysUp; external set keysUp(List<num> v); external List<num> get keysDown; external set keysDown(List<num> v); external List<num> get keysLeft; external set keysLeft(List<num> v); external List<num> get keysRight; external set keysRight(List<num> v); external num get wheelPrecision; external set wheelPrecision(num v); external num get wheelDeltaPercentage; external set wheelDeltaPercentage(num v); external num get zoomOnFactor; external set zoomOnFactor(num v); external Vector2 get targetScreenOffset; external set targetScreenOffset(Vector2 v); external bool get allowUpsideDown; external set allowUpsideDown(bool v); external Matrix get JS$_viewMatrix; external set JS$_viewMatrix(Matrix v); external bool get JS$_useCtrlForPanning; external set JS$_useCtrlForPanning(bool v); external num get JS$_panningMouseButton; external set JS$_panningMouseButton(num v); external ArcRotateCameraInputsManager get inputs; external set inputs(ArcRotateCameraInputsManager v); external VoidFunc0 get JS$_reset; external set JS$_reset(VoidFunc0 v); external Vector3 get panningAxis; external set panningAxis(Vector3 v); external Vector3 get JS$_localDirection; external set JS$_localDirection(Vector3 v); external Vector3 get JS$_transformedDirection; external set JS$_transformedDirection(Vector3 v); external get JS$_bouncingBehavior; external set JS$_bouncingBehavior(v); external BouncingBehavior/*BouncingBehavior|Null*/ get bouncingBehavior; external set bouncingBehavior(BouncingBehavior/*BouncingBehavior|Null*/ v); external bool get useBouncingBehavior; external set useBouncingBehavior(bool v); external get JS$_framingBehavior; external set JS$_framingBehavior(v); external FramingBehavior/*FramingBehavior|Null*/ get framingBehavior; external set framingBehavior(FramingBehavior/*FramingBehavior|Null*/ v); external bool get useFramingBehavior; external set useFramingBehavior(bool v); external get JS$_autoRotationBehavior; external set JS$_autoRotationBehavior(v); external AutoRotationBehavior/*AutoRotationBehavior|Null*/ get autoRotationBehavior; external set autoRotationBehavior(AutoRotationBehavior/*AutoRotationBehavior|Null*/ v); external bool get useAutoRotationBehavior; external set useAutoRotationBehavior(bool v); external Observable<AbstractMesh/*AbstractMesh|Null*/> get onMeshTargetChangedObservable; external set onMeshTargetChangedObservable(Observable<AbstractMesh/*AbstractMesh|Null*/> v); external VoidFunc1<AbstractMesh> get onCollide; external set onCollide(VoidFunc1<AbstractMesh> v); external bool get checkCollisions; external set checkCollisions(bool v); external Vector3 get collisionRadius; external set collisionRadius(Vector3 v); external Collider get JS$_collider; external set JS$_collider(Collider v); external Vector3 get JS$_previousPosition; external set JS$_previousPosition(Vector3 v); external Vector3 get JS$_collisionVelocity; external set JS$_collisionVelocity(Vector3 v); external Vector3 get JS$_newPosition; external set JS$_newPosition(Vector3 v); external num get JS$_previousAlpha; external set JS$_previousAlpha(num v); external num get JS$_previousBeta; external set JS$_previousBeta(num v); external num get JS$_previousRadius; external set JS$_previousRadius(num v); external bool get JS$_collisionTriggered; external set JS$_collisionTriggered(bool v); external Vector3/*Vector3|Null*/ get JS$_targetBoundingCenter; external set JS$_targetBoundingCenter(Vector3/*Vector3|Null*/ v); external get JS$_computationVector; external set JS$_computationVector(v); external factory ArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, Scene scene, [bool setActiveOnSceneIfNoneActive]); external void JS$_initCache(); external void JS$_updateCache([bool ignoreParentClass]); external Vector3 JS$_getTargetPosition();
 /// Store current camera state (fov, position, etc..)
 external get JS$_storedAlpha; external set JS$_storedAlpha(v); external get JS$_storedBeta; external set JS$_storedBeta(v); external get JS$_storedRadius; external set JS$_storedRadius(v); external get JS$_storedTarget; external set JS$_storedTarget(v); external Camera storeState();
 /// Restored camera state. You must call storeState() first
 external bool JS$_restoreStateValues(); external bool JS$_isSynchronizedViewMatrix(); external void attachControl(HtmlElement element, [bool noPreventDefault, bool useCtrlForPanning, num panningMouseButton]); external void detachControl(HtmlElement element); external void JS$_checkInputs(); external void JS$_checkLimits(); external void rebuildAnglesAndRadius(); external void setPosition(Vector3 position); external void setTarget(dynamic/*AbstractMesh|Vector3*/ target, [bool toBoundingCenter, bool allowSamePosition]); external Matrix JS$_getViewMatrix(); external VoidFunc3Opt1<num, Vector3, AbstractMesh/*AbstractMesh|Null*/> get JS$_onCollisionPositionChange; external set JS$_onCollisionPositionChange(VoidFunc3Opt1<num, Vector3, AbstractMesh/*AbstractMesh|Null*/> v); external void zoomOn([List<AbstractMesh> meshes, bool doNotUpdateMaxZ]); external void focusOn(dynamic/*List<AbstractMesh>|{
            min: Vector3;
            max: Vector3;
            distance: number;
        }*/ meshesOrMinMaxVectorAndDistance, [bool doNotUpdateMaxZ]);
 /// @override
 /// Override Camera.createRigCamera
 external Camera createRigCamera(String name, num cameraIndex);
 /// @override
 /// Override Camera._updateRigCameras
 external void JS$_updateRigCameras(); external void dispose(); external String getClassName(); }

 @JS("BABYLON.ArcRotateCameraInputsManager" ) class ArcRotateCameraInputsManager extends CameraInputsManager<ArcRotateCamera> { // @Ignore
 ArcRotateCameraInputsManager .fakeConstructor$() : super.fakeConstructor$() ;
 external factory ArcRotateCameraInputsManager(ArcRotateCamera camera); external ArcRotateCameraInputsManager addMouseWheel(); external ArcRotateCameraInputsManager addPointers(); external ArcRotateCameraInputsManager addKeyboard(); external ArcRotateCameraInputsManager addGamepad(); external ArcRotateCameraInputsManager addVRDeviceOrientation(); }

 @JS("BABYLON.Camera" ) class Camera extends Node { // @Ignore
 Camera .fakeConstructor$() : super.fakeConstructor$() ;
 external CameraInputsManager<Camera> get inputs; external set inputs(CameraInputsManager<Camera> v); external static get JS$_PERSPECTIVE_CAMERA; external static set JS$_PERSPECTIVE_CAMERA(v); external static get JS$_ORTHOGRAPHIC_CAMERA; external static set JS$_ORTHOGRAPHIC_CAMERA(v); external static get JS$_FOVMODE_VERTICAL_FIXED; external static set JS$_FOVMODE_VERTICAL_FIXED(v); external static get JS$_FOVMODE_HORIZONTAL_FIXED; external static set JS$_FOVMODE_HORIZONTAL_FIXED(v); external static get JS$_RIG_MODE_NONE; external static set JS$_RIG_MODE_NONE(v); external static get JS$_RIG_MODE_STEREOSCOPIC_ANAGLYPH; external static set JS$_RIG_MODE_STEREOSCOPIC_ANAGLYPH(v); external static get JS$_RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL; external static set JS$_RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL(v); external static get JS$_RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED; external static set JS$_RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED(v); external static get JS$_RIG_MODE_STEREOSCOPIC_OVERUNDER; external static set JS$_RIG_MODE_STEREOSCOPIC_OVERUNDER(v); external static get JS$_RIG_MODE_VR; external static set JS$_RIG_MODE_VR(v); external static get JS$_RIG_MODE_WEBVR; external static set JS$_RIG_MODE_WEBVR(v); external static num get PERSPECTIVE_CAMERA; external static set PERSPECTIVE_CAMERA(num v); external static num get ORTHOGRAPHIC_CAMERA; external static set ORTHOGRAPHIC_CAMERA(num v);
 /// This is the default FOV mode for perspective cameras.
 /// This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.
 external static num get FOVMODE_VERTICAL_FIXED; external static set FOVMODE_VERTICAL_FIXED(num v);
 /// This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.
 external static num get FOVMODE_HORIZONTAL_FIXED; external static set FOVMODE_HORIZONTAL_FIXED(num v); external static num get RIG_MODE_NONE; external static set RIG_MODE_NONE(num v); external static num get RIG_MODE_STEREOSCOPIC_ANAGLYPH; external static set RIG_MODE_STEREOSCOPIC_ANAGLYPH(num v); external static num get RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL; external static set RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL(num v); external static num get RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED; external static set RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED(num v); external static num get RIG_MODE_STEREOSCOPIC_OVERUNDER; external static set RIG_MODE_STEREOSCOPIC_OVERUNDER(num v); external static num get RIG_MODE_VR; external static set RIG_MODE_VR(num v); external static num get RIG_MODE_WEBVR; external static set RIG_MODE_WEBVR(num v); external static bool get ForceAttachControlToAlwaysPreventDefault; external static set ForceAttachControlToAlwaysPreventDefault(bool v); external static bool get UseAlternateWebVRRendering; external static set UseAlternateWebVRRendering(bool v); external Vector3 get position; external set position(Vector3 v);
 /// The vector the camera should consider as up.
 /// (default is Vector3(0, 1, 0) aka Vector3.Up())
 external Vector3 get upVector; external set upVector(Vector3 v); external num/*num|Null*/ get orthoLeft; external set orthoLeft(num/*num|Null*/ v); external num/*num|Null*/ get orthoRight; external set orthoRight(num/*num|Null*/ v); external num/*num|Null*/ get orthoBottom; external set orthoBottom(num/*num|Null*/ v); external num/*num|Null*/ get orthoTop; external set orthoTop(num/*num|Null*/ v);
 /// FOV is set in Radians. (default is 0.8)
 external num get fov; external set fov(num v); external num get minZ; external set minZ(num v); external num get maxZ; external set maxZ(num v); external num get inertia; external set inertia(num v); external num get mode; external set mode(num v); external bool get isIntermediate; external set isIntermediate(bool v); external Viewport get viewport; external set viewport(Viewport v);
 /// Restricts the camera to viewing objects with the same layerMask.
 /// A camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0
 external num get layerMask; external set layerMask(num v);
 /// fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)
 external num get fovMode; external set fovMode(num v); external num get cameraRigMode; external set cameraRigMode(num v); external num get interaxialDistance; external set interaxialDistance(num v); external bool get isStereoscopicSideBySide; external set isStereoscopicSideBySide(bool v); external dynamic get JS$_cameraRigParams; external set JS$_cameraRigParams(dynamic v); external List<Camera> get JS$_rigCameras; external set JS$_rigCameras(List<Camera> v); external PostProcess/*PostProcess|Null*/ get JS$_rigPostProcess; external set JS$_rigPostProcess(PostProcess/*PostProcess|Null*/ v); external Matrix get JS$_webvrViewMatrix; external set JS$_webvrViewMatrix(Matrix v); external bool get JS$_skipRendering; external set JS$_skipRendering(bool v); external Camera get JS$_alternateCamera; external set JS$_alternateCamera(Camera v); external List<RenderTargetTexture> get customRenderTargets; external set customRenderTargets(List<RenderTargetTexture> v); external Observable<Camera> get onViewMatrixChangedObservable; external set onViewMatrixChangedObservable(Observable<Camera> v); external Observable<Camera> get onProjectionMatrixChangedObservable; external set onProjectionMatrixChangedObservable(Observable<Camera> v); external Observable<Camera> get onAfterCheckInputsObservable; external set onAfterCheckInputsObservable(Observable<Camera> v); external Observable<Camera> get onRestoreStateObservable; external set onRestoreStateObservable(Observable<Camera> v); external get JS$_computedViewMatrix; external set JS$_computedViewMatrix(v); external Matrix get JS$_projectionMatrix; external set JS$_projectionMatrix(Matrix v); external get JS$_doNotComputeProjectionMatrix; external set JS$_doNotComputeProjectionMatrix(v); external get JS$_worldMatrix; external set JS$_worldMatrix(v); external List<PostProcess/*PostProcess|Null*/> get JS$_postProcesses; external set JS$_postProcesses(List<PostProcess/*PostProcess|Null*/> v); external get JS$_transformMatrix; external set JS$_transformMatrix(v); external SmartArray<AbstractMesh> get JS$_activeMeshes; external set JS$_activeMeshes(SmartArray<AbstractMesh> v); external Vector3 get JS$_globalPosition; external set JS$_globalPosition(Vector3 v); external get JS$_frustumPlanes; external set JS$_frustumPlanes(v); external get JS$_refreshFrustumPlanes; external set JS$_refreshFrustumPlanes(v); external factory Camera(String name, Vector3 position, Scene scene, [bool setActiveOnSceneIfNoneActive]); external get JS$_storedFov; external set JS$_storedFov(v); external get JS$_stateStored; external set JS$_stateStored(v);
 /// Store current camera state (fov, position, etc..)
 external Camera storeState();
 /// Restores the camera state values if it has been stored. You must call storeState() first
 external bool JS$_restoreStateValues();
 /// Restored camera state. You must call storeState() first
 external bool restoreState(); external String getClassName();
 external String toString([bool fullDetails]); external Vector3 get globalPosition; external set globalPosition(Vector3 v); external SmartArray<AbstractMesh> getActiveMeshes(); external bool isActiveMesh(Mesh mesh);
 /// Is this camera ready to be used/rendered
 external bool isReady([bool completeCheck]); external void JS$_initCache(); external void JS$_updateCache([bool ignoreParentClass]); external bool JS$_isSynchronized(); external bool JS$_isSynchronizedViewMatrix(); external bool JS$_isSynchronizedProjectionMatrix(); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement element); external void update(); external void JS$_checkInputs(); external List<Camera> get rigCameras; external set rigCameras(List<Camera> v); external PostProcess/*PostProcess|Null*/ get rigPostProcess; external set rigPostProcess(PostProcess/*PostProcess|Null*/ v);
 /// Internal, gets the first post proces.
 external PostProcess/*PostProcess|Null*/ JS$_getFirstPostProcess(); external JS$_cascadePostProcessesToRigCams(); external num attachPostProcess(PostProcess postProcess, [num/*num|Null*/ insertAt]); external void detachPostProcess(PostProcess postProcess); external Matrix getWorldMatrix(); external Matrix JS$_getViewMatrix(); external Matrix getViewMatrix([bool force]); external void freezeProjectionMatrix([Matrix projection]); external void unfreezeProjectionMatrix(); external Matrix getProjectionMatrix([bool force]); external Matrix getTranformationMatrix(); external updateFrustumPlanes(); external bool isInFrustum(ICullable target); external bool isCompletelyInFrustum(ICullable target); external Ray getForwardRay([num length, Matrix transform, Vector3 origin]);
 /// Releases resources associated with this node.
 external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]); external FreeCamera/*FreeCamera|Null*/ get leftCamera; external set leftCamera(FreeCamera/*FreeCamera|Null*/ v); external FreeCamera/*FreeCamera|Null*/ get rightCamera; external set rightCamera(FreeCamera/*FreeCamera|Null*/ v); external Vector3/*Vector3|Null*/ getLeftTarget(); external Vector3/*Vector3|Null*/ getRightTarget(); external void setCameraRigMode(num mode, dynamic rigParams); external JS$_getVRProjectionMatrix(); external void JS$_updateCameraRotationMatrix(); external void JS$_updateWebVRCameraRotationMatrix();
 /// This function MUST be overwritten by the different WebVR cameras available.
 /// The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.
 external Matrix JS$_getWebVRProjectionMatrix();
 /// This function MUST be overwritten by the different WebVR cameras available.
 /// The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.
 external Matrix JS$_getWebVRViewMatrix(); external void setCameraRigParameter(String name, dynamic value);
 /// needs to be overridden by children so sub has required properties to be copied
 external Camera/*Camera|Null*/ createRigCamera(String name, num cameraIndex);
 /// May need to be overridden by children
 external void JS$_updateRigCameras(); external void JS$_setupInputs(); external dynamic serialize(); external Camera clone(String name); external Vector3 getDirection(Vector3 localAxis); external void getDirectionToRef(Vector3 localAxis, Vector3 result); external static Func0<Camera> GetConstructorFromName(String type, String name, Scene scene, [num interaxial_distance, bool isStereoscopicSideBySide]); external Matrix computeWorldMatrix(); external static Camera Parse(dynamic parsedCamera, Scene scene); }

 @JS("BABYLON.CameraInputTypes" ) external dynamic/*{}*/ get CameraInputTypes; @JS("BABYLON.CameraInputTypes" ) external set CameraInputTypes(dynamic/*{}*/ v); @anonymous @JS() abstract class ICameraInput <TCamera extends Camera > { external TCamera/*TCamera|Null*/ get camera; external set camera(TCamera/*TCamera|Null*/ v); external String getClassName(); external String getSimpleName(); external VoidFunc2Opt1<HtmlElement, bool> get attachControl; external set attachControl(VoidFunc2Opt1<HtmlElement, bool> v); external VoidFunc1<HtmlElement/*HtmlElement|Null*/> get detachControl; external set detachControl(VoidFunc1<HtmlElement/*HtmlElement|Null*/> v); external VoidFunc0 get checkInputs; external set checkInputs(VoidFunc0 v); }

 @anonymous @JS() abstract class CameraInputsMap <TCamera extends Camera > {
 /*/* Index signature is not yet supported by JavaScript interop. */*/
 /*/* Index signature is not yet supported by JavaScript interop. */*/
 /* Index signature is not yet supported by JavaScript interop. */
 }

 @JS("BABYLON.CameraInputsManager" ) class CameraInputsManager <TCamera extends Camera > { // @Ignore
 CameraInputsManager .fakeConstructor$() ;
 external CameraInputsMap<TCamera> get attached; external set attached(CameraInputsMap<TCamera> v); external HtmlElement/*HtmlElement|Null*/ get attachedElement; external set attachedElement(HtmlElement/*HtmlElement|Null*/ v); external bool get noPreventDefault; external set noPreventDefault(bool v); external TCamera get camera; external set camera(TCamera v); external VoidFunc0 get checkInputs; external set checkInputs(VoidFunc0 v); external factory CameraInputsManager(TCamera camera);
 /// Add an input method to a camera.
 /// builtin inputs example: camera.inputs.addGamepad();
 /// custom inputs example: camera.inputs.add(new BABYLON.FreeCameraGamepadInput());
 external void add(ICameraInput<TCamera> input);
 /// Remove a specific input method from a camera
 /// example: camera.inputs.remove(camera.inputs.attached.mouse);
 external void remove(ICameraInput<TCamera> inputToRemove); external void removeByType(String inputType); external JS$_addCheckInputs(fn); external void attachInput(ICameraInput<TCamera> input); external void attachElement(HtmlElement element, [bool noPreventDefault]); external void detachElement(HtmlElement element, [bool disconnect]); external void rebuildInputCheck();
 /// Remove all attached input methods from a camera
 external void clear(); external void serialize(dynamic serializedCamera); external void parse(dynamic parsedCamera); }

 /// This is a camera specifically designed to react to device orientation events such as a modern mobile device
 /// being tilted forward or back and left or right.
 @JS("BABYLON.DeviceOrientationCamera" ) class DeviceOrientationCamera extends FreeCamera { // @Ignore
 DeviceOrientationCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_initialQuaternion; external set JS$_initialQuaternion(v); external get JS$_quaternionCache; external set JS$_quaternionCache(v);
 /// Creates a new device orientation camera
 external factory DeviceOrientationCamera(String name, Vector3 position, Scene scene);
 /// Gets the current instance class name ("DeviceOrientationCamera").
 /// This helps avoiding instanceof at run time.
 external String getClassName();
 /// Checks and applies the current values of the inputs to the camera. (Internal use only)
 external void JS$_checkInputs();
 /// Reset the camera to its default orientation on the specified axis only.
 external void resetToCurrentRotation([Axis axis]); }

 @JS("BABYLON.FollowCamera" ) class FollowCamera extends TargetCamera { // @Ignore
 FollowCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external num get radius; external set radius(num v); external num get rotationOffset; external set rotationOffset(num v); external num get heightOffset; external set heightOffset(num v); external num get cameraAcceleration; external set cameraAcceleration(num v); external num get maxCameraSpeed; external set maxCameraSpeed(num v); external AbstractMesh/*AbstractMesh|Null*/ get lockedTarget; external set lockedTarget(AbstractMesh/*AbstractMesh|Null*/ v); external factory FollowCamera(String name, Vector3 position, Scene scene, [AbstractMesh/*AbstractMesh|Null*/ lockedTarget]); external getRadians(degrees); external follow(cameraTarget); external void JS$_checkInputs(); external String getClassName(); }

 @JS("BABYLON.ArcFollowCamera" ) class ArcFollowCamera extends TargetCamera { // @Ignore
 ArcFollowCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external num get alpha; external set alpha(num v); external num get beta; external set beta(num v); external num get radius; external set radius(num v); external AbstractMesh/*AbstractMesh|Null*/ get target; external set target(AbstractMesh/*AbstractMesh|Null*/ v); external get JS$_cartesianCoordinates; external set JS$_cartesianCoordinates(v); external factory ArcFollowCamera(String name, num alpha, num beta, num radius, AbstractMesh/*AbstractMesh|Null*/ target, Scene scene); external follow(); external void JS$_checkInputs(); external String getClassName(); }

 @JS("BABYLON.FreeCamera" ) class FreeCamera extends TargetCamera { // @Ignore
 FreeCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external Vector3 get ellipsoid; external set ellipsoid(Vector3 v); external Vector3 get ellipsoidOffset; external set ellipsoidOffset(Vector3 v); external bool get checkCollisions; external set checkCollisions(bool v); external bool get applyGravity; external set applyGravity(bool v); external FreeCameraInputsManager get inputs; external set inputs(FreeCameraInputsManager v);
 /// Gets the input sensibility for a mouse input. (default is 2000.0)
 /// Higher values reduce sensitivity.
 /// Sets the input sensibility for a mouse input. (default is 2000.0)
 /// Higher values reduce sensitivity.
 external num get angularSensibility; external set angularSensibility(num v); external List<num> get keysUp; external set keysUp(List<num> v); external List<num> get keysDown; external set keysDown(List<num> v); external List<num> get keysLeft; external set keysLeft(List<num> v); external List<num> get keysRight; external set keysRight(List<num> v); external VoidFunc1<AbstractMesh> get onCollide; external set onCollide(VoidFunc1<AbstractMesh> v); external get JS$_collider; external set JS$_collider(v); external get JS$_needMoveForGravity; external set JS$_needMoveForGravity(v); external get JS$_oldPosition; external set JS$_oldPosition(v); external get JS$_diffPosition; external set JS$_diffPosition(v); external get JS$_newPosition; external set JS$_newPosition(v); external Vector3 get JS$_localDirection; external set JS$_localDirection(Vector3 v); external Vector3 get JS$_transformedDirection; external set JS$_transformedDirection(Vector3 v); external factory FreeCamera(String name, Vector3 position, Scene scene, [bool setActiveOnSceneIfNoneActive]); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement element); external get JS$_collisionMask; external set JS$_collisionMask(v); external num get collisionMask; external set collisionMask(num v); external void JS$_collideWithWorld(Vector3 displacement); external get JS$_onCollisionPositionChange; external set JS$_onCollisionPositionChange(v); external void JS$_checkInputs(); external bool JS$_decideIfNeedsToMove(); external void JS$_updatePosition(); external void dispose(); external String getClassName(); }

 @JS("BABYLON.FreeCameraInputsManager" ) class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> { // @Ignore
 FreeCameraInputsManager .fakeConstructor$() : super.fakeConstructor$() ;
 external factory FreeCameraInputsManager(FreeCamera camera); external FreeCameraInputsManager addKeyboard(); external FreeCameraInputsManager addMouse([bool touchEnabled]); external FreeCameraInputsManager addGamepad(); external FreeCameraInputsManager addDeviceOrientation(); external FreeCameraInputsManager addTouch(); external FreeCameraInputsManager addVirtualJoystick(); }

 @JS("BABYLON.GamepadCamera" ) class GamepadCamera extends UniversalCamera { // @Ignore
 GamepadCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external num get gamepadAngularSensibility; external set gamepadAngularSensibility(num v); external num get gamepadMoveSensibility; external set gamepadMoveSensibility(num v); external factory GamepadCamera(String name, Vector3 position, Scene scene); external String getClassName(); }

 /// Camera used to simulate anaglyphic rendering (based on FreeCamera)
 @JS("BABYLON.AnaglyphFreeCamera" ) class AnaglyphFreeCamera extends FreeCamera { // @Ignore
 AnaglyphFreeCamera .fakeConstructor$() : super.fakeConstructor$() ;
 /// Creates a new AnaglyphFreeCamera
 external factory AnaglyphFreeCamera(String name, Vector3 position, num interaxialDistance, Scene scene);
 /// Gets camera class name
 external String getClassName(); }

 /// Camera used to simulate anaglyphic rendering (based on ArcRotateCamera)
 @JS("BABYLON.AnaglyphArcRotateCamera" ) class AnaglyphArcRotateCamera extends ArcRotateCamera { // @Ignore
 AnaglyphArcRotateCamera .fakeConstructor$() : super.fakeConstructor$() ;
 /// Creates a new AnaglyphArcRotateCamera
 external factory AnaglyphArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, num interaxialDistance, Scene scene);
 /// Gets camera class name
 external String getClassName(); }

 /// Camera used to simulate anaglyphic rendering (based on GamepadCamera)
 @JS("BABYLON.AnaglyphGamepadCamera" ) class AnaglyphGamepadCamera extends GamepadCamera { // @Ignore
 AnaglyphGamepadCamera .fakeConstructor$() : super.fakeConstructor$() ;
 /// Creates a new AnaglyphGamepadCamera
 external factory AnaglyphGamepadCamera(String name, Vector3 position, num interaxialDistance, Scene scene);
 /// Gets camera class name
 external String getClassName(); }

 /// Camera used to simulate anaglyphic rendering (based on UniversalCamera)
 @JS("BABYLON.AnaglyphUniversalCamera" ) class AnaglyphUniversalCamera extends UniversalCamera { // @Ignore
 AnaglyphUniversalCamera .fakeConstructor$() : super.fakeConstructor$() ;
 /// Creates a new AnaglyphUniversalCamera
 external factory AnaglyphUniversalCamera(String name, Vector3 position, num interaxialDistance, Scene scene);
 /// Gets camera class name
 external String getClassName(); }

 /// Camera used to simulate stereoscopic rendering (based on FreeCamera)
 @JS("BABYLON.StereoscopicFreeCamera" ) class StereoscopicFreeCamera extends FreeCamera { // @Ignore
 StereoscopicFreeCamera .fakeConstructor$() : super.fakeConstructor$() ;
 /// Creates a new StereoscopicFreeCamera
 external factory StereoscopicFreeCamera(String name, Vector3 position, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);
 /// Gets camera class name
 external String getClassName(); }

 /// Camera used to simulate stereoscopic rendering (based on ArcRotateCamera)
 @JS("BABYLON.StereoscopicArcRotateCamera" ) class StereoscopicArcRotateCamera extends ArcRotateCamera { // @Ignore
 StereoscopicArcRotateCamera .fakeConstructor$() : super.fakeConstructor$() ;
 /// Creates a new StereoscopicArcRotateCamera
 external factory StereoscopicArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);
 /// Gets camera class name
 external String getClassName(); }

 /// Camera used to simulate stereoscopic rendering (based on GamepadCamera)
 @JS("BABYLON.StereoscopicGamepadCamera" ) class StereoscopicGamepadCamera extends GamepadCamera { // @Ignore
 StereoscopicGamepadCamera .fakeConstructor$() : super.fakeConstructor$() ;
 /// Creates a new StereoscopicGamepadCamera
 external factory StereoscopicGamepadCamera(String name, Vector3 position, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);
 /// Gets camera class name
 external String getClassName(); }

 /// Camera used to simulate stereoscopic rendering (based on UniversalCamera)
 @JS("BABYLON.StereoscopicUniversalCamera" ) class StereoscopicUniversalCamera extends UniversalCamera { // @Ignore
 StereoscopicUniversalCamera .fakeConstructor$() : super.fakeConstructor$() ;
 /// Creates a new StereoscopicUniversalCamera
 external factory StereoscopicUniversalCamera(String name, Vector3 position, num interaxialDistance, bool isStereoscopicSideBySide, Scene scene);
 /// Gets camera class name
 external String getClassName(); }

 @JS("BABYLON.TargetCamera" ) class TargetCamera extends Camera { // @Ignore
 TargetCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external Vector3 get cameraDirection; external set cameraDirection(Vector3 v); external Vector2 get cameraRotation; external set cameraRotation(Vector2 v); external Vector3 get rotation; external set rotation(Vector3 v); external Quaternion get rotationQuaternion; external set rotationQuaternion(Quaternion v); external num get speed; external set speed(num v); external bool get noRotationConstraint; external set noRotationConstraint(bool v); external dynamic get lockedTarget; external set lockedTarget(dynamic v); external Vector3 get JS$_currentTarget; external set JS$_currentTarget(Vector3 v); external Matrix get JS$_viewMatrix; external set JS$_viewMatrix(Matrix v); external Matrix get JS$_camMatrix; external set JS$_camMatrix(Matrix v); external Matrix get JS$_cameraTransformMatrix; external set JS$_cameraTransformMatrix(Matrix v); external Matrix get JS$_cameraRotationMatrix; external set JS$_cameraRotationMatrix(Matrix v); external get JS$_rigCamTransformMatrix; external set JS$_rigCamTransformMatrix(v); external Vector3 get JS$_referencePoint; external set JS$_referencePoint(Vector3 v); external get JS$_currentUpVector; external set JS$_currentUpVector(v); external Vector3 get JS$_transformedReferencePoint; external set JS$_transformedReferencePoint(Vector3 v); external Vector3 get JS$_globalCurrentTarget; external set JS$_globalCurrentTarget(Vector3 v); external Vector3 get JS$_globalCurrentUpVector; external set JS$_globalCurrentUpVector(Vector3 v); external VoidFunc0 get JS$_reset; external set JS$_reset(VoidFunc0 v); external factory TargetCamera(String name, Vector3 position, Scene scene, [bool setActiveOnSceneIfNoneActive]); external Vector3 getFrontPosition(num distance); external Vector3/*Vector3|Null*/ JS$_getLockedTargetPosition();
 /// Store current camera state (fov, position, etc..)
 external get JS$_storedPosition; external set JS$_storedPosition(v); external get JS$_storedRotation; external set JS$_storedRotation(v); external get JS$_storedRotationQuaternion; external set JS$_storedRotationQuaternion(v); external Camera storeState();
 /// Restored camera state. You must call storeState() first
 external bool JS$_restoreStateValues(); external void JS$_initCache(); external void JS$_updateCache([bool ignoreParentClass]); external bool JS$_isSynchronizedViewMatrix(); external num JS$_computeLocalCameraSpeed(); external void setTarget(Vector3 target);
 /// Return the current target position of the camera. This value is expressed in local space.
 external Vector3 getTarget(); external bool JS$_decideIfNeedsToMove(); external void JS$_updatePosition(); external void JS$_checkInputs(); external void JS$_updateCameraRotationMatrix(); external Matrix JS$_getViewMatrix(); external void JS$_computeViewMatrix(Vector3 position, Vector3 target, Vector3 up);
 /// @override
 /// Override Camera.createRigCamera
 external Camera/*Camera|Null*/ createRigCamera(String name, num cameraIndex);
 /// @override
 /// Override Camera._updateRigCameras
 external void JS$_updateRigCameras(); external JS$_getRigCamPosition(halfSpace, result); external String getClassName(); }

 @JS("BABYLON.TouchCamera" ) class TouchCamera extends FreeCamera { // @Ignore
 TouchCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external num get touchAngularSensibility; external set touchAngularSensibility(num v); external num get touchMoveSensibility; external set touchMoveSensibility(num v); external factory TouchCamera(String name, Vector3 position, Scene scene); external String getClassName(); external void JS$_setupInputs(); }

 @JS("BABYLON.UniversalCamera" ) class UniversalCamera extends TouchCamera { // @Ignore
 UniversalCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external num get gamepadAngularSensibility; external set gamepadAngularSensibility(num v); external num get gamepadMoveSensibility; external set gamepadMoveSensibility(num v); external factory UniversalCamera(String name, Vector3 position, Scene scene); external String getClassName(); }

 @JS("BABYLON.VirtualJoysticksCamera" ) class VirtualJoysticksCamera extends FreeCamera { // @Ignore
 VirtualJoysticksCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external factory VirtualJoysticksCamera(String name, Vector3 position, Scene scene); external String getClassName(); }

 
// Module Debug
 /// The Axes viewer will show 3 axes in a specific point in space
 @JS("BABYLON.Debug.AxesViewer" ) class AxesViewer { // @Ignore
 AxesViewer .fakeConstructor$() ;
 external get JS$_xline; external set JS$_xline(v); external get JS$_yline; external set JS$_yline(v); external get JS$_zline; external set JS$_zline(v); external get JS$_xmesh; external set JS$_xmesh(v); external get JS$_ymesh; external set JS$_ymesh(v); external get JS$_zmesh; external set JS$_zmesh(v); external Scene/*Scene|Null*/ get scene; external set scene(Scene/*Scene|Null*/ v); external num get scaleLines; external set scaleLines(num v); external factory AxesViewer(Scene scene, [num scaleLines]); external void update(Vector3 position, Vector3 xaxis, Vector3 yaxis, Vector3 zaxis); external void dispose(); }

 
// End module Debug
 
// Module Debug
 /// The BoneAxesViewer will attach 3 axes to a specific bone of a specific mesh
 @JS("BABYLON.Debug.BoneAxesViewer" ) class BoneAxesViewer extends AxesViewer { // @Ignore
 BoneAxesViewer .fakeConstructor$() : super.fakeConstructor$() ;
 external Mesh/*Mesh|Null*/ get mesh; external set mesh(Mesh/*Mesh|Null*/ v); external Bone/*Bone|Null*/ get bone; external set bone(Bone/*Bone|Null*/ v); external Vector3 get pos; external set pos(Vector3 v); external Vector3 get xaxis; external set xaxis(Vector3 v); external Vector3 get yaxis; external set yaxis(Vector3 v); external Vector3 get zaxis; external set zaxis(Vector3 v); external factory BoneAxesViewer(Scene scene, Bone bone, Mesh mesh, [num scaleLines]); external void update(); external void dispose(); }

 
// End module Debug
 @JS("BABYLON.DebugLayer" ) class DebugLayer { // @Ignore
 DebugLayer .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external static String get InspectorURL; external static set InspectorURL(String v); external get JS$_inspector; external set JS$_inspector(v); external get BJSINSPECTOR; external set BJSINSPECTOR(v); external factory DebugLayer(Scene scene);
 /// Creates the inspector window.
 external JS$_createInspector([config]); external bool isVisible(); external void hide(); external void show([dynamic/*{
            popup?: boolean;
            initialTab?: number;
            parentElement?: HTMLElement;
            newColors?: {
                backgroundColor?: string;
                backgroundColorLighter?: string;
                backgroundColorLighter2?: string;
                backgroundColorLighter3?: string;
                color?: string;
                colorTop?: string;
                colorBot?: string;
            };
        }*/ config]); }

 
// Module Debug
 /// Used to show the physics impostor around the specific mesh.
 @JS("BABYLON.Debug.PhysicsViewer" ) class PhysicsViewer { // @Ignore
 PhysicsViewer .fakeConstructor$() ;
 external List<PhysicsImpostor/*PhysicsImpostor|Null*/> get JS$_impostors; external set JS$_impostors(List<PhysicsImpostor/*PhysicsImpostor|Null*/> v); external List<AbstractMesh/*AbstractMesh|Null*/> get JS$_meshes; external set JS$_meshes(List<AbstractMesh/*AbstractMesh|Null*/> v); external Scene/*Scene|Null*/ get JS$_scene; external set JS$_scene(Scene/*Scene|Null*/ v); external num get JS$_numMeshes; external set JS$_numMeshes(num v); external IPhysicsEnginePlugin/*IPhysicsEnginePlugin|Null*/ get JS$_physicsEnginePlugin; external set JS$_physicsEnginePlugin(IPhysicsEnginePlugin/*IPhysicsEnginePlugin|Null*/ v); external get JS$_renderFunction; external set JS$_renderFunction(v); external get JS$_debugBoxMesh; external set JS$_debugBoxMesh(v); external get JS$_debugSphereMesh; external set JS$_debugSphereMesh(v); external get JS$_debugMaterial; external set JS$_debugMaterial(v); external factory PhysicsViewer(Scene scene); external void JS$_updateDebugMeshes(); external void showImpostor(PhysicsImpostor impostor); external void hideImpostor(PhysicsImpostor/*PhysicsImpostor|Null*/ impostor); external JS$_getDebugMaterial(scene); external JS$_getDebugBoxMesh(scene); external JS$_getDebugSphereMesh(scene); external JS$_getDebugMesh(impostor, scene); external void dispose(); }

 
// End module Debug
 @JS("BABYLON.RayHelper" ) class RayHelper { // @Ignore
 RayHelper .fakeConstructor$() ;
 external Ray/*Ray|Null*/ get ray; external set ray(Ray/*Ray|Null*/ v); external get JS$_renderPoints; external set JS$_renderPoints(v); external get JS$_renderLine; external set JS$_renderLine(v); external get JS$_renderFunction; external set JS$_renderFunction(v); external get JS$_scene; external set JS$_scene(v); external get JS$_updateToMeshFunction; external set JS$_updateToMeshFunction(v); external get JS$_attachedToMesh; external set JS$_attachedToMesh(v); external get JS$_meshSpaceDirection; external set JS$_meshSpaceDirection(v); external get JS$_meshSpaceOrigin; external set JS$_meshSpaceOrigin(v); external static RayHelper CreateAndShow(Ray ray, Scene scene, Color3 color); external factory RayHelper(Ray ray); external void show(Scene scene, Color3 color); external void hide(); external JS$_render(); external void attachToMesh(AbstractMesh mesh, [Vector3 meshSpaceDirection, Vector3 meshSpaceOrigin, num length]); external void detachFromMesh(); external JS$_updateToMesh(); external void dispose(); }

 
// Module Debug
 /// Demo available here: http://www.babylonjs-playground.com/#1BZJVJ#8
 @JS("BABYLON.Debug.SkeletonViewer" ) class SkeletonViewer { // @Ignore
 SkeletonViewer .fakeConstructor$() ;
 external Skeleton get skeleton; external set skeleton(Skeleton v); external AbstractMesh get mesh; external set mesh(AbstractMesh v); external bool get autoUpdateBonesMatrices; external set autoUpdateBonesMatrices(bool v); external num get renderingGroupId; external set renderingGroupId(num v); external Color3 get color; external set color(Color3 v); external get JS$_scene; external set JS$_scene(v); external get JS$_debugLines; external set JS$_debugLines(v); external get JS$_debugMesh; external set JS$_debugMesh(v); external get JS$_isEnabled; external set JS$_isEnabled(v); external get JS$_renderFunction; external set JS$_renderFunction(v); external factory SkeletonViewer(Skeleton skeleton, AbstractMesh mesh, Scene scene, [bool autoUpdateBonesMatrices, num renderingGroupId]); external bool get isEnabled; external set isEnabled(bool v); external JS$_getBonePosition(position, bone, meshMat, [x, y, z]); external JS$_getLinesForBonesWithLength(bones, meshMat); external JS$_getLinesForBonesNoLength(bones, meshMat); external void update(); external void dispose(); }

 
// End module Debug
 /// Interface for attribute information associated with buffer instanciation
 @JS("BABYLON.InstancingAttributeInfo" ) class InstancingAttributeInfo { // @Ignore
 InstancingAttributeInfo .fakeConstructor$() ;
 /// Index/offset of the attribute in the vertex shader
 external num get index; external set index(num v);
 /// size of the attribute, 1, 2, 3 or 4
 external num get attributeSize; external set attributeSize(num v);
 /// type of the attribute, gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.FIXED, gl.FLOAT.
 /// default is FLOAT
 external num get attribyteType; external set attribyteType(num v);
 /// normalization of fixed-point data. behavior unclear, use FALSE, default is FALSE
 external bool get normalized; external set normalized(bool v);
 /// Offset of the data in the Vertex Buffer acting as the instancing buffer
 external num get offset; external set offset(num v);
 /// Name of the GLSL attribute, for debugging purpose only
 external String get attributeName; external set attributeName(String v); }

 /// Define options used to create a render target texture
 @JS("BABYLON.RenderTargetCreationOptions" ) class RenderTargetCreationOptions { // @Ignore
 RenderTargetCreationOptions .fakeConstructor$() ;
 /// Specifies is mipmaps must be generated
 external bool get generateMipMaps; external set generateMipMaps(bool v);
 /// Specifies whether or not a depth should be allocated in the texture (true by default)
 external bool get generateDepthBuffer; external set generateDepthBuffer(bool v);
 /// Specifies whether or not a stencil should be allocated in the texture (false by default)
 external bool get generateStencilBuffer; external set generateStencilBuffer(bool v);
 /// Defines texture type (int by default)
 external num get type; external set type(num v);
 /// Defines sampling mode (trilinear by default)
 external num get samplingMode; external set samplingMode(num v);
 /// Defines format (RGBA by default)
 external num get format; external set format(num v); }

 /// Define options used to create a depth texture
 @JS("BABYLON.DepthTextureCreationOptions" ) class DepthTextureCreationOptions { // @Ignore
 DepthTextureCreationOptions .fakeConstructor$() ;
 /// Specifies whether or not a stencil should be allocated in the texture
 external bool get generateStencil; external set generateStencil(bool v);
 /// Specifies whether or not bilinear filtering is enable on the texture
 external bool get bilinearFiltering; external set bilinearFiltering(bool v);
 /// Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode
 external num get comparisonFunction; external set comparisonFunction(num v);
 /// Specifies if the created texture is a cube texture
 external bool get isCube; external set isCube(bool v); }

 /// Class used to describe the capabilities of the engine relatively to the current browser
 @JS("BABYLON.EngineCapabilities" ) class EngineCapabilities { // @Ignore
 EngineCapabilities .fakeConstructor$() ;
 /// Maximum textures units per fragment shader
 external num get maxTexturesImageUnits; external set maxTexturesImageUnits(num v);
 /// Maximum texture units per vertex shader
 external num get maxVertexTextureImageUnits; external set maxVertexTextureImageUnits(num v);
 /// Maximum textures units in the entire pipeline
 external num get maxCombinedTexturesImageUnits; external set maxCombinedTexturesImageUnits(num v);
 /// Maximum texture size
 external num get maxTextureSize; external set maxTextureSize(num v);
 /// Maximum cube texture size
 external num get maxCubemapTextureSize; external set maxCubemapTextureSize(num v);
 /// Maximum render texture size
 external num get maxRenderTextureSize; external set maxRenderTextureSize(num v);
 /// Maximum number of vertex attributes
 external num get maxVertexAttribs; external set maxVertexAttribs(num v);
 /// Maximum number of varyings
 external num get maxVaryingVectors; external set maxVaryingVectors(num v);
 /// Maximum number of uniforms per vertex shader
 external num get maxVertexUniformVectors; external set maxVertexUniformVectors(num v);
 /// Maximum number of uniforms per fragment shader
 external num get maxFragmentUniformVectors; external set maxFragmentUniformVectors(num v);
 /// Defines if standard derivates (dx/dy) are supported
 external bool get standardDerivatives; external set standardDerivatives(bool v);
 /// Defines if s3tc texture compression is supported
 external WEBGL_compressed_texture_s3tc/*WEBGL_compressed_texture_s3tc|Null*/ get s3tc; external set s3tc(WEBGL_compressed_texture_s3tc/*WEBGL_compressed_texture_s3tc|Null*/ v);
 /// Defines if pvrtc texture compression is supported
 external dynamic get pvrtc; external set pvrtc(dynamic v);
 /// Defines if etc1 texture compression is supported
 external dynamic get etc1; external set etc1(dynamic v);
 /// Defines if etc2 texture compression is supported
 external dynamic get etc2; external set etc2(dynamic v);
 /// Defines if astc texture compression is supported
 external dynamic get astc; external set astc(dynamic v);
 /// Defines if float textures are supported
 external bool get textureFloat; external set textureFloat(bool v);
 /// Defines if vertex array objects are supported
 external bool get vertexArrayObject; external set vertexArrayObject(bool v);
 /// Gets the webgl extension for anisotropic filtering (null if not supported)
 external EXT_texture_filter_anisotropic/*EXT_texture_filter_anisotropic|Null*/ get textureAnisotropicFilterExtension; external set textureAnisotropicFilterExtension(EXT_texture_filter_anisotropic/*EXT_texture_filter_anisotropic|Null*/ v);
 /// Gets the maximum level of anisotropy supported
 external num get maxAnisotropy; external set maxAnisotropy(num v);
 /// Defines if instancing is supported
 external bool get instancedArrays; external set instancedArrays(bool v);
 /// Defines if 32 bits indices are supported
 external bool get uintIndices; external set uintIndices(bool v);
 /// Defines if high precision shaders are supported
 external bool get highPrecisionShaderSupported; external set highPrecisionShaderSupported(bool v);
 /// Defines if depth reading in the fragment shader is supported
 external bool get fragmentDepthSupported; external set fragmentDepthSupported(bool v);
 /// Defines if float texture linear filtering is supported
 external bool get textureFloatLinearFiltering; external set textureFloatLinearFiltering(bool v);
 /// Defines if rendering to float textures is supported
 external bool get textureFloatRender; external set textureFloatRender(bool v);
 /// Defines if half float textures are supported
 external bool get textureHalfFloat; external set textureHalfFloat(bool v);
 /// Defines if half float texture linear filtering is supported
 external bool get textureHalfFloatLinearFiltering; external set textureHalfFloatLinearFiltering(bool v);
 /// Defines if rendering to half float textures is supported
 external bool get textureHalfFloatRender; external set textureHalfFloatRender(bool v);
 /// Defines if textureLOD shader command is supported
 external bool get textureLOD; external set textureLOD(bool v);
 /// Defines if draw buffers extension is supported
 external bool get drawBuffersExtension; external set drawBuffersExtension(bool v);
 /// Defines if depth textures are supported
 external bool get depthTextureExtension; external set depthTextureExtension(bool v);
 /// Defines if float color buffer are supported
 external bool get colorBufferFloat; external set colorBufferFloat(bool v);
 /// Gets disjoint timer query extension (null if not supported)
 external EXT_disjoint_timer_query get timerQuery; external set timerQuery(EXT_disjoint_timer_query v);
 /// Defines if timestamp can be used with timer query
 external bool get canUseTimestampForTimerQuery; external set canUseTimestampForTimerQuery(bool v); }

 /// Interface defining initialization parameters for Engine class
 @anonymous @JS() abstract class EngineOptions implements ContextAttributes {
 /// Defines if the engine should no exceed a specified device ratio
 /// @see https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio
 external num get limitDeviceRatio; external set limitDeviceRatio(num v);
 /// Defines if webvr should be enabled automatically
 /// @see http://doc.babylonjs.com/how_to/webvr_camera
 external bool get autoEnableWebVR; external set autoEnableWebVR(bool v);
 /// Defines if webgl2 should be turned off even if supported
 /// @see http://doc.babylonjs.com/features/webgl2
 external bool get disableWebGL2Support; external set disableWebGL2Support(bool v);
 /// Defines if webaudio should be initialized as well
 /// @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
 external bool get audioEngine; external set audioEngine(bool v);
 /// Defines if animations should run using a deterministic lock step
 /// @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
 external bool get deterministicLockstep; external set deterministicLockstep(bool v);
 /// Defines the maximum steps to use with deterministic lock step mode
 external num get lockstepMaxSteps; external set lockstepMaxSteps(num v);
 /// Defines that engine should ignore context lost events
 /// If this event happens when this parameter is true, you will have to reload the page to restore rendering
 external bool get doNotHandleContextLost; external set doNotHandleContextLost(bool v); external factory EngineOptions({ num limitDeviceRatio, bool autoEnableWebVR, bool disableWebGL2Support, bool audioEngine, bool deterministicLockstep, num lockstepMaxSteps, bool doNotHandleContextLost, bool alpha, bool depth, bool stencil, bool antialias, bool premultipliedAlpha, bool preserveDrawingBuffer}); }

 /// Defines the interface used by display changed events
 @anonymous @JS() abstract class IDisplayChangedEventArgs {
 /// Gets the vrDisplay object (if any)
 external dynamic/*dynamic|Null*/ get vrDisplay; external set vrDisplay(dynamic/*dynamic|Null*/ v);
 /// Gets a boolean indicating if webVR is supported
 external bool get vrSupported; external set vrSupported(bool v); external factory IDisplayChangedEventArgs({ dynamic/*dynamic|Null*/ vrDisplay, bool vrSupported}); }

 /// The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio
 @JS("BABYLON.Engine" ) class Engine { // @Ignore
 Engine .fakeConstructor$() ;
 /// Use this array to turn off some WebGL2 features on known buggy browsers version
 external static List<dynamic/*{
            key: string;
            capture: string;
            captureConstraint: number;
            targets: string[];
        }|{
            key: string;
            capture: null;
            captureConstraint: null;
            targets: string[];
        }*/> get ExceptionList; external static set ExceptionList(List<dynamic/*{
            key: string;
            capture: string;
            captureConstraint: number;
            targets: string[];
        }|{
            key: string;
            capture: null;
            captureConstraint: null;
            targets: string[];
        }*/> v);
 /// Gets the list of created engines
 external static List<Engine> get Instances; external static set Instances(List<Engine> v);
 /// Gets the latest created engine
 external static Engine/*Engine|Null*/ get LastCreatedEngine; external static set LastCreatedEngine(Engine/*Engine|Null*/ v);
 /// Gets the latest created scene
 external static Scene/*Scene|Null*/ get LastCreatedScene; external static set LastCreatedScene(Scene/*Scene|Null*/ v);
 /// Will flag all materials in all scenes in all engines as dirty to trigger new shader compilation
 external static void MarkAllMaterialsAsDirty(num flag, [bool predicate(Material mat)]); external static get JS$_ALPHA_DISABLE; external static set JS$_ALPHA_DISABLE(v); external static get JS$_ALPHA_ADD; external static set JS$_ALPHA_ADD(v); external static get JS$_ALPHA_COMBINE; external static set JS$_ALPHA_COMBINE(v); external static get JS$_ALPHA_SUBTRACT; external static set JS$_ALPHA_SUBTRACT(v); external static get JS$_ALPHA_MULTIPLY; external static set JS$_ALPHA_MULTIPLY(v); external static get JS$_ALPHA_MAXIMIZED; external static set JS$_ALPHA_MAXIMIZED(v); external static get JS$_ALPHA_ONEONE; external static set JS$_ALPHA_ONEONE(v); external static get JS$_ALPHA_PREMULTIPLIED; external static set JS$_ALPHA_PREMULTIPLIED(v); external static get JS$_ALPHA_PREMULTIPLIED_PORTERDUFF; external static set JS$_ALPHA_PREMULTIPLIED_PORTERDUFF(v); external static get JS$_ALPHA_INTERPOLATE; external static set JS$_ALPHA_INTERPOLATE(v); external static get JS$_ALPHA_SCREENMODE; external static set JS$_ALPHA_SCREENMODE(v); external static get JS$_DELAYLOADSTATE_NONE; external static set JS$_DELAYLOADSTATE_NONE(v); external static get JS$_DELAYLOADSTATE_LOADED; external static set JS$_DELAYLOADSTATE_LOADED(v); external static get JS$_DELAYLOADSTATE_LOADING; external static set JS$_DELAYLOADSTATE_LOADING(v); external static get JS$_DELAYLOADSTATE_NOTLOADED; external static set JS$_DELAYLOADSTATE_NOTLOADED(v); external static get JS$_TEXTUREFORMAT_ALPHA; external static set JS$_TEXTUREFORMAT_ALPHA(v); external static get JS$_TEXTUREFORMAT_LUMINANCE; external static set JS$_TEXTUREFORMAT_LUMINANCE(v); external static get JS$_TEXTUREFORMAT_LUMINANCE_ALPHA; external static set JS$_TEXTUREFORMAT_LUMINANCE_ALPHA(v); external static get JS$_TEXTUREFORMAT_RGB; external static set JS$_TEXTUREFORMAT_RGB(v); external static get JS$_TEXTUREFORMAT_RGBA; external static set JS$_TEXTUREFORMAT_RGBA(v); external static get JS$_TEXTUREFORMAT_R32F; external static set JS$_TEXTUREFORMAT_R32F(v); external static get JS$_TEXTUREFORMAT_RG32F; external static set JS$_TEXTUREFORMAT_RG32F(v); external static get JS$_TEXTUREFORMAT_RGB32F; external static set JS$_TEXTUREFORMAT_RGB32F(v); external static get JS$_TEXTUREFORMAT_RGBA32F; external static set JS$_TEXTUREFORMAT_RGBA32F(v); external static get JS$_TEXTURETYPE_UNSIGNED_INT; external static set JS$_TEXTURETYPE_UNSIGNED_INT(v); external static get JS$_TEXTURETYPE_FLOAT; external static set JS$_TEXTURETYPE_FLOAT(v); external static get JS$_TEXTURETYPE_HALF_FLOAT; external static set JS$_TEXTURETYPE_HALF_FLOAT(v); external static get JS$_NEVER; external static set JS$_NEVER(v); external static get JS$_ALWAYS; external static set JS$_ALWAYS(v); external static get JS$_LESS; external static set JS$_LESS(v); external static get JS$_EQUAL; external static set JS$_EQUAL(v); external static get JS$_LEQUAL; external static set JS$_LEQUAL(v); external static get JS$_GREATER; external static set JS$_GREATER(v); external static get JS$_GEQUAL; external static set JS$_GEQUAL(v); external static get JS$_NOTEQUAL; external static set JS$_NOTEQUAL(v);
 /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn
 external static num get NEVER; external static set NEVER(num v);
 /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn
 external static num get ALWAYS; external static set ALWAYS(num v);
 /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value
 external static num get LESS; external static set LESS(num v);
 /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value
 external static num get EQUAL; external static set EQUAL(num v);
 /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value
 external static num get LEQUAL; external static set LEQUAL(num v);
 /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value
 external static num get GREATER; external static set GREATER(num v);
 /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value
 external static num get GEQUAL; external static set GEQUAL(num v);
 /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value
 external static num get NOTEQUAL; external static set NOTEQUAL(num v); external static get JS$_KEEP; external static set JS$_KEEP(v); external static get JS$_REPLACE; external static set JS$_REPLACE(v); external static get JS$_INCR; external static set JS$_INCR(v); external static get JS$_DECR; external static set JS$_DECR(v); external static get JS$_INVERT; external static set JS$_INVERT(v); external static get JS$_INCR_WRAP; external static set JS$_INCR_WRAP(v); external static get JS$_DECR_WRAP; external static set JS$_DECR_WRAP(v);
 /// Passed to stencilOperation to specify that stencil value must be kept
 external static num get KEEP; external static set KEEP(num v);
 /// Passed to stencilOperation to specify that stencil value must be replaced
 external static num get REPLACE; external static set REPLACE(num v);
 /// Passed to stencilOperation to specify that stencil value must be incremented
 external static num get INCR; external static set INCR(num v);
 /// Passed to stencilOperation to specify that stencil value must be decremented
 external static num get DECR; external static set DECR(num v);
 /// Passed to stencilOperation to specify that stencil value must be inverted
 external static num get INVERT; external static set INVERT(num v);
 /// Passed to stencilOperation to specify that stencil value must be incremented with wrapping
 external static num get INCR_WRAP; external static set INCR_WRAP(num v);
 /// Passed to stencilOperation to specify that stencil value must be decremented with wrapping
 external static num get DECR_WRAP; external static set DECR_WRAP(num v);
 /// Defines that alpha blending is disabled
 external static num get ALPHA_DISABLE; external static set ALPHA_DISABLE(num v);
 /// Defines that alpha blending to SRC + DEST
 external static num get ALPHA_ONEONE; external static set ALPHA_ONEONE(num v);
 /// Defines that alpha blending to SRC ALPHA * SRC + DEST
 external static num get ALPHA_ADD; external static set ALPHA_ADD(num v);
 /// Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST
 external static num get ALPHA_COMBINE; external static set ALPHA_COMBINE(num v);
 /// Defines that alpha blending to DEST - SRC * DEST
 external static num get ALPHA_SUBTRACT; external static set ALPHA_SUBTRACT(num v);
 /// Defines that alpha blending to SRC * DEST
 external static num get ALPHA_MULTIPLY; external static set ALPHA_MULTIPLY(num v);
 /// Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC) * DEST
 external static num get ALPHA_MAXIMIZED; external static set ALPHA_MAXIMIZED(num v);
 /// Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST
 external static num get ALPHA_PREMULTIPLIED; external static set ALPHA_PREMULTIPLIED(num v);
 /// Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST
 /// Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA
 external static num get ALPHA_PREMULTIPLIED_PORTERDUFF; external static set ALPHA_PREMULTIPLIED_PORTERDUFF(num v);
 /// Defines that alpha blending to CST * SRC + (1 - CST) * DEST
 external static num get ALPHA_INTERPOLATE; external static set ALPHA_INTERPOLATE(num v);
 /// Defines that alpha blending to SRC + (1 - SRC) * DEST
 /// Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA
 external static num get ALPHA_SCREENMODE; external static set ALPHA_SCREENMODE(num v);
 /// Defines that the ressource is not delayed
 external static num get DELAYLOADSTATE_NONE; external static set DELAYLOADSTATE_NONE(num v);
 /// Defines that the ressource was successfully delay loaded
 external static num get DELAYLOADSTATE_LOADED; external static set DELAYLOADSTATE_LOADED(num v);
 /// Defines that the ressource is currently delay loading
 external static num get DELAYLOADSTATE_LOADING; external static set DELAYLOADSTATE_LOADING(num v);
 /// Defines that the ressource is delayed and has not started loading
 external static num get DELAYLOADSTATE_NOTLOADED; external static set DELAYLOADSTATE_NOTLOADED(num v);
 /// ALPHA
 external static num get TEXTUREFORMAT_ALPHA; external static set TEXTUREFORMAT_ALPHA(num v);
 /// LUMINANCE
 external static num get TEXTUREFORMAT_LUMINANCE; external static set TEXTUREFORMAT_LUMINANCE(num v);
 /// R32F
 external static num get TEXTUREFORMAT_R32F; external static set TEXTUREFORMAT_R32F(num v);
 /// RG32F
 external static num get TEXTUREFORMAT_RG32F; external static set TEXTUREFORMAT_RG32F(num v);
 /// RGB32F
 external static num get TEXTUREFORMAT_RGB32F; external static set TEXTUREFORMAT_RGB32F(num v);
 /// RGBA32F
 external static num get TEXTUREFORMAT_RGBA32F; external static set TEXTUREFORMAT_RGBA32F(num v);
 /// LUMINANCE_ALPHA
 external static num get TEXTUREFORMAT_LUMINANCE_ALPHA; external static set TEXTUREFORMAT_LUMINANCE_ALPHA(num v);
 /// RGB
 external static num get TEXTUREFORMAT_RGB; external static set TEXTUREFORMAT_RGB(num v);
 /// RGBA
 external static num get TEXTUREFORMAT_RGBA; external static set TEXTUREFORMAT_RGBA(num v);
 /// UNSIGNED_INT
 external static num get TEXTURETYPE_UNSIGNED_INT; external static set TEXTURETYPE_UNSIGNED_INT(num v);
 /// FLOAT
 external static num get TEXTURETYPE_FLOAT; external static set TEXTURETYPE_FLOAT(num v);
 /// HALF_FLOAT
 external static num get TEXTURETYPE_HALF_FLOAT; external static set TEXTURETYPE_HALF_FLOAT(num v); external static get JS$_SCALEMODE_FLOOR; external static set JS$_SCALEMODE_FLOOR(v); external static get JS$_SCALEMODE_NEAREST; external static set JS$_SCALEMODE_NEAREST(v); external static get JS$_SCALEMODE_CEILING; external static set JS$_SCALEMODE_CEILING(v);
 /// Defines that texture rescaling will use a floor to find the closer power of 2 size
 external static num get SCALEMODE_FLOOR; external static set SCALEMODE_FLOOR(num v);
 /// Defines that texture rescaling will look for the nearest power of 2 size
 external static num get SCALEMODE_NEAREST; external static set SCALEMODE_NEAREST(num v);
 /// Defines that texture rescaling will use a ceil to find the closer power of 2 size
 external static num get SCALEMODE_CEILING; external static set SCALEMODE_CEILING(num v);
 /// Returns the current version of the framework
 external static String get Version; external static set Version(String v);
 /// Gets or sets the epsilon value used by collision engine
 external static num get CollisionsEpsilon; external static set CollisionsEpsilon(num v);
 /// Gets or sets the relative url used to load code if using the engine in non-minified mode
 external static String get CodeRepository; external static set CodeRepository(String v);
 /// Gets or sets the relative url used to load shaders if using the engine in non-minified mode
 external static String get ShadersRepository; external static set ShadersRepository(String v);
 /// Gets or sets a boolean that indicates if textures must be forced to power of 2 size even if not required
 external bool get forcePOTTextures; external set forcePOTTextures(bool v);
 /// Gets a boolean indicating if the engine is currently rendering in fullscreen mode
 external bool get isFullscreen; external set isFullscreen(bool v);
 /// Gets a boolean indicating if the pointer is currently locked
 external bool get isPointerLock; external set isPointerLock(bool v);
 /// Gets or sets a boolean indicating if back faces must be culled (true by default)
 external bool get cullBackFaces; external set cullBackFaces(bool v);
 /// Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foregroun
 external bool get renderEvenInBackground; external set renderEvenInBackground(bool v);
 /// Gets or sets a boolean indicating that cache can be kept between frames
 external bool get preventCacheWipeBetweenFrames; external set preventCacheWipeBetweenFrames(bool v);
 /// Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest
 external bool get enableOfflineSupport; external set enableOfflineSupport(bool v);
 /// Gets or sets a boolean to enable/disable checking manifest if IndexedDB support is enabled (Babylon.js will always consider the database is up to date)
 external bool get disableManifestCheck; external set disableManifestCheck(bool v);
 /// Gets the list of created scenes
 external List<Scene> get scenes; external set scenes(List<Scene> v);
 /// Gets the list of created postprocesses
 external List<PostProcess> get postProcesses; external set postProcesses(List<PostProcess> v);
 /// Observable event triggered each time the rendering canvas is resized
 external Observable<Engine> get onResizeObservable; external set onResizeObservable(Observable<Engine> v);
 /// Observable event triggered each time the canvas loses focus
 external Observable<Engine> get onCanvasBlurObservable; external set onCanvasBlurObservable(Observable<Engine> v);
 /// Observable event triggered each time the canvas gains focus
 external Observable<Engine> get onCanvasFocusObservable; external set onCanvasFocusObservable(Observable<Engine> v);
 /// Observable event triggered each time the canvas receives pointerout event
 external Observable<PointerEvent> get onCanvasPointerOutObservable; external set onCanvasPointerOutObservable(Observable<PointerEvent> v);
 /// Observable event triggered before each texture is initialized
 external Observable<Texture> get onBeforeTextureInitObservable; external set onBeforeTextureInitObservable(Observable<Texture> v); external get JS$_vrDisplay; external set JS$_vrDisplay(v); external get JS$_vrSupported; external set JS$_vrSupported(v); external get JS$_oldSize; external set JS$_oldSize(v); external get JS$_oldHardwareScaleFactor; external set JS$_oldHardwareScaleFactor(v); external get JS$_vrExclusivePointerMode; external set JS$_vrExclusivePointerMode(v); external get JS$_webVRInitPromise; external set JS$_webVRInitPromise(v);
 /// Gets a boolean indicating that the engine is currently in VR exclusive mode for the pointers
 /// @see https://docs.microsoft.com/en-us/microsoft-edge/webvr/essentials#mouse-input
 external bool get isInVRExclusivePointerMode; external set isInVRExclusivePointerMode(bool v);
 /// Gets or sets a boolean indicating that uniform buffers must be disabled even if they are supported
 external bool get disableUniformBuffers; external set disableUniformBuffers(bool v);
 /// @hidden
 external List<UniformBuffer> get JS$_uniformBuffers; external set JS$_uniformBuffers(List<UniformBuffer> v);
 /// Gets a boolean indicating that the engine supports uniform buffers
 /// @see http://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
 external bool get supportsUniformBuffers; external set supportsUniformBuffers(bool v);
 /// Observable raised when the engine begins a new frame
 external Observable<Engine> get onBeginFrameObservable; external set onBeginFrameObservable(Observable<Engine> v);
 /// Observable raised when the engine ends the current frame
 external Observable<Engine> get onEndFrameObservable; external set onEndFrameObservable(Observable<Engine> v);
 /// Observable raised when the engine is about to compile a shader
 external Observable<Engine> get onBeforeShaderCompilationObservable; external set onBeforeShaderCompilationObservable(Observable<Engine> v);
 /// Observable raised when the engine has jsut compiled a shader
 external Observable<Engine> get onAfterShaderCompilationObservable; external set onAfterShaderCompilationObservable(Observable<Engine> v); external get JS$_gl; external set JS$_gl(v); external get JS$_renderingCanvas; external set JS$_renderingCanvas(v); external get JS$_windowIsBackground; external set JS$_windowIsBackground(v); external get JS$_webGLVersion; external set JS$_webGLVersion(v);
 /// Gets a boolean indicating that only power of 2 textures are supported
 /// Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them
 external bool get needPOTTextures; external set needPOTTextures(bool v);
 /// @hidden
 external bool get JS$_badOS; external set JS$_badOS(bool v);
 /// @hidden
 external bool get JS$_badDesktopOS; external set JS$_badDesktopOS(bool v);
 /// Gets or sets a value indicating if we want to disable texture binding optmization.
 /// This could be required on some buggy drivers which wants to have textures bound in a progressive order.
 /// By default Babylon.js will try to let textures bound where they are and only update the samplers to point where the texture is
 external bool get disableTextureBindingOptimization; external set disableTextureBindingOptimization(bool v);
 /// Gets the audio engine
 /// @see http://doc.babylonjs.com/how_to/playing_sounds_and_music
 /// @ignorenaming
 external static AudioEngine get audioEngine; external static set audioEngine(AudioEngine v); external get JS$_onFocus; external set JS$_onFocus(v); external get JS$_onBlur; external set JS$_onBlur(v); external get JS$_onCanvasPointerOut; external set JS$_onCanvasPointerOut(v); external get JS$_onCanvasBlur; external set JS$_onCanvasBlur(v); external get JS$_onCanvasFocus; external set JS$_onCanvasFocus(v); external get JS$_onFullscreenChange; external set JS$_onFullscreenChange(v); external get JS$_onPointerLockChange; external set JS$_onPointerLockChange(v); external get JS$_onVRDisplayPointerRestricted; external set JS$_onVRDisplayPointerRestricted(v); external get JS$_onVRDisplayPointerUnrestricted; external set JS$_onVRDisplayPointerUnrestricted(v); external get JS$_onVrDisplayConnect; external set JS$_onVrDisplayConnect(v); external get JS$_onVrDisplayDisconnect; external set JS$_onVrDisplayDisconnect(v); external get JS$_onVrDisplayPresentChange; external set JS$_onVrDisplayPresentChange(v);
 /// Observable signaled when VR display mode changes
 external Observable<IDisplayChangedEventArgs> get onVRDisplayChangedObservable; external set onVRDisplayChangedObservable(Observable<IDisplayChangedEventArgs> v);
 /// Observable signaled when VR request present is complete
 external Observable<bool> get onVRRequestPresentComplete; external set onVRRequestPresentComplete(Observable<bool> v);
 /// Observable signaled when VR request present starts
 external Observable<Engine> get onVRRequestPresentStart; external set onVRRequestPresentStart(Observable<Engine> v); external get JS$_hardwareScalingLevel; external set JS$_hardwareScalingLevel(v);
 /// @hidden
 external EngineCapabilities get JS$_caps; external set JS$_caps(EngineCapabilities v); external get JS$_pointerLockRequested; external set JS$_pointerLockRequested(v); external get JS$_isStencilEnable; external set JS$_isStencilEnable(v); external get JS$_colorWrite; external set JS$_colorWrite(v); external get JS$_loadingScreen; external set JS$_loadingScreen(v);
 /// @hidden
 external PerfCounter get JS$_drawCalls; external set JS$_drawCalls(PerfCounter v);
 /// @hidden
 external PerfCounter get JS$_textureCollisions; external set JS$_textureCollisions(PerfCounter v); external get JS$_glVersion; external set JS$_glVersion(v); external get JS$_glRenderer; external set JS$_glRenderer(v); external get JS$_glVendor; external set JS$_glVendor(v); external get JS$_videoTextureSupported; external set JS$_videoTextureSupported(v); external get JS$_renderingQueueLaunched; external set JS$_renderingQueueLaunched(v); external get JS$_activeRenderLoops; external set JS$_activeRenderLoops(v); external get JS$_deterministicLockstep; external set JS$_deterministicLockstep(v); external get JS$_lockstepMaxSteps; external set JS$_lockstepMaxSteps(v);
 /// Observable signaled when a context lost event is raised
 external Observable<Engine> get onContextLostObservable; external set onContextLostObservable(Observable<Engine> v);
 /// Observable signaled when a context restored event is raised
 external Observable<Engine> get onContextRestoredObservable; external set onContextRestoredObservable(Observable<Engine> v); external get JS$_onContextLost; external set JS$_onContextLost(v); external get JS$_onContextRestored; external set JS$_onContextRestored(v); external get JS$_contextWasLost; external set JS$_contextWasLost(v); external get JS$_doNotHandleContextLost; external set JS$_doNotHandleContextLost(v); external get JS$_performanceMonitor; external set JS$_performanceMonitor(v); external get JS$_fps; external set JS$_fps(v); external get JS$_deltaTime; external set JS$_deltaTime(v);
 /// Turn this value on if you want to pause FPS computation when in background
 external bool get disablePerformanceMonitorInBackground; external set disablePerformanceMonitorInBackground(bool v);
 /// Gets the performance monitor attached to this engine
 /// @see http://doc.babylonjs.com/how_to/optimizing_your_scene#engineinstrumentation
 external PerformanceMonitor get performanceMonitor; external set performanceMonitor(PerformanceMonitor v);
 /// @hidden
 external JS$_DepthCullingState get JS$_depthCullingState; external set JS$_depthCullingState(JS$_DepthCullingState v);
 /// @hidden
 external JS$_StencilState get JS$_stencilState; external set JS$_stencilState(JS$_StencilState v);
 /// @hidden
 external JS$_AlphaState get JS$_alphaState; external set JS$_alphaState(JS$_AlphaState v);
 /// @hidden
 external num get JS$_alphaMode; external set JS$_alphaMode(num v); external get JS$_internalTexturesCache; external set JS$_internalTexturesCache(v);
 /// @hidden
 external num get JS$_activeChannel; external set JS$_activeChannel(num v); external get JS$_currentTextureChannel; external set JS$_currentTextureChannel(v);
 /// @hidden
 external dynamic/*JSMap of <String,InternalTexture|Null>*/ get JS$_boundTexturesCache; external set JS$_boundTexturesCache(dynamic/*JSMap of <String,InternalTexture|Null>*/ v);
 /// @hidden
 external Effect/*Effect|Null*/ get JS$_currentEffect; external set JS$_currentEffect(Effect/*Effect|Null*/ v);
 /// @hidden
 external Program/*Program|Null*/ get JS$_currentProgram; external set JS$_currentProgram(Program/*Program|Null*/ v); external get JS$_compiledEffects; external set JS$_compiledEffects(v); external get JS$_vertexAttribArraysEnabled; external set JS$_vertexAttribArraysEnabled(v);
 /// @hidden
 external Viewport/*Viewport|Null*/ get JS$_cachedViewport; external set JS$_cachedViewport(Viewport/*Viewport|Null*/ v); external get JS$_cachedVertexArrayObject; external set JS$_cachedVertexArrayObject(v);
 /// @hidden
 external dynamic get JS$_cachedVertexBuffers; external set JS$_cachedVertexBuffers(dynamic v);
 /// @hidden
 external Buffer/*Buffer|Null*/ get JS$_cachedIndexBuffer; external set JS$_cachedIndexBuffer(Buffer/*Buffer|Null*/ v);
 /// @hidden
 external Effect/*Effect|Null*/ get JS$_cachedEffectForVertexBuffers; external set JS$_cachedEffectForVertexBuffers(Effect/*Effect|Null*/ v);
 /// @hidden
 external InternalTexture/*InternalTexture|Null*/ get JS$_currentRenderTarget; external set JS$_currentRenderTarget(InternalTexture/*InternalTexture|Null*/ v); external get JS$_uintIndicesCurrentlySet; external set JS$_uintIndicesCurrentlySet(v); external get JS$_currentBoundBuffer; external set JS$_currentBoundBuffer(v);
 /// @hidden
 external Framebuffer/*Framebuffer|Null*/ get JS$_currentFramebuffer; external set JS$_currentFramebuffer(Framebuffer/*Framebuffer|Null*/ v); external get JS$_currentBufferPointers; external set JS$_currentBufferPointers(v); external get JS$_currentInstanceLocations; external set JS$_currentInstanceLocations(v); external get JS$_currentInstanceBuffers; external set JS$_currentInstanceBuffers(v); external get JS$_textureUnits; external set JS$_textureUnits(v); external get JS$_firstBoundInternalTextureTracker; external set JS$_firstBoundInternalTextureTracker(v); external get JS$_lastBoundInternalTextureTracker; external set JS$_lastBoundInternalTextureTracker(v); external get JS$_workingCanvas; external set JS$_workingCanvas(v); external get JS$_workingContext; external set JS$_workingContext(v); external get JS$_rescalePostProcess; external set JS$_rescalePostProcess(v); external get JS$_dummyFramebuffer; external set JS$_dummyFramebuffer(v); external get JS$_externalData; external set JS$_externalData(v); external get JS$_bindedRenderFunction; external set JS$_bindedRenderFunction(v); external get JS$_vaoRecordInProgress; external set JS$_vaoRecordInProgress(v); external get JS$_mustWipeVertexAttributes; external set JS$_mustWipeVertexAttributes(v); external get JS$_emptyTexture; external set JS$_emptyTexture(v); external get JS$_emptyCubeTexture; external set JS$_emptyCubeTexture(v); external get JS$_emptyTexture3D; external set JS$_emptyTexture3D(v); external get JS$_frameHandler; external set JS$_frameHandler(v); external get JS$_nextFreeTextureSlots; external set JS$_nextFreeTextureSlots(v); external get JS$_maxSimultaneousTextures; external set JS$_maxSimultaneousTextures(v); external get JS$_activeRequests; external set JS$_activeRequests(v); external get JS$_texturesSupported; external set JS$_texturesSupported(v); external get JS$_textureFormatInUse; external set JS$_textureFormatInUse(v);
 /// Gets the list of texture formats supported
 external List<String> get texturesSupported; external set texturesSupported(List<String> v);
 /// Gets the list of texture formats in use
 external String/*String|Null*/ get textureFormatInUse; external set textureFormatInUse(String/*String|Null*/ v);
 /// Gets the current viewport
 external Viewport/*Viewport|Null*/ get currentViewport; external set currentViewport(Viewport/*Viewport|Null*/ v);
 /// Gets the default empty texture
 external InternalTexture get emptyTexture; external set emptyTexture(InternalTexture v);
 /// Gets the default empty 3D texture
 external InternalTexture get emptyTexture3D; external set emptyTexture3D(InternalTexture v);
 /// Gets the default empty cube texture
 external InternalTexture get emptyCubeTexture; external set emptyCubeTexture(InternalTexture v);
 /// Creates a new engine
 external factory Engine(dynamic/*CanvasElement|RenderingContext|Null*/ canvasOrContext, [bool antialias, EngineOptions options, bool adaptToDeviceRatio]); external JS$_rebuildInternalTextures(); external JS$_rebuildEffects(); external JS$_rebuildBuffers(); external JS$_initGLContext();
 /// Gets version of the current webGL context
 external num get webGLVersion; external set webGLVersion(num v);
 /// Returns true if the stencil buffer has been enabled through the creation option of the context.
 external bool get isStencilEnable; external set isStencilEnable(bool v); external JS$_prepareWorkingCanvas();
 /// Reset the texture cache to empty state
 external void resetTextureCache();
 /// Gets a boolean indicating that the engine is running in deterministic lock step mode
 /// @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
 external bool isDeterministicLockStep();
 /// Gets the max steps when engine is running in deterministic lock step
 /// @see http://doc.babylonjs.com/babylon101/animations#deterministic-lockstep
 external num getLockstepMaxSteps();
 /// Gets an object containing information about the current webGL context
 external dynamic/*{
            vendor: string;
            renderer: string;
            version: string;
        }*/ getGlInfo();
 /// Gets current aspect ratio
 external num getAspectRatio(Camera camera, [bool useScreen]);
 /// Gets the current render width
 external num getRenderWidth([bool useScreen]);
 /// Gets the current render height
 external num getRenderHeight([bool useScreen]);
 /// Gets the HTML canvas attached with the current webGL context
 external CanvasElement/*CanvasElement|Null*/ getRenderingCanvas();
 /// Gets the client rect of the HTML canvas attached with the current webGL context
 external Rectangle/*Rectangle|Null*/ getRenderingCanvasClientRect();
 /// Defines the hardware scaling level.
 /// By default the hardware scaling level is computed from the window device ratio.
 /// if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
 external void setHardwareScalingLevel(num level);
 /// Gets the current hardware scaling level.
 /// By default the hardware scaling level is computed from the window device ratio.
 /// if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
 external num getHardwareScalingLevel();
 /// Gets the list of loaded textures
 external List<InternalTexture> getLoadedTexturesCache();
 /// Gets the object containing all engine capabilities
 external EngineCapabilities getCaps();
 /// @hidden
 external num get drawCalls; external set drawCalls(num v);
 /// @hidden
 external PerfCounter/*PerfCounter|Null*/ get drawCallsPerfCounter; external set drawCallsPerfCounter(PerfCounter/*PerfCounter|Null*/ v);
 /// Gets the current depth function
 external num/*num|Null*/ getDepthFunction();
 /// Sets the current depth function
 external void setDepthFunction(num depthFunc);
 /// Sets the current depth function to GREATER
 external void setDepthFunctionToGreater();
 /// Sets the current depth function to GEQUAL
 external void setDepthFunctionToGreaterOrEqual();
 /// Sets the current depth function to LESS
 external void setDepthFunctionToLess();
 /// Sets the current depth function to LEQUAL
 external void setDepthFunctionToLessOrEqual();
 /// Gets a boolean indicating if stencil buffer is enabled
 external bool getStencilBuffer();
 /// Enable or disable the stencil buffer
 external void setStencilBuffer(bool enable);
 /// Gets the current stencil mask
 external num getStencilMask();
 /// Sets the current stencil mask
 external void setStencilMask(num mask);
 /// Gets the current stencil function
 external num getStencilFunction();
 /// Gets the current stencil reference value
 external num getStencilFunctionReference();
 /// Gets the current stencil mask
 external num getStencilFunctionMask();
 /// Sets the current stencil function
 external void setStencilFunction(num stencilFunc);
 /// Sets the current stencil reference
 external void setStencilFunctionReference(num reference);
 /// Sets the current stencil mask
 external void setStencilFunctionMask(num mask);
 /// Gets the current stencil operation when stencil fails
 external num getStencilOperationFail();
 /// Gets the current stencil operation when depth fails
 external num getStencilOperationDepthFail();
 /// Gets the current stencil operation when stencil passes
 external num getStencilOperationPass();
 /// Sets the stencil operation to use when stencil fails
 external void setStencilOperationFail(num operation);
 /// Sets the stencil operation to use when depth fails
 external void setStencilOperationDepthFail(num operation);
 /// Sets the stencil operation to use when stencil passes
 external void setStencilOperationPass(num operation);
 /// Sets a boolean indicating if the dithering state is enabled or disabled
 external void setDitheringState(bool value);
 /// Sets a boolean indicating if the rasterizer state is enabled or disabled
 external void setRasterizerState(bool value);
 /// stop executing a render loop function and remove it from the execution array
 external void stopRenderLoop([void renderFunction()]);
 /// @hidden
 external void JS$_renderLoop();
 /// Register and execute a render loop. The engine can have more than one render function
 external void runRenderLoop(void renderFunction());
 /// Toggle full screen mode
 external void switchFullscreen(bool requestPointerLock);
 /// Clear the current render buffer or the current render target (if any is set up)
 external void clear(Color4/*Color4|Null*/ color, bool backBuffer, bool depth, [bool stencil]);
 /// Executes a scissor clear (ie. a clear on a specific portion of the screen)
 external void scissorClear(num x, num y, num width, num height, Color4 clearColor);
 /// Set the WebGL's viewport
 external void setViewport(Viewport viewport, [num requiredWidth, num requiredHeight]);
 /// Directly set the WebGL Viewport
 external Viewport/*Viewport|Null*/ setDirectViewport(num x, num y, num width, num height);
 /// Begin a new frame
 external void beginFrame();
 /// Enf the current frame
 external void endFrame();
 /// Resize the view according to the canvas' size
 external void resize();
 /// Force a specific size of the canvas
 external void setSize(num width, num height);
 /// Gets a boolean indicating if a webVR device was detected
 external bool isVRDevicePresent();
 /// Gets the current webVR device
 external dynamic getVRDevice();
 /// Initializes a webVR display and starts listening to display change events
 /// The onVRDisplayChangedObservable will be notified upon these changes
 external Observable<IDisplayChangedEventArgs> initWebVR();
 /// Initializes a webVR display and starts listening to display change events
 /// The onVRDisplayChangedObservable will be notified upon these changes
 external Promise<IDisplayChangedEventArgs> initWebVRAsync();
 /// Call this function to switch to webVR mode
 /// Will do nothing if webVR is not supported or if there is no webVR device
 /// @see http://doc.babylonjs.com/how_to/webvr_camera
 external void enableVR();
 /// Call this function to leave webVR mode
 /// Will do nothing if webVR is not supported or if there is no webVR device
 /// @see http://doc.babylonjs.com/how_to/webvr_camera
 external void disableVR(); external get JS$_onVRFullScreenTriggered; external set JS$_onVRFullScreenTriggered(v); external JS$_getVRDisplaysAsync();
 /// Binds the frame buffer to the specified texture.
 external void bindFramebuffer(InternalTexture texture, [num faceIndex, num requiredWidth, num requiredHeight, bool forceFullscreenViewport, InternalTexture depthStencilTexture]); external bindUnboundFramebuffer(framebuffer);
 /// Unbind the current render target texture from the webGL context
 external void unBindFramebuffer(InternalTexture texture, [bool disableGenerateMipMaps, void onBeforeUnbind()]);
 /// Unbind a list of render target textures from the webGL context
 /// This is used only when drawBuffer extension or webGL2 are active
 external void unBindMultiColorAttachmentFramebuffer(List<InternalTexture> textures, [bool disableGenerateMipMaps, void onBeforeUnbind()]);
 /// Force the mipmap generation for the given render target texture
 external void generateMipMapsForCubemap(InternalTexture texture);
 /// Force a webGL flush (ie. a flush of all waiting webGL commands)
 external void flushFramebuffer();
 /// Unbind the current render target and bind the default framebuffer
 external void restoreDefaultFramebuffer();
 /// Create an uniform buffer
 /// @see http://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
 external Buffer createUniformBuffer(dynamic/*List<num>|Float32List*/ elements);
 /// Create a dynamic uniform buffer
 /// @see http://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
 external Buffer createDynamicUniformBuffer(dynamic/*List<num>|Float32List*/ elements);
 /// Update an existing uniform buffer
 /// @see http://doc.babylonjs.com/features/webgl2#uniform-buffer-objets
 external void updateUniformBuffer(Buffer uniformBuffer, dynamic/*List<num>|Float32List*/ elements, [num offset, num count]); external JS$_resetVertexBufferBinding();
 /// Creates a vertex buffer
 external Buffer createVertexBuffer(dynamic/*List<num>|ByteBuffer|TypedData*/ data);
 /// Creates a dynamic vertex buffer
 external Buffer createDynamicVertexBuffer(dynamic/*List<num>|ByteBuffer|TypedData*/ data);
 /// Update a dynamic index buffer
 external void updateDynamicIndexBuffer(Buffer indexBuffer, dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num offset]);
 /// Updates a dynamic vertex buffer.
 external void updateDynamicVertexBuffer(Buffer vertexBuffer, dynamic/*List<num>|ByteBuffer|TypedData*/ data, [num byteOffset, num byteLength]); external JS$_resetIndexBufferBinding();
 /// Creates a new index buffer
 external Buffer createIndexBuffer(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [bool updatable]);
 /// Bind a webGL buffer to the webGL context
 external void bindArrayBuffer(Buffer/*Buffer|Null*/ buffer);
 /// Bind an uniform buffer to the current webGL context
 external void bindUniformBuffer(Buffer/*Buffer|Null*/ buffer);
 /// Bind a buffer to the current webGL context at a given location
 external void bindUniformBufferBase(Buffer buffer, num location);
 /// Bind a specific block at a given index in a specific shader program
 external void bindUniformBlock(Program shaderProgram, String blockName, num index); external bindIndexBuffer(buffer); external bindBuffer(buffer, target);
 /// update the bound buffer with the given data
 external void updateArrayBuffer(Float32List data); external JS$_vertexAttribPointer(buffer, indx, size, type, normalized, stride, offset); external JS$_bindIndexBufferWithCache(indexBuffer); external JS$_bindVertexBuffersAttributes(vertexBuffers, effect);
 /// Records a vertex array object
 /// @see http://doc.babylonjs.com/features/webgl2#vertex-array-objects
 external WebGLVertexArrayObject recordVertexArrayObject(dynamic/*JSMap of <String,VertexBuffer>*/ vertexBuffers, Buffer/*Buffer|Null*/ indexBuffer, Effect effect);
 /// Bind a specific vertex array object
 /// @see http://doc.babylonjs.com/features/webgl2#vertex-array-objects
 external void bindVertexArrayObject(WebGLVertexArrayObject vertexArrayObject, Buffer/*Buffer|Null*/ indexBuffer);
 /// Bind webGl buffers directly to the webGL context
 external void bindBuffersDirectly(Buffer vertexBuffer, Buffer indexBuffer, List<num> vertexDeclaration, num vertexStrideSize, Effect effect); external JS$_unbindVertexArrayObject();
 /// Bind a list of vertex buffers to the webGL context
 external void bindBuffers(dynamic/*JSMap of <String,VertexBuffer|Null>*/ vertexBuffers, Buffer/*Buffer|Null*/ indexBuffer, Effect effect);
 /// Unbind all instance attributes
 external void unbindInstanceAttributes();
 /// Release and free the memory of a vertex array object
 external void releaseVertexArrayObject(WebGLVertexArrayObject vao);
 /// @hidden
 external bool JS$_releaseBuffer(Buffer buffer);
 /// Creates a webGL buffer to use with instanciation
 external Buffer createInstancesBuffer(num capacity);
 /// Delete a webGL buffer used with instanciation
 external void deleteInstancesBuffer(Buffer buffer);
 /// Update the content of a webGL buffer used with instanciation and bind it to the webGL context
 external void updateAndBindInstancesBuffer(Buffer instancesBuffer, Float32List data, List<dynamic>/*List<num>|List<InstancingAttributeInfo>*/ offsetLocations);
 /// Apply all cached states (depth, culling, stencil and alpha)
 external void applyStates();
 /// Send a draw order
 external void draw(bool useTriangles, num indexStart, num indexCount, [num instancesCount]);
 /// Draw a list of points
 external void drawPointClouds(num verticesStart, num verticesCount, [num instancesCount]);
 /// Draw a list of unindexed primitives
 external void drawUnIndexed(bool useTriangles, num verticesStart, num verticesCount, [num instancesCount]);
 /// Draw a list of indexed primitives
 external void drawElementsType(num fillMode, num indexStart, num indexCount, [num instancesCount]);
 /// Draw a list of unindexed primitives
 external void drawArraysType(num fillMode, num verticesStart, num verticesCount, [num instancesCount]); external JS$_drawMode(fillMode);
 /// @hidden
 external void JS$_releaseEffect(Effect effect);
 /// @hidden
 external void JS$_deleteProgram(Program program);
 /// Create a new effect (used to store vertex/fragment shaders)
 external Effect createEffect(dynamic baseName, dynamic/*List<String>|EffectCreationOptions*/ attributesNamesOrOptions, dynamic/*List<String>|Engine*/ uniformsNamesOrEngine, [List<String> samplers, String defines, EffectFallbacks fallbacks, void onCompiled(Effect effect), void onError(Effect effect, String errors), dynamic indexParameters]);
 /// Create an effect to use with particle systems
 external Effect createEffectForParticles(String fragmentName, [List<String> uniformsNames, List<String> samplers, String defines, EffectFallbacks fallbacks, void onCompiled(Effect effect), void onError(Effect effect, String errors)]);
 /// Directly creates a webGL program
 external Program createRawShaderProgram(String vertexCode, String fragmentCode, [RenderingContext context, List<String>/*List<String>|Null*/ transformFeedbackVaryings]);
 /// Creates a webGL program
 external Program createShaderProgram(String vertexCode, String fragmentCode, String/*String|Null*/ defines, [RenderingContext context, List<String>/*List<String>|Null*/ transformFeedbackVaryings]); external JS$_createShaderProgram(vertexShader, fragmentShader, context, [transformFeedbackVaryings]);
 /// Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names
 external List<UniformLocation/*UniformLocation|Null*/> getUniforms(Program shaderProgram, List<String> uniformsNames);
 /// Gets the lsit of active attributes for a given webGL program
 external List<num> getAttributes(Program shaderProgram, List<String> attributesNames);
 /// Activates an effect, mkaing it the current one (ie. the one used for rendering)
 external void enableEffect(Effect/*Effect|Null*/ effect);
 /// Set the value of an uniform to an array of int32
 external void setIntArray(UniformLocation/*UniformLocation|Null*/ uniform, Int32List array);
 /// Set the value of an uniform to an array of int32 (stored as vec2)
 external void setIntArray2(UniformLocation/*UniformLocation|Null*/ uniform, Int32List array);
 /// Set the value of an uniform to an array of int32 (stored as vec3)
 external void setIntArray3(UniformLocation/*UniformLocation|Null*/ uniform, Int32List array);
 /// Set the value of an uniform to an array of int32 (stored as vec4)
 external void setIntArray4(UniformLocation/*UniformLocation|Null*/ uniform, Int32List array);
 /// Set the value of an uniform to an array of float32
 external void setFloatArray(UniformLocation/*UniformLocation|Null*/ uniform, Float32List array);
 /// Set the value of an uniform to an array of float32 (stored as vec2)
 external void setFloatArray2(UniformLocation/*UniformLocation|Null*/ uniform, Float32List array);
 /// Set the value of an uniform to an array of float32 (stored as vec3)
 external void setFloatArray3(UniformLocation/*UniformLocation|Null*/ uniform, Float32List array);
 /// Set the value of an uniform to an array of float32 (stored as vec4)
 external void setFloatArray4(UniformLocation/*UniformLocation|Null*/ uniform, Float32List array);
 /// Set the value of an uniform to an array of number
 external void setArray(UniformLocation/*UniformLocation|Null*/ uniform, List<num> array);
 /// Set the value of an uniform to an array of number (stored as vec2)
 external void setArray2(UniformLocation/*UniformLocation|Null*/ uniform, List<num> array);
 /// Set the value of an uniform to an array of number (stored as vec3)
 external void setArray3(UniformLocation/*UniformLocation|Null*/ uniform, List<num> array);
 /// Set the value of an uniform to an array of number (stored as vec4)
 external void setArray4(UniformLocation/*UniformLocation|Null*/ uniform, List<num> array);
 /// Set the value of an uniform to an array of float32 (stored as matrices)
 external void setMatrices(UniformLocation/*UniformLocation|Null*/ uniform, Float32List matrices);
 /// Set the value of an uniform to a matrix
 external void setMatrix(UniformLocation/*UniformLocation|Null*/ uniform, Matrix matrix);
 /// Set the value of an uniform to a matrix (3x3)
 external void setMatrix3x3(UniformLocation/*UniformLocation|Null*/ uniform, Float32List matrix);
 /// Set the value of an uniform to a matrix (2x2)
 external void setMatrix2x2(UniformLocation/*UniformLocation|Null*/ uniform, Float32List matrix);
 /// Set the value of an uniform to a number (int)
 external void setInt(UniformLocation/*UniformLocation|Null*/ uniform, num value);
 /// Set the value of an uniform to a number (float)
 external void setFloat(UniformLocation/*UniformLocation|Null*/ uniform, num value);
 /// Set the value of an uniform to a vec2
 external void setFloat2(UniformLocation/*UniformLocation|Null*/ uniform, num x, num y);
 /// Set the value of an uniform to a vec3
 external void setFloat3(UniformLocation/*UniformLocation|Null*/ uniform, num x, num y, num z);
 /// Set the value of an uniform to a boolean
 external void setBool(UniformLocation/*UniformLocation|Null*/ uniform, num bool);
 /// Set the value of an uniform to a vec4
 external void setFloat4(UniformLocation/*UniformLocation|Null*/ uniform, num x, num y, num z, num w);
 /// Set the value of an uniform to a Color3
 external void setColor3(UniformLocation/*UniformLocation|Null*/ uniform, Color3 color3);
 /// Set the value of an uniform to a Color3 and an alpha value
 external void setColor4(UniformLocation/*UniformLocation|Null*/ uniform, Color3 color3, num alpha);
 /// Sets a Color4 on a uniform variable
 external void setDirectColor4(UniformLocation/*UniformLocation|Null*/ uniform, Color4 color4);
 /// Set various states to the webGL context
 external void setState(bool culling, [num zOffset, bool force, bool reverseSide]);
 /// Set the z offset to apply to current rendering
 external void setZOffset(num value);
 /// Gets the current value of the zOffset
 external num getZOffset();
 /// Enable or disable depth buffering
 external void setDepthBuffer(bool enable);
 /// Gets a boolean indicating if depth writing is enabled
 external bool getDepthWrite();
 /// Enable or disable depth writing
 external void setDepthWrite(bool enable);
 /// Enable or disable color writing
 external void setColorWrite(bool enable);
 /// Gets a boolean indicating if color writing is enabled
 external bool getColorWrite();
 /// Sets alpha constants used by some alpha blending modes
 external void setAlphaConstants(num r, num g, num b, num a);
 /// Sets the current alpha mode
 /// @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
 external void setAlphaMode(num mode, [bool noDepthWriteChange]);
 /// Gets the current alpha mode
 /// @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered
 external num getAlphaMode();
 /// Force the entire cache to be cleared
 /// You should not have to use this function unless your engine needs to share the webGL context with another engine
 external void wipeCaches([bool bruteForce]);
 /// Set the compressed texture format to use, based on the formats you have, and the formats
 /// supported by the hardware / browser.
 /// Khronos Texture Container (.ktx) files are used to support this.  This format has the
 /// advantage of being specifically designed for OpenGL.  Header elements directly correspond
 /// to API arguments needed to compressed textures.  This puts the burden on the container
 /// generator to house the arcane code for determining these for current & future formats.
 /// for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 /// for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 /// Note: The result of this call is not taken into account when a texture is base64.
 /// on your server.  Syntax: '-' + format family + '.ktx'.  (Case and order do not matter.)
 /// Current families are astc, dxt, pvrtc, etc2, & etc1.
 external String/*String|Null*/ setTextureFormatToUse(List<String> formatsAvailable);
 /// @hidden
 external Texture JS$_createTexture();
 /// Usually called from BABYLON.Texture.ts.
 /// Passed information to create a WebGLTexture
 /// * A conventional http URL, e.g. 'http://...' or 'file://...'
 /// * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
 /// * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
 external InternalTexture createTexture(String/*String|Null*/ urlArg, bool noMipmap, bool invertY, Scene/*Scene|Null*/ scene, [num samplingMode, VoidFunc0/*VoidFunc0|Null*/ onLoad, VoidFunc2<String, dynamic>/*VoidFunc2<String, dynamic>|Null*/ onError, dynamic/*ByteBuffer|ImageElement|Null*/ buffer, InternalTexture/*InternalTexture|Null*/ fallback, num/*num|Null*/ format]); external JS$_rescaleTexture(source, destination, scene, internalFormat, onComplete);
 /// Update a raw texture
 external void updateRawTexture(InternalTexture/*InternalTexture|Null*/ texture, TypedData/*TypedData|Null*/ data, num format, bool invertY, [String/*String|Null*/ compression, num type]);
 /// Creates a raw texture
 external InternalTexture createRawTexture(TypedData/*TypedData|Null*/ data, num width, num height, num format, bool generateMipMaps, bool invertY, num samplingMode, [String/*String|Null*/ compression, num type]);
 /// Creates a dynamic texture
 external InternalTexture createDynamicTexture(num width, num height, bool generateMipMaps, num samplingMode);
 /// Update the sampling mode of a given texture
 external void updateTextureSamplingMode(num samplingMode, InternalTexture texture);
 /// Update the content of a dynamic texture
 external void updateDynamicTexture(InternalTexture/*InternalTexture|Null*/ texture, CanvasElement canvas, bool invertY, [bool premulAlpha, num format]);
 /// Update a video texture
 external void updateVideoTexture(InternalTexture/*InternalTexture|Null*/ texture, VideoElement video, bool invertY);
 /// Updates a depth texture Comparison Mode and Function.
 /// If the comparison Function is equal to 0, the mode will be set to none.
 /// Otherwise, this only works in webgl 2 and requires a shadow sampler in the shader.
 external void updateTextureComparisonFunction(InternalTexture texture, num comparisonFunction); external JS$_setupDepthStencilTexture(internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction);
 /// Creates a depth stencil texture.
 /// This is only available in WebGL 2 or with the depth texture extension available.
 external InternalTexture createDepthStencilTexture(dynamic/*num|{
            width: number;
            height: number;
        }*/ size, DepthTextureCreationOptions options);
 /// Creates a depth stencil texture.
 /// This is only available in WebGL 2 or with the depth texture extension available.
 external JS$_createDepthStencilTexture(size, options);
 /// Creates a depth stencil cube texture.
 /// This is only available in WebGL 2.
 external JS$_createDepthStencilCubeTexture(size, options);
 /// Sets the frame buffer Depth / Stencil attachement of the render target to the defined depth stencil texture.
 external void setFrameBufferDepthStencilTexture(RenderTargetTexture renderTarget);
 /// Creates a new render target texture
 external InternalTexture createRenderTargetTexture(dynamic/*num|{
            width: number;
            height: number;
        }*/ size, dynamic/*bool|RenderTargetCreationOptions*/ options);
 /// Create a multi render target texture
 /// @see http://doc.babylonjs.com/features/webgl2#multiple-render-target
 external List<InternalTexture> createMultipleRenderTarget(dynamic size, IMultiRenderTargetOptions options); external JS$_setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height, [samples]);
 /// Updates the sample count of a render target texture
 /// @see http://doc.babylonjs.com/features/webgl2#multisample-render-targets
 external num updateRenderTargetTextureSampleCount(InternalTexture/*InternalTexture|Null*/ texture, num samples);
 /// Update the sample count for a given multiple render target texture
 /// @see http://doc.babylonjs.com/features/webgl2#multisample-render-targets
 external num updateMultipleRenderTargetTextureSampleCount(List<InternalTexture>/*List<InternalTexture>|Null*/ textures, num samples);
 /// @hidden
 external void JS$_uploadDataToTexture(num target, num lod, num internalFormat, num width, num height, num format, num type, TypedData data);
 /// @hidden
 external void JS$_uploadCompressedDataToTexture(num target, num lod, num internalFormat, num width, num height, TypedData data);
 /// Creates a new render target cube texture
 external InternalTexture createRenderTargetCubeTexture(num size, [Partial<RenderTargetCreationOptions> options]);
 /// Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)
 external InternalTexture createPrefilteredCubeTexture(String rootUrl, Scene/*Scene|Null*/ scene, num scale, num offset, [VoidFunc1<InternalTexture>/*VoidFunc1<InternalTexture|Null>|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, num format, dynamic forcedExtension]);
 /// Creates a cube texture
 external InternalTexture createCubeTexture(String rootUrl, Scene/*Scene|Null*/ scene, List<String>/*List<String>|Null*/ files, [bool noMipmap, VoidFunc1Opt1<dynamic>/*VoidFunc1Opt1<dynamic>|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, num format, dynamic forcedExtension, bool createPolynomials]); external setCubeMapTextureParams(gl, loadMipmap);
 /// Update a raw cube texture
 external void updateRawCubeTexture(InternalTexture texture, List<TypedData> data, num format, num type, bool invertY, [String/*String|Null*/ compression, num level]);
 /// Creates a new raw cube texture
 external InternalTexture createRawCubeTexture(List<TypedData>/*List<TypedData>|Null*/ data, num size, num format, num type, bool generateMipMaps, bool invertY, num samplingMode, [String/*String|Null*/ compression]);
 /// Creates a new raw cube texture from a specified url
 external InternalTexture createRawCubeTextureFromUrl(String url, Scene scene, num size, num format, num type, bool noMipmap, List<TypedData>/*List<TypedData>|Null*/ callback(ByteBuffer ArrayBuffer), Func1<List<TypedData>, List<List<TypedData>>>/*Func1<List<TypedData>, List<List<TypedData>>>|Null*/ mipmapGenerator, [VoidFunc0/*VoidFunc0|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, num samplingMode, bool invertY]);
 /// Update a raw 3D texture
 external void updateRawTexture3D(InternalTexture texture, TypedData/*TypedData|Null*/ data, num format, bool invertY, [String/*String|Null*/ compression]);
 /// Creates a new raw 3D texture
 external InternalTexture createRawTexture3D(TypedData/*TypedData|Null*/ data, num width, num height, num depth, num format, bool generateMipMaps, bool invertY, num samplingMode, [String/*String|Null*/ compression]); external JS$_prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode); external JS$_prepareWebGLTexture(texture, scene, width, height, invertY, noMipmap, isCompressed, processFunction, [samplingMode]); external JS$_convertRGBtoRGBATextureData(rgbData, width, height, textureType);
 /// @hidden
 external void JS$_releaseFramebufferObjects(InternalTexture texture);
 /// @hidden
 external void JS$_releaseTexture(InternalTexture texture); external setProgram(program); external get JS$_boundUniforms; external set JS$_boundUniforms(v);
 /// Binds an effect to the webGL context
 external void bindSamplers(Effect effect); external JS$_moveBoundTextureOnTop(internalTexture); external JS$_getCorrectTextureChannel(channel, internalTexture); external JS$_linkTrackers(previous, next); external JS$_removeDesignatedSlot(internalTexture); external JS$_activateCurrentTexture();
 /// @hidden
 external void JS$_bindTextureDirectly(num target, InternalTexture/*InternalTexture|Null*/ texture, [bool forTextureDataUpdate, bool force]);
 /// @hidden
 external void JS$_bindTexture(num channel, InternalTexture/*InternalTexture|Null*/ texture);
 /// Sets a texture to the webGL context from a postprocess
 external void setTextureFromPostProcess(num channel, PostProcess/*PostProcess|Null*/ postProcess);
 /// Binds the output of the passed in post process to the texture channel specified
 external void setTextureFromPostProcessOutput(num channel, PostProcess/*PostProcess|Null*/ postProcess);
 /// Unbind all textures from the webGL context
 external void unbindAllTextures();
 /// Sets a texture to the according uniform.
 external void setTexture(num channel, UniformLocation/*UniformLocation|Null*/ uniform, BaseTexture/*BaseTexture|Null*/ texture);
 /// Sets a depth stencil texture from a render target to the according uniform.
 external void setDepthStencilTexture(num channel, UniformLocation/*UniformLocation|Null*/ uniform, RenderTargetTexture/*RenderTargetTexture|Null*/ texture); external JS$_bindSamplerUniformToChannel(sourceSlot, destination); external JS$_getTextureWrapMode(mode); external JS$_setTexture(channel, texture, [isPartOfTextureArray, depthStencilTexture]);
 /// Sets an array of texture to the webGL context
 external void setTextureArray(num channel, UniformLocation/*UniformLocation|Null*/ uniform, List<BaseTexture> textures);
 /// @hidden
 external void JS$_setAnisotropicLevel(num target, BaseTexture texture); external JS$_setTextureParameterFloat(target, parameter, value, texture); external JS$_setTextureParameterInteger(target, parameter, value, [texture]);
 /// Reads pixels from the current frame buffer. Please note that this function can be slow
 external Uint8List readPixels(num x, num y, num width, num height);
 /// Add an externaly attached data from its key.
 /// This method call will fail and return false, if such key already exists.
 /// If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.
 external bool addExternalData /*<T>*/(String key, dynamic/*=T*/ data);
 /// Get an externaly attached data from its key
 external dynamic/*=T*/ getExternalData /*<T>*/(String key);
 /// Get an externaly attached data from its key, create it using a factory if it's not already present
 external dynamic/*=T*/ getOrAddExternalDataWithFactory /*<T>*/(String key, dynamic/*=T*/ JS$factory(String k));
 /// Remove an externaly attached data from the Engine instance
 external bool removeExternalData(String key);
 /// Unbind all vertex attributes from the webGL context
 external void unbindAllAttributes();
 /// Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
 external void releaseEffects();
 /// Dispose and release all associated resources
 external void dispose();
 /// Display the loading screen
 /// @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
 external void displayLoadingUI();
 /// Hide the loading screen
 /// @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
 external void hideLoadingUI();
 /// Gets the current loading screen object
 /// @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
 /// Sets the current loading screen object
 /// @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
 external ILoadingScreen get loadingScreen; external set loadingScreen(ILoadingScreen v);
 /// Sets the current loading screen text
 /// @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
 external String get loadingUIText; external set loadingUIText(String v);
 /// Sets the current loading screen background color
 /// @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
 external String get loadingUIBackgroundColor; external set loadingUIBackgroundColor(String v);
 /// Attach a new callback raised when context lost event is fired
 external void attachContextLostEvent(VoidFunc1<ContextEvent> callback);
 /// Attach a new callback raised when context restored event is fired
 external void attachContextRestoredEvent(VoidFunc1<ContextEvent> callback);
 /// Gets the source code of the vertex shader associated with a specific webGL program
 external String/*String|Null*/ getVertexShaderSource(Program program);
 /// Gets the source code of the fragment shader associated with a specific webGL program
 external String/*String|Null*/ getFragmentShaderSource(Program program);
 /// Get the current error code of the webGL context
 /// @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
 external num getError();
 /// Gets the current framerate
 external num getFps();
 /// Gets the time spent between current and previous frame
 external num getDeltaTime(); external JS$_measureFps();
 /// @hidden
 external TypedData JS$_readTexturePixels(InternalTexture texture, num width, num height, [num faceIndex]); external JS$_canRenderToFloatFramebuffer(); external JS$_canRenderToHalfFloatFramebuffer(); external JS$_canRenderToFramebuffer(type);
 /// @hidden
 external num JS$_getWebGLTextureType(num type); external JS$_getInternalFormat(format);
 /// @hidden
 external num JS$_getRGBABufferInternalSizedFormat(num type, [num format]);
 /// @hidden
 external num JS$_getRGBAMultiSampleBufferFormat(num type);
 /// Create a new webGL query (you must be sure that queries are supported by checking getCaps() function)
 external WebGLQuery createQuery();
 /// Delete and release a webGL query
 external Engine deleteQuery(WebGLQuery query);
 /// Check if a given query has resolved and got its value
 external bool isQueryResultAvailable(WebGLQuery query);
 /// Gets the value of a given query
 external num getQueryResult(WebGLQuery query);
 /// Initiates an occlusion query
 /// @see http://doc.babylonjs.com/features/occlusionquery
 external Engine beginOcclusionQuery(num algorithmType, WebGLQuery query);
 /// Ends an occlusion query
 /// @see http://doc.babylonjs.com/features/occlusionquery
 external Engine endOcclusionQuery(num algorithmType); external JS$_createTimeQuery(); external JS$_deleteTimeQuery(query); external JS$_getTimeQueryResult(query); external JS$_getTimeQueryAvailability(query); external get JS$_currentNonTimestampToken; external set JS$_currentNonTimestampToken(v);
 /// Starts a time query (used to measure time spent by the GPU on a specific frame)
 /// Please note that only one query can be issued at a time
 external JS$_TimeToken/*JS$_TimeToken|Null*/ startTimeQuery();
 /// Ends a time query
 external num endTimeQuery(JS$_TimeToken token); external getGlAlgorithmType(algorithmType);
 /// Creates a webGL transform feedback object
 /// Please makes sure to check webGLVersion property to check if you are running webGL 2+
 external WebGLTransformFeedback createTransformFeedback();
 /// Delete a webGL transform feedback object
 external void deleteTransformFeedback(WebGLTransformFeedback value);
 /// Bind a webGL transform feedback object to the webgl context
 external void bindTransformFeedback(WebGLTransformFeedback/*WebGLTransformFeedback|Null*/ value);
 /// Begins a transform feedback operation
 external void beginTransformFeedback([bool usePoints]);
 /// Ends a transform feedback operation
 external void endTransformFeedback();
 /// Specify the varyings to use with transform feedback
 external void setTranformFeedbackVaryings(Program program, List<String> value);
 /// Bind a webGL buffer for a transform feedback operation
 external void bindTransformFeedbackBuffer(Buffer/*Buffer|Null*/ value);
 /// @hidden
 external IFileRequest JS$_loadFile(String url, void onSuccess(dynamic/*String|ByteBuffer*/ data, [String responseURL]), [void onProgress(dynamic data), Database database, bool useArrayBuffer, void onError([HttpRequest request, dynamic exception])]);
 /// @hidden
 external Promise<dynamic/*String|ByteBuffer*/> JS$_loadFileAsync(String url, [Database database, bool useArrayBuffer]); external JS$_partialLoadFile(url, index, loadedFiles, scene, onfinish, [onErrorCallBack]); external JS$_cascadeLoadFiles(scene, onfinish, files, [onError]);
 /// Gets a boolean indicating if the engine can be instanciated (ie. if a webGL context can be found)
 /// @ignorenaming
 external static bool isSupported(); }

 @JS("BABYLON.NullEngineOptions" ) class NullEngineOptions { // @Ignore
 NullEngineOptions .fakeConstructor$() ;
 external num get renderWidth; external set renderWidth(num v); external num get renderHeight; external set renderHeight(num v); external num get textureSize; external set textureSize(num v); external bool get deterministicLockstep; external set deterministicLockstep(bool v); external num get lockstepMaxSteps; external set lockstepMaxSteps(num v); }

 /// The null engine class provides support for headless version of babylon.js.
 /// This can be used in server side scenario or for testing purposes
 @JS("BABYLON.NullEngine" ) class NullEngine extends Engine { // @Ignore
 NullEngine .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_options; external set JS$_options(v); external bool isDeterministicLockStep(); external num getLockstepMaxSteps(); external num getHardwareScalingLevel(); external factory NullEngine([NullEngineOptions options]); external Buffer createVertexBuffer(dynamic/*List<num>|Float32List*/ vertices); external Buffer createIndexBuffer(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices); external void clear(Color4 color, bool backBuffer, bool depth, [bool stencil]); external num getRenderWidth([bool useScreen]); external num getRenderHeight([bool useScreen]); external void setViewport(Viewport viewport, [num requiredWidth, num requiredHeight]); external Program createShaderProgram(String vertexCode, String fragmentCode, String defines, [RenderingContext context]); external List<UniformLocation> getUniforms(Program shaderProgram, List<String> uniformsNames); external List<num> getAttributes(Program shaderProgram, List<String> attributesNames); external void bindSamplers(Effect effect); external void enableEffect(Effect effect); external void setState(bool culling, [num zOffset, bool force, bool reverseSide]); external void setIntArray(UniformLocation uniform, Int32List array); external void setIntArray2(UniformLocation uniform, Int32List array); external void setIntArray3(UniformLocation uniform, Int32List array); external void setIntArray4(UniformLocation uniform, Int32List array); external void setFloatArray(UniformLocation uniform, Float32List array); external void setFloatArray2(UniformLocation uniform, Float32List array); external void setFloatArray3(UniformLocation uniform, Float32List array); external void setFloatArray4(UniformLocation uniform, Float32List array); external void setArray(UniformLocation uniform, List<num> array); external void setArray2(UniformLocation uniform, List<num> array); external void setArray3(UniformLocation uniform, List<num> array); external void setArray4(UniformLocation uniform, List<num> array); external void setMatrices(UniformLocation uniform, Float32List matrices); external void setMatrix(UniformLocation uniform, Matrix matrix); external void setMatrix3x3(UniformLocation uniform, Float32List matrix); external void setMatrix2x2(UniformLocation uniform, Float32List matrix); external void setFloat(UniformLocation uniform, num value); external void setFloat2(UniformLocation uniform, num x, num y); external void setFloat3(UniformLocation uniform, num x, num y, num z); external void setBool(UniformLocation uniform, num bool); external void setFloat4(UniformLocation uniform, num x, num y, num z, num w); external void setColor3(UniformLocation uniform, Color3 color3); external void setColor4(UniformLocation uniform, Color3 color3, num alpha); external void setAlphaMode(num mode, [bool noDepthWriteChange]); external void bindBuffers(dynamic/*JSMap of <String,VertexBuffer>*/ vertexBuffers, Buffer indexBuffer, Effect effect); external void wipeCaches([bool bruteForce]); external void draw(bool useTriangles, num indexStart, num indexCount, [num instancesCount]); external void drawElementsType(num fillMode, num indexStart, num indexCount, [num instancesCount]); external void drawArraysType(num fillMode, num verticesStart, num verticesCount, [num instancesCount]); external Texture JS$_createTexture(); external void JS$_releaseTexture(InternalTexture texture); external InternalTexture createTexture(String urlArg, bool noMipmap, bool invertY, Scene scene, [num samplingMode, VoidFunc0/*VoidFunc0|Null*/ onLoad, VoidFunc2<String, dynamic>/*VoidFunc2<String, dynamic>|Null*/ onError, dynamic/*ByteBuffer|ImageElement|Null*/ buffer, InternalTexture fallBack, num format]); external InternalTexture createRenderTargetTexture(dynamic size, dynamic/*bool|RenderTargetCreationOptions*/ options); external void updateTextureSamplingMode(num samplingMode, InternalTexture texture); external void bindFramebuffer(InternalTexture texture, [num faceIndex, num requiredWidth, num requiredHeight, bool forceFullscreenViewport]); external void unBindFramebuffer(InternalTexture texture, [bool disableGenerateMipMaps, void onBeforeUnbind()]); external Buffer createDynamicVertexBuffer(dynamic/*List<num>|Float32List*/ vertices); external void updateDynamicIndexBuffer(Buffer indexBuffer, dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num offset]);
 /// Updates a dynamic vertex buffer.
 external void updateDynamicVertexBuffer(Buffer vertexBuffer, dynamic/*List<num>|Float32List*/ vertices, [num byteOffset, num byteLength]); external void JS$_bindTextureDirectly(num target, InternalTexture texture); external void JS$_bindTexture(num channel, InternalTexture texture); external bool JS$_releaseBuffer(Buffer buffer); external void releaseEffects(); }

 @JS("BABYLON.KeyboardEventTypes" ) class KeyboardEventTypes { // @Ignore
 KeyboardEventTypes .fakeConstructor$() ;
 external static num get JS$_KEYDOWN; external static set JS$_KEYDOWN(num v); external static num get JS$_KEYUP; external static set JS$_KEYUP(num v); external static num get KEYDOWN; external static set KEYDOWN(num v); external static num get KEYUP; external static set KEYUP(num v); }

 @JS("BABYLON.KeyboardInfo" ) class KeyboardInfo { // @Ignore
 KeyboardInfo .fakeConstructor$() ;
 external num get type; external set type(num v); external KeyboardEvent get event; external set event(KeyboardEvent v); external factory KeyboardInfo(num type, KeyboardEvent event); }

 /// This class is used to store keyboard related info for the onPreKeyboardObservable event.
 /// Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable
 @JS("BABYLON.KeyboardInfoPre" ) class KeyboardInfoPre extends KeyboardInfo { // @Ignore
 KeyboardInfoPre .fakeConstructor$() : super.fakeConstructor$() ;
 external factory KeyboardInfoPre(num type, KeyboardEvent event); external bool get skipOnPointerObservable; external set skipOnPointerObservable(bool v); }

 @JS("BABYLON.PointerEventTypes" ) class PointerEventTypes { // @Ignore
 PointerEventTypes .fakeConstructor$() ;
 external static num get JS$_POINTERDOWN; external static set JS$_POINTERDOWN(num v); external static num get JS$_POINTERUP; external static set JS$_POINTERUP(num v); external static num get JS$_POINTERMOVE; external static set JS$_POINTERMOVE(num v); external static num get JS$_POINTERWHEEL; external static set JS$_POINTERWHEEL(num v); external static num get JS$_POINTERPICK; external static set JS$_POINTERPICK(num v); external static num get JS$_POINTERTAP; external static set JS$_POINTERTAP(num v); external static num get JS$_POINTERDOUBLETAP; external static set JS$_POINTERDOUBLETAP(num v); external static num get POINTERDOWN; external static set POINTERDOWN(num v); external static num get POINTERUP; external static set POINTERUP(num v); external static num get POINTERMOVE; external static set POINTERMOVE(num v); external static num get POINTERWHEEL; external static set POINTERWHEEL(num v); external static num get POINTERPICK; external static set POINTERPICK(num v); external static num get POINTERTAP; external static set POINTERTAP(num v); external static num get POINTERDOUBLETAP; external static set POINTERDOUBLETAP(num v); }

 @JS("BABYLON.PointerInfoBase" ) class PointerInfoBase { // @Ignore
 PointerInfoBase .fakeConstructor$() ;
 external num get type; external set type(num v); external dynamic/*PointerEvent|MouseWheelEvent*/ get event; external set event(dynamic/*PointerEvent|MouseWheelEvent*/ v); external factory PointerInfoBase(num type, dynamic/*PointerEvent|MouseWheelEvent*/ event); }

 /// This class is used to store pointer related info for the onPrePointerObservable event.
 /// Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable
 @JS("BABYLON.PointerInfoPre" ) class PointerInfoPre extends PointerInfoBase { // @Ignore
 PointerInfoPre .fakeConstructor$() : super.fakeConstructor$() ;
 external factory PointerInfoPre(num type, dynamic/*PointerEvent|MouseWheelEvent*/ event, num localX, num localY); external Vector2 get localPosition; external set localPosition(Vector2 v); external bool get skipOnPointerObservable; external set skipOnPointerObservable(bool v); }

 /// This type contains all the data related to a pointer event in Babylon.js.
 /// The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.
 @JS("BABYLON.PointerInfo" ) class PointerInfo extends PointerInfoBase { // @Ignore
 PointerInfo .fakeConstructor$() : super.fakeConstructor$() ;
 external PickingInfo/*PickingInfo|Null*/ get pickInfo; external set pickInfo(PickingInfo/*PickingInfo|Null*/ v); external factory PointerInfo(num type, dynamic/*PointerEvent|MouseWheelEvent*/ event, PickingInfo/*PickingInfo|Null*/ pickInfo); }

 @JS("BABYLON.BoundingBox" ) class BoundingBox implements ICullable { // @Ignore
 BoundingBox .fakeConstructor$() ;
 external List<Vector3> get vectors; external set vectors(List<Vector3> v); external Vector3 get center; external set center(Vector3 v); external Vector3 get centerWorld; external set centerWorld(Vector3 v); external Vector3 get extendSize; external set extendSize(Vector3 v); external Vector3 get extendSizeWorld; external set extendSizeWorld(Vector3 v); external List<Vector3> get directions; external set directions(List<Vector3> v); external List<Vector3> get vectorsWorld; external set vectorsWorld(List<Vector3> v); external Vector3 get minimumWorld; external set minimumWorld(Vector3 v); external Vector3 get maximumWorld; external set maximumWorld(Vector3 v); external Vector3 get minimum; external set minimum(Vector3 v); external Vector3 get maximum; external set maximum(Vector3 v); external get JS$_worldMatrix; external set JS$_worldMatrix(v);
 /// Creates a new bounding box
 external factory BoundingBox(Vector3 min, Vector3 max);
 /// Recreates the entire bounding box from scratch
 external void reConstruct(Vector3 min, Vector3 max); external Matrix getWorldMatrix(); external BoundingBox setWorldMatrix(Matrix matrix); external void JS$_update(Matrix world); external bool isInFrustum(List<Plane> frustumPlanes); external bool isCompletelyInFrustum(List<Plane> frustumPlanes); external bool intersectsPoint(Vector3 point); external bool intersectsSphere(BoundingSphere sphere); external bool intersectsMinMax(Vector3 min, Vector3 max); external static bool Intersects(BoundingBox box0, BoundingBox box1); external static bool IntersectsSphere(Vector3 minPoint, Vector3 maxPoint, Vector3 sphereCenter, num sphereRadius); external static bool IsCompletelyInFrustum(List<Vector3> boundingVectors, List<Plane> frustumPlanes); external static bool IsInFrustum(List<Vector3> boundingVectors, List<Plane> frustumPlanes); }

 @anonymous @JS() abstract class ICullable { external bool isInFrustum(List<Plane> frustumPlanes); external bool isCompletelyInFrustum(List<Plane> frustumPlanes); }

 @JS("BABYLON.BoundingInfo" ) class BoundingInfo implements ICullable { // @Ignore
 BoundingInfo .fakeConstructor$() ;
 external Vector3 get minimum; external set minimum(Vector3 v); external Vector3 get maximum; external set maximum(Vector3 v); external BoundingBox get boundingBox; external set boundingBox(BoundingBox v); external BoundingSphere get boundingSphere; external set boundingSphere(BoundingSphere v); external get JS$_isLocked; external set JS$_isLocked(v); external factory BoundingInfo(Vector3 minimum, Vector3 maximum); external bool get isLocked; external set isLocked(bool v); external void update(Matrix world);
 /// Recreate the bounding info to be centered around a specific point given a specific extend.
 external BoundingInfo centerOn(Vector3 center, Vector3 extend); external bool isInFrustum(List<Plane> frustumPlanes);
 /// Gets the world distance between the min and max points of the bounding box
 external num get diagonalLength; external set diagonalLength(num v); external bool isCompletelyInFrustum(List<Plane> frustumPlanes); external bool JS$_checkCollision(Collider collider); external bool intersectsPoint(Vector3 point); external bool intersects(BoundingInfo boundingInfo, bool precise); }

 @JS("BABYLON.BoundingSphere" ) class BoundingSphere { // @Ignore
 BoundingSphere .fakeConstructor$() ;
 external Vector3 get center; external set center(Vector3 v); external num get radius; external set radius(num v); external Vector3 get centerWorld; external set centerWorld(Vector3 v); external num get radiusWorld; external set radiusWorld(num v); external Vector3 get minimum; external set minimum(Vector3 v); external Vector3 get maximum; external set maximum(Vector3 v); external get JS$_tempRadiusVector; external set JS$_tempRadiusVector(v);
 /// Creates a new bounding sphere
 external factory BoundingSphere(Vector3 min, Vector3 max);
 /// Recreates the entire bounding sphere from scratch
 external void reConstruct(Vector3 min, Vector3 max); external void JS$_update(Matrix world); external bool isInFrustum(List<Plane> frustumPlanes); external bool intersectsPoint(Vector3 point); external static bool Intersects(BoundingSphere sphere0, BoundingSphere sphere1); }

 @JS("BABYLON.Ray" ) class Ray { // @Ignore
 Ray .fakeConstructor$() ;
 external Vector3 get origin; external set origin(Vector3 v); external Vector3 get direction; external set direction(Vector3 v); external num get length; external set length(num v); external get JS$_edge1; external set JS$_edge1(v); external get JS$_edge2; external set JS$_edge2(v); external get JS$_pvec; external set JS$_pvec(v); external get JS$_tvec; external set JS$_tvec(v); external get JS$_qvec; external set JS$_qvec(v); external get JS$_tmpRay; external set JS$_tmpRay(v); external factory Ray(Vector3 origin, Vector3 direction, [num length]); external bool intersectsBoxMinMax(Vector3 minimum, Vector3 maximum); external bool intersectsBox(BoundingBox box); external bool intersectsSphere(BoundingSphere sphere); external IntersectionInfo/*IntersectionInfo|Null*/ intersectsTriangle(Vector3 vertex0, Vector3 vertex1, Vector3 vertex2); external num/*num|Null*/ intersectsPlane(Plane plane); external PickingInfo intersectsMesh(AbstractMesh mesh, [bool fastCheck]); external List<PickingInfo> intersectsMeshes(List<AbstractMesh> meshes, [bool fastCheck, List<PickingInfo> results]); external JS$_comparePickingInfo(pickingInfoA, pickingInfoB); external static get smallnum; external static set smallnum(v); external static get rayl; external static set rayl(v);
 /// Intersection test between the ray and a given segment whithin a given tolerance (threshold)
 external num intersectionSegment(Vector3 sega, Vector3 segb, num threshold); external Ray update(num x, num y, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection); external static Ray Zero(); external static Ray CreateNew(num x, num y, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection);
 /// Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
 /// transformed to the given world matrix.
 external static Ray CreateNewFromTo(Vector3 origin, Vector3 end, [Matrix world]); external static Ray Transform(Ray ray, Matrix matrix); external static void TransformToRef(Ray ray, Matrix matrix, Ray result); }

 @JS("BABYLON.StickValues" ) class StickValues { // @Ignore
 StickValues .fakeConstructor$() ;
 external num get x; external set x(num v); external num get y; external set y(num v); external factory StickValues(num x, num y); }

 @anonymous @JS() abstract class GamepadButtonChanges { external bool get changed; external set changed(bool v); external bool get pressChanged; external set pressChanged(bool v); external bool get touchChanged; external set touchChanged(bool v); external bool get valueChanged; external set valueChanged(bool v); external factory GamepadButtonChanges({ bool changed, bool pressChanged, bool touchChanged, bool valueChanged}); }

 @JS("BABYLON.Gamepad" ) class Gamepad { // @Ignore
 Gamepad .fakeConstructor$() ;
 external String get id; external set id(String v); external num get index; external set index(num v); external dynamic get browserGamepad; external set browserGamepad(dynamic v); external num get type; external set type(num v); external get JS$_leftStick; external set JS$_leftStick(v); external get JS$_rightStick; external set JS$_rightStick(v); external bool get JS$_isConnected; external set JS$_isConnected(bool v); external get JS$_leftStickAxisX; external set JS$_leftStickAxisX(v); external get JS$_leftStickAxisY; external set JS$_leftStickAxisY(v); external get JS$_rightStickAxisX; external set JS$_rightStickAxisX(v); external get JS$_rightStickAxisY; external set JS$_rightStickAxisY(v); external get JS$_onleftstickchanged; external set JS$_onleftstickchanged(v); external get JS$_onrightstickchanged; external set JS$_onrightstickchanged(v); external static num get GAMEPAD; external static set GAMEPAD(num v); external static num get GENERIC; external static set GENERIC(num v); external static num get XBOX; external static set XBOX(num v); external static num get POSE_ENABLED; external static set POSE_ENABLED(num v); external bool get JS$_invertLeftStickY; external set JS$_invertLeftStickY(bool v); external bool get isConnected; external set isConnected(bool v); external factory Gamepad(String id, num index, dynamic browserGamepad, [num leftStickX, num leftStickY, num rightStickX, num rightStickY]); external void onleftstickchanged(void callback(StickValues values)); external void onrightstickchanged(void callback(StickValues values)); external StickValues get leftStick; external set leftStick(StickValues v); external StickValues get rightStick; external set rightStick(StickValues v); external void update(); external void dispose(); }

 @JS("BABYLON.GenericPad" ) class GenericPad extends Gamepad { // @Ignore
 GenericPad .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_buttons; external set JS$_buttons(v); external get JS$_onbuttondown; external set JS$_onbuttondown(v); external get JS$_onbuttonup; external set JS$_onbuttonup(v); external Observable<num> get onButtonDownObservable; external set onButtonDownObservable(Observable<num> v); external Observable<num> get onButtonUpObservable; external set onButtonUpObservable(Observable<num> v); external void onbuttondown(void callback(num buttonPressed)); external void onbuttonup(void callback(num buttonReleased)); external factory GenericPad(String id, num index, dynamic browserGamepad); external JS$_setButtonValue(newValue, currentValue, buttonIndex); external void update(); external void dispose(); }

 @JS("BABYLON.GamepadManager" ) class GamepadManager { // @Ignore
 GamepadManager .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_babylonGamepads; external set JS$_babylonGamepads(v); external get JS$_oneGamepadConnected; external set JS$_oneGamepadConnected(v); external bool get JS$_isMonitoring; external set JS$_isMonitoring(bool v); external get JS$_gamepadEventSupported; external set JS$_gamepadEventSupported(v); external get JS$_gamepadSupport; external set JS$_gamepadSupport(v); external Observable<Gamepad> get onGamepadConnectedObservable; external set onGamepadConnectedObservable(Observable<Gamepad> v); external Observable<Gamepad> get onGamepadDisconnectedObservable; external set onGamepadDisconnectedObservable(Observable<Gamepad> v); external get JS$_onGamepadConnectedEvent; external set JS$_onGamepadConnectedEvent(v); external get JS$_onGamepadDisconnectedEvent; external set JS$_onGamepadDisconnectedEvent(v); external factory GamepadManager([dynamic/*Scene|dynamic*/ JS$_scene]); external List<Gamepad> get gamepads; external set gamepads(List<Gamepad> v); external Gamepad/*Gamepad|Null*/ getGamepadByType([num type]); external void dispose(); external JS$_addNewGamepad(gamepad); external JS$_startMonitoringGamepads(); external JS$_stopMonitoringGamepads(); external void JS$_checkGamepadsStatus(); external JS$_updateGamepadObjects(); }

 /// Defines supported buttons for XBox360 compatible gamepads
 @JS("BABYLON.Xbox360Button" ) class Xbox360Button { external static num get
 /// A
 A; external static num get
 /// B
 B; external static num get
 /// X
 X; external static num get
 /// Y
 Y; external static num get
 /// Start
 Start; external static num get
 /// Back
 Back; external static num get
 /// Left button
 LB; external static num get
 /// Right button
 RB; external static num get
 /// Left stick
 LeftStick; external static num get
 /// Right stick
 RightStick; }
 /// Defines values for XBox360 DPad
 @JS("BABYLON.Xbox360Dpad" ) class Xbox360Dpad { external static num get
 /// Up
 Up; external static num get
 /// Down
 Down; external static num get
 /// Left
 Left; external static num get
 /// Right
 Right; }
 /// Defines a XBox360 gamepad
 @JS("BABYLON.Xbox360Pad" ) class Xbox360Pad extends Gamepad { // @Ignore
 Xbox360Pad .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_leftTrigger; external set JS$_leftTrigger(v); external get JS$_rightTrigger; external set JS$_rightTrigger(v); external get JS$_onlefttriggerchanged; external set JS$_onlefttriggerchanged(v); external get JS$_onrighttriggerchanged; external set JS$_onrighttriggerchanged(v); external get JS$_onbuttondown; external set JS$_onbuttondown(v); external get JS$_onbuttonup; external set JS$_onbuttonup(v); external get JS$_ondpaddown; external set JS$_ondpaddown(v); external get JS$_ondpadup; external set JS$_ondpadup(v);
 /// Observable raised when a button is pressed
 external Observable<num/*enum Xbox360Button*/> get onButtonDownObservable; external set onButtonDownObservable(Observable<num/*enum Xbox360Button*/> v);
 /// Observable raised when a button is released
 external Observable<num/*enum Xbox360Button*/> get onButtonUpObservable; external set onButtonUpObservable(Observable<num/*enum Xbox360Button*/> v);
 /// Observable raised when a pad is pressed
 external Observable<num/*enum Xbox360Dpad*/> get onPadDownObservable; external set onPadDownObservable(Observable<num/*enum Xbox360Dpad*/> v);
 /// Observable raised when a pad is released
 external Observable<num/*enum Xbox360Dpad*/> get onPadUpObservable; external set onPadUpObservable(Observable<num/*enum Xbox360Dpad*/> v); external get JS$_buttonA; external set JS$_buttonA(v); external get JS$_buttonB; external set JS$_buttonB(v); external get JS$_buttonX; external set JS$_buttonX(v); external get JS$_buttonY; external set JS$_buttonY(v); external get JS$_buttonBack; external set JS$_buttonBack(v); external get JS$_buttonStart; external set JS$_buttonStart(v); external get JS$_buttonLB; external set JS$_buttonLB(v); external get JS$_buttonRB; external set JS$_buttonRB(v); external get JS$_buttonLeftStick; external set JS$_buttonLeftStick(v); external get JS$_buttonRightStick; external set JS$_buttonRightStick(v); external get JS$_dPadUp; external set JS$_dPadUp(v); external get JS$_dPadDown; external set JS$_dPadDown(v); external get JS$_dPadLeft; external set JS$_dPadLeft(v); external get JS$_dPadRight; external set JS$_dPadRight(v); external get JS$_isXboxOnePad; external set JS$_isXboxOnePad(v);
 /// Creates a new XBox360 gamepad object
 external factory Xbox360Pad(String id, num index, dynamic gamepad, [bool xboxOne]);
 /// Defines the callback to call when left trigger is pressed
 external void onlefttriggerchanged(void callback(num value));
 /// Defines the callback to call when right trigger is pressed
 external void onrighttriggerchanged(void callback(num value));
 /// Gets or sets left trigger value
 external num get leftTrigger; external set leftTrigger(num v);
 /// Gets or sets right trigger value
 external num get rightTrigger; external set rightTrigger(num v);
 /// Defines the callback to call when a button is pressed
 external void onbuttondown(void callback(num/*enum Xbox360Button*/ buttonPressed));
 /// Defines the callback to call when a button is released
 external void onbuttonup(void callback(num/*enum Xbox360Button*/ buttonReleased));
 /// Defines the callback to call when a pad is pressed
 external void ondpaddown(void callback(num/*enum Xbox360Dpad*/ dPadPressed));
 /// Defines the callback to call when a pad is released
 external void ondpadup(void callback(num/*enum Xbox360Dpad*/ dPadReleased)); external JS$_setButtonValue(newValue, currentValue, buttonType); external JS$_setDPadValue(newValue, currentValue, buttonType);
 /// Gets or sets value of A button
 external num get buttonA; external set buttonA(num v);
 /// Gets or sets value of B button
 external num get buttonB; external set buttonB(num v);
 /// Gets or sets value of X button
 external num get buttonX; external set buttonX(num v);
 /// Gets or sets value of Y button
 external num get buttonY; external set buttonY(num v);
 /// Gets or sets value of Start button
 external num get buttonStart; external set buttonStart(num v);
 /// Gets or sets value of Back button
 external num get buttonBack; external set buttonBack(num v);
 /// Gets or sets value of Left button
 external num get buttonLB; external set buttonLB(num v);
 /// Gets or sets value of Right button
 external num get buttonRB; external set buttonRB(num v);
 /// Gets or sets value of left stick
 external num get buttonLeftStick; external set buttonLeftStick(num v);
 /// Gets or sets value of right stick
 external num get buttonRightStick; external set buttonRightStick(num v);
 /// Gets or sets value of DPad up
 external num get dPadUp; external set dPadUp(num v);
 /// Gets or sets value of DPad down
 external num get dPadDown; external set dPadDown(num v);
 /// Gets or sets value of DPad left
 external num get dPadLeft; external set dPadLeft(num v);
 /// Gets or sets value of DPad right
 external num get dPadRight; external set dPadRight(num v);
 /// Force the gamepad to synchronize with device values
 external void update(); external void dispose(); }

 /// Represents the different options available during the creation of
 /// a Environment helper.
 /// This can control the default ground, skybox and image processing setup of your scene.
 @anonymous @JS() abstract class IEnvironmentHelperOptions {
 /// Specifies wether or not to create a ground.
 /// True by default.
 external bool get createGround; external set createGround(bool v);
 /// Specifies the ground size.
 /// 15 by default.
 external num get groundSize; external set groundSize(num v);
 /// The texture used on the ground for the main color.
 /// Comes from the BabylonJS CDN by default.
 /// Remarks: Can be either a texture or a url.
 external dynamic/*String|BaseTexture*/ get groundTexture; external set groundTexture(dynamic/*String|BaseTexture*/ v);
 /// The color mixed in the ground texture by default.
 /// BabylonJS clearColor by default.
 external Color3 get groundColor; external set groundColor(Color3 v);
 /// Specifies the ground opacity.
 /// 1 by default.
 external num get groundOpacity; external set groundOpacity(num v);
 /// Enables the ground to receive shadows.
 /// True by default.
 external bool get enableGroundShadow; external set enableGroundShadow(bool v);
 /// Helps preventing the shadow to be fully black on the ground.
 /// 0.5 by default.
 external num get groundShadowLevel; external set groundShadowLevel(num v);
 /// Creates a mirror texture attach to the ground.
 /// false by default.
 external bool get enableGroundMirror; external set enableGroundMirror(bool v);
 /// Specifies the ground mirror size ratio.
 /// 0.3 by default as the default kernel is 64.
 external num get groundMirrorSizeRatio; external set groundMirrorSizeRatio(num v);
 /// Specifies the ground mirror blur kernel size.
 /// 64 by default.
 external num get groundMirrorBlurKernel; external set groundMirrorBlurKernel(num v);
 /// Specifies the ground mirror visibility amount.
 /// 1 by default
 external num get groundMirrorAmount; external set groundMirrorAmount(num v);
 /// Specifies the ground mirror reflectance weight.
 /// This uses the standard weight of the background material to setup the fresnel effect
 /// of the mirror.
 /// 1 by default.
 external num get groundMirrorFresnelWeight; external set groundMirrorFresnelWeight(num v);
 /// Specifies the ground mirror Falloff distance.
 /// This can helps reducing the size of the reflection.
 /// 0 by Default.
 external num get groundMirrorFallOffDistance; external set groundMirrorFallOffDistance(num v);
 /// Specifies the ground mirror texture type.
 /// Unsigned Int by Default.
 external num get groundMirrorTextureType; external set groundMirrorTextureType(num v);
 /// Specifies a bias applied to the ground vertical position to prevent z-fighyting with
 /// the shown objects.
 external num get groundYBias; external set groundYBias(num v);
 /// Specifies wether or not to create a skybox.
 /// True by default.
 external bool get createSkybox; external set createSkybox(bool v);
 /// Specifies the skybox size.
 /// 20 by default.
 external num get skyboxSize; external set skyboxSize(num v);
 /// The texture used on the skybox for the main color.
 /// Comes from the BabylonJS CDN by default.
 /// Remarks: Can be either a texture or a url.
 external dynamic/*String|BaseTexture*/ get skyboxTexture; external set skyboxTexture(dynamic/*String|BaseTexture*/ v);
 /// The color mixed in the skybox texture by default.
 /// BabylonJS clearColor by default.
 external Color3 get skyboxColor; external set skyboxColor(Color3 v);
 /// The background rotation around the Y axis of the scene.
 /// This helps aligning the key lights of your scene with the background.
 /// 0 by default.
 external num get backgroundYRotation; external set backgroundYRotation(num v);
 /// Compute automatically the size of the elements to best fit with the scene.
 external bool get sizeAuto; external set sizeAuto(bool v);
 /// Default position of the rootMesh if autoSize is not true.
 external Vector3 get rootPosition; external set rootPosition(Vector3 v);
 /// Sets up the image processing in the scene.
 /// true by default.
 external bool get setupImageProcessing; external set setupImageProcessing(bool v);
 /// The texture used as your environment texture in the scene.
 /// Comes from the BabylonJS CDN by default and in use if setupImageProcessing is true.
 /// Remarks: Can be either a texture or a url.
 external dynamic/*String|BaseTexture*/ get environmentTexture; external set environmentTexture(dynamic/*String|BaseTexture*/ v);
 /// The value of the exposure to apply to the scene.
 /// 0.6 by default if setupImageProcessing is true.
 external num get cameraExposure; external set cameraExposure(num v);
 /// The value of the contrast to apply to the scene.
 /// 1.6 by default if setupImageProcessing is true.
 external num get cameraContrast; external set cameraContrast(num v);
 /// Specifies wether or not tonemapping should be enabled in the scene.
 /// true by default if setupImageProcessing is true.
 external bool get toneMappingEnabled; external set toneMappingEnabled(bool v); external factory IEnvironmentHelperOptions({ bool createGround, num groundSize, dynamic/*String|BaseTexture*/ groundTexture, Color3 groundColor, num groundOpacity, bool enableGroundShadow, num groundShadowLevel, bool enableGroundMirror, num groundMirrorSizeRatio, num groundMirrorBlurKernel, num groundMirrorAmount, num groundMirrorFresnelWeight, num groundMirrorFallOffDistance, num groundMirrorTextureType, num groundYBias, bool createSkybox, num skyboxSize, dynamic/*String|BaseTexture*/ skyboxTexture, Color3 skyboxColor, num backgroundYRotation, bool sizeAuto, Vector3 rootPosition, bool setupImageProcessing, dynamic/*String|BaseTexture*/ environmentTexture, num cameraExposure, num cameraContrast, bool toneMappingEnabled}); }

 /// The Environment helper class can be used to add a fully featuread none expensive background to your scene.
 /// It includes by default a skybox and a ground relying on the BackgroundMaterial.
 /// It also helps with the default setup of your imageProcessing configuration.
 @JS("BABYLON.EnvironmentHelper" ) class EnvironmentHelper { // @Ignore
 EnvironmentHelper .fakeConstructor$() ;
 /// Default ground texture URL.
 external static get JS$_groundTextureCDNUrl; external static set JS$_groundTextureCDNUrl(v);
 /// Default skybox texture URL.
 external static get JS$_skyboxTextureCDNUrl; external static set JS$_skyboxTextureCDNUrl(v);
 /// Default environment texture URL.
 external static get JS$_environmentTextureCDNUrl; external static set JS$_environmentTextureCDNUrl(v);
 /// Creates the default options for the helper.
 external static JS$_getDefaultOptions(); external get JS$_rootMesh; external set JS$_rootMesh(v);
 /// Gets the root mesh created by the helper.
 external Mesh get rootMesh; external set rootMesh(Mesh v); external get JS$_skybox; external set JS$_skybox(v);
 /// Gets the skybox created by the helper.
 external Mesh/*Mesh|Null*/ get skybox; external set skybox(Mesh/*Mesh|Null*/ v); external get JS$_skyboxTexture; external set JS$_skyboxTexture(v);
 /// Gets the skybox texture created by the helper.
 external BaseTexture/*BaseTexture|Null*/ get skyboxTexture; external set skyboxTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_skyboxMaterial; external set JS$_skyboxMaterial(v);
 /// Gets the skybox material created by the helper.
 external BackgroundMaterial/*BackgroundMaterial|Null*/ get skyboxMaterial; external set skyboxMaterial(BackgroundMaterial/*BackgroundMaterial|Null*/ v); external get JS$_ground; external set JS$_ground(v);
 /// Gets the ground mesh created by the helper.
 external Mesh/*Mesh|Null*/ get ground; external set ground(Mesh/*Mesh|Null*/ v); external get JS$_groundTexture; external set JS$_groundTexture(v);
 /// Gets the ground texture created by the helper.
 external BaseTexture/*BaseTexture|Null*/ get groundTexture; external set groundTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_groundMirror; external set JS$_groundMirror(v);
 /// Gets the ground mirror created by the helper.
 external MirrorTexture/*MirrorTexture|Null*/ get groundMirror; external set groundMirror(MirrorTexture/*MirrorTexture|Null*/ v);
 /// Gets the ground mirror render list to helps pushing the meshes
 /// you wish in the ground reflection.
 external List<AbstractMesh>/*List<AbstractMesh>|Null*/ get groundMirrorRenderList; external set groundMirrorRenderList(List<AbstractMesh>/*List<AbstractMesh>|Null*/ v); external get JS$_groundMaterial; external set JS$_groundMaterial(v);
 /// Gets the ground material created by the helper.
 external BackgroundMaterial/*BackgroundMaterial|Null*/ get groundMaterial; external set groundMaterial(BackgroundMaterial/*BackgroundMaterial|Null*/ v);
 /// Stores the creation options.
 external get JS$_scene; external set JS$_scene(v); external get JS$_options; external set JS$_options(v);
 /// This observable will be notified with any error during the creation of the environment,
 /// mainly texture creation errors.
 external Observable<dynamic/*{
            message?: string;
            exception?: any;
        }*/> get onErrorObservable; external set onErrorObservable(Observable<dynamic/*{
            message?: string;
            exception?: any;
        }*/> v);
 /// constructor
 external factory EnvironmentHelper(Partial<IEnvironmentHelperOptions> options, Scene scene);
 /// Updates the background according to the new options
 external void updateOptions(Partial<IEnvironmentHelperOptions> options);
 /// Sets the primary color of all the available elements.
 external void setMainColor(Color3 color);
 /// Setup the image processing according to the specified options.
 external JS$_setupImageProcessing();
 /// Setup the environment texture according to the specified options.
 external JS$_setupEnvironmentTexture();
 /// Setup the background according to the specified options.
 external JS$_setupBackground();
 /// Get the scene sizes according to the setup.
 external JS$_getSceneSize();
 /// Setup the ground according to the specified options.
 external JS$_setupGround(sceneSize);
 /// Setup the ground material according to the specified options.
 external JS$_setupGroundMaterial();
 /// Setup the ground diffuse texture according to the specified options.
 external JS$_setupGroundDiffuseTexture();
 /// Setup the ground mirror texture according to the specified options.
 external JS$_setupGroundMirrorTexture(sceneSize);
 /// Setup the ground to receive the mirror texture.
 external JS$_setupMirrorInGroundMaterial();
 /// Setup the skybox according to the specified options.
 external JS$_setupSkybox(sceneSize);
 /// Setup the skybox material according to the specified options.
 external JS$_setupSkyboxMaterial();
 /// Setup the skybox reflection texture according to the specified options.
 external JS$_setupSkyboxReflectionTexture(); external get JS$_errorHandler; external set JS$_errorHandler(v);
 /// Dispose all the elements created by the Helper.
 external void dispose(); }

 /// Display a 360 degree video on an approximately spherical surface, useful for VR applications or skyboxes.
 /// As a subclass of Node, this allow parenting to the camera or multiple videos with different locations in the scene.
 /// This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.
 /// Potential additions to this helper include zoom and and non-infinite distance rendering effects.
 @JS("BABYLON.VideoDome" ) class VideoDome extends Node { // @Ignore
 VideoDome .fakeConstructor$() : super.fakeConstructor$() ;
 /// The video texture being displayed on the sphere
 external VideoTexture get JS$_videoTexture; external set JS$_videoTexture(VideoTexture v);
 /// The skybox material
 external BackgroundMaterial get JS$_material; external set JS$_material(BackgroundMaterial v);
 /// The surface used for the skybox
 external Mesh get JS$_mesh; external set JS$_mesh(Mesh v);
 /// The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
 /// Also see the options.resolution property.
 external num get fovMultiplier; external set fovMultiplier(num v);
 /// Create an instance of this class and pass through the parameters to the relevant classes, VideoTexture, StandardMaterial, and Mesh.
 external factory VideoDome(String name, dynamic/*String|List<String>|VideoElement*/ urlsOrVideo, dynamic/*{
            resolution?: number;
            clickToPlay?: boolean;
            autoPlay?: boolean;
            loop?: boolean;
            size?: number;
        }*/ options, Scene scene);
 /// Releases resources associated with this node.
 external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]); }

 /// This class can be used to get instrumentation data from a Babylon engine
 @JS("BABYLON.EngineInstrumentation" ) class EngineInstrumentation implements IDisposable { // @Ignore
 EngineInstrumentation .fakeConstructor$() ;
 external Engine get engine; external set engine(Engine v); external get JS$_captureGPUFrameTime; external set JS$_captureGPUFrameTime(v); external get JS$_gpuFrameTimeToken; external set JS$_gpuFrameTimeToken(v); external get JS$_gpuFrameTime; external set JS$_gpuFrameTime(v); external get JS$_captureShaderCompilationTime; external set JS$_captureShaderCompilationTime(v); external get JS$_shaderCompilationTime; external set JS$_shaderCompilationTime(v); external get JS$_onBeginFrameObserver; external set JS$_onBeginFrameObserver(v); external get JS$_onEndFrameObserver; external set JS$_onEndFrameObserver(v); external get JS$_onBeforeShaderCompilationObserver; external set JS$_onBeforeShaderCompilationObserver(v); external get JS$_onAfterShaderCompilationObserver; external set JS$_onAfterShaderCompilationObserver(v);
 /// Gets the perf counter used for GPU frame time
 external PerfCounter get gpuFrameTimeCounter; external set gpuFrameTimeCounter(PerfCounter v);
 /// Gets the GPU frame time capture status
 /// Enable or disable the GPU frame time capture
 external bool get captureGPUFrameTime; external set captureGPUFrameTime(bool v);
 /// Gets the perf counter used for shader compilation time
 external PerfCounter get shaderCompilationTimeCounter; external set shaderCompilationTimeCounter(PerfCounter v);
 /// Gets the shader compilation time capture status
 /// Enable or disable the shader compilation time capture
 external bool get captureShaderCompilationTime; external set captureShaderCompilationTime(bool v); external factory EngineInstrumentation(Engine engine); external void dispose(); }

 /// This class can be used to get instrumentation data from a Babylon engine
 @JS("BABYLON.SceneInstrumentation" ) class SceneInstrumentation implements IDisposable { // @Ignore
 SceneInstrumentation .fakeConstructor$() ;
 external Scene get scene; external set scene(Scene v); external get JS$_captureActiveMeshesEvaluationTime; external set JS$_captureActiveMeshesEvaluationTime(v); external get JS$_activeMeshesEvaluationTime; external set JS$_activeMeshesEvaluationTime(v); external get JS$_captureRenderTargetsRenderTime; external set JS$_captureRenderTargetsRenderTime(v); external get JS$_renderTargetsRenderTime; external set JS$_renderTargetsRenderTime(v); external get JS$_captureFrameTime; external set JS$_captureFrameTime(v); external get JS$_frameTime; external set JS$_frameTime(v); external get JS$_captureRenderTime; external set JS$_captureRenderTime(v); external get JS$_renderTime; external set JS$_renderTime(v); external get JS$_captureInterFrameTime; external set JS$_captureInterFrameTime(v); external get JS$_interFrameTime; external set JS$_interFrameTime(v); external get JS$_captureParticlesRenderTime; external set JS$_captureParticlesRenderTime(v); external get JS$_particlesRenderTime; external set JS$_particlesRenderTime(v); external get JS$_captureSpritesRenderTime; external set JS$_captureSpritesRenderTime(v); external get JS$_spritesRenderTime; external set JS$_spritesRenderTime(v); external get JS$_capturePhysicsTime; external set JS$_capturePhysicsTime(v); external get JS$_physicsTime; external set JS$_physicsTime(v); external get JS$_captureAnimationsTime; external set JS$_captureAnimationsTime(v); external get JS$_animationsTime; external set JS$_animationsTime(v); external get JS$_onBeforeActiveMeshesEvaluationObserver; external set JS$_onBeforeActiveMeshesEvaluationObserver(v); external get JS$_onAfterActiveMeshesEvaluationObserver; external set JS$_onAfterActiveMeshesEvaluationObserver(v); external get JS$_onBeforeRenderTargetsRenderObserver; external set JS$_onBeforeRenderTargetsRenderObserver(v); external get JS$_onAfterRenderTargetsRenderObserver; external set JS$_onAfterRenderTargetsRenderObserver(v); external get JS$_onAfterRenderObserver; external set JS$_onAfterRenderObserver(v); external get JS$_onBeforeDrawPhaseObserver; external set JS$_onBeforeDrawPhaseObserver(v); external get JS$_onAfterDrawPhaseObserver; external set JS$_onAfterDrawPhaseObserver(v); external get JS$_onBeforeAnimationsObserver; external set JS$_onBeforeAnimationsObserver(v); external get JS$_onBeforeParticlesRenderingObserver; external set JS$_onBeforeParticlesRenderingObserver(v); external get JS$_onAfterParticlesRenderingObserver; external set JS$_onAfterParticlesRenderingObserver(v); external get JS$_onBeforeSpritesRenderingObserver; external set JS$_onBeforeSpritesRenderingObserver(v); external get JS$_onAfterSpritesRenderingObserver; external set JS$_onAfterSpritesRenderingObserver(v); external get JS$_onBeforePhysicsObserver; external set JS$_onBeforePhysicsObserver(v); external get JS$_onAfterPhysicsObserver; external set JS$_onAfterPhysicsObserver(v); external get JS$_onAfterAnimationsObserver; external set JS$_onAfterAnimationsObserver(v);
 /// Gets the perf counter used for active meshes evaluation time
 external PerfCounter get activeMeshesEvaluationTimeCounter; external set activeMeshesEvaluationTimeCounter(PerfCounter v);
 /// Gets the active meshes evaluation time capture status
 /// Enable or disable the active meshes evaluation time capture
 external bool get captureActiveMeshesEvaluationTime; external set captureActiveMeshesEvaluationTime(bool v);
 /// Gets the perf counter used for render targets render time
 external PerfCounter get renderTargetsRenderTimeCounter; external set renderTargetsRenderTimeCounter(PerfCounter v);
 /// Gets the render targets render time capture status
 /// Enable or disable the render targets render time capture
 external bool get captureRenderTargetsRenderTime; external set captureRenderTargetsRenderTime(bool v);
 /// Gets the perf counter used for particles render time
 external PerfCounter get particlesRenderTimeCounter; external set particlesRenderTimeCounter(PerfCounter v);
 /// Gets the particles render time capture status
 /// Enable or disable the particles render time capture
 external bool get captureParticlesRenderTime; external set captureParticlesRenderTime(bool v);
 /// Gets the perf counter used for sprites render time
 external PerfCounter get spritesRenderTimeCounter; external set spritesRenderTimeCounter(PerfCounter v);
 /// Gets the sprites render time capture status
 /// Enable or disable the sprites render time capture
 external bool get captureSpritesRenderTime; external set captureSpritesRenderTime(bool v);
 /// Gets the perf counter used for physics time
 external PerfCounter get physicsTimeCounter; external set physicsTimeCounter(PerfCounter v);
 /// Gets the physics time capture status
 /// Enable or disable the physics time capture
 external bool get capturePhysicsTime; external set capturePhysicsTime(bool v);
 /// Gets the perf counter used for animations time
 external PerfCounter get animationsTimeCounter; external set animationsTimeCounter(PerfCounter v);
 /// Gets the animations time capture status
 /// Enable or disable the animations time capture
 external bool get captureAnimationsTime; external set captureAnimationsTime(bool v);
 /// Gets the perf counter used for frame time capture
 external PerfCounter get frameTimeCounter; external set frameTimeCounter(PerfCounter v);
 /// Gets the frame time capture status
 /// Enable or disable the frame time capture
 external bool get captureFrameTime; external set captureFrameTime(bool v);
 /// Gets the perf counter used for inter-frames time capture
 external PerfCounter get interFrameTimeCounter; external set interFrameTimeCounter(PerfCounter v);
 /// Gets the inter-frames time capture status
 /// Enable or disable the inter-frames time capture
 external bool get captureInterFrameTime; external set captureInterFrameTime(bool v);
 /// Gets the perf counter used for render time capture
 external PerfCounter get renderTimeCounter; external set renderTimeCounter(PerfCounter v);
 /// Gets the render time capture status
 /// Enable or disable the render time capture
 external bool get captureRenderTime; external set captureRenderTime(bool v);
 /// Gets the perf counter used for draw calls
 external PerfCounter get drawCallsCounter; external set drawCallsCounter(PerfCounter v);
 /// Gets the perf counter used for texture collisions
 external PerfCounter get textureCollisionsCounter; external set textureCollisionsCounter(PerfCounter v); external factory SceneInstrumentation(Scene scene); external void dispose(); }

 /// @hidden
 @JS("BABYLON._TimeToken" ) class JS$_TimeToken { // @Ignore
 JS$_TimeToken .fakeConstructor$() ;
 external WebGLQuery/*WebGLQuery|Null*/ get JS$_startTimeQuery; external set JS$_startTimeQuery(WebGLQuery/*WebGLQuery|Null*/ v); external WebGLQuery/*WebGLQuery|Null*/ get JS$_endTimeQuery; external set JS$_endTimeQuery(WebGLQuery/*WebGLQuery|Null*/ v); external WebGLQuery/*WebGLQuery|Null*/ get JS$_timeElapsedQuery; external set JS$_timeElapsedQuery(WebGLQuery/*WebGLQuery|Null*/ v); external bool get JS$_timeElapsedQueryEnded; external set JS$_timeElapsedQueryEnded(bool v); }

 /// Effect layer options. This helps customizing the behaviour
 /// of the effect layer.
 @anonymous @JS() abstract class IEffectLayerOptions {
 /// Multiplication factor apply to the canvas size to compute the render target size
 /// used to generated the objects (the smaller the faster).
 external num get mainTextureRatio; external set mainTextureRatio(num v);
 /// Enforces a fixed size texture to ensure effect stability across devices.
 external num get mainTextureFixedSize; external set mainTextureFixedSize(num v);
 /// Alpha blending mode used to apply the blur. Default depends of the implementation.
 external num get alphaBlendingMode; external set alphaBlendingMode(num v);
 /// The camera attached to the layer.
 external Camera/*Camera|Null*/ get camera; external set camera(Camera/*Camera|Null*/ v); external factory IEffectLayerOptions({ num mainTextureRatio, num mainTextureFixedSize, num alphaBlendingMode, Camera/*Camera|Null*/ camera}); }

 /// The effect layer Helps adding post process effect blended with the main pass.
 /// This can be for instance use to generate glow or higlight effects on the scene.
 /// The effect layer class can not be used directly and is intented to inherited from to be
 /// customized per effects.
 @JS("BABYLON.EffectLayer" ) abstract class EffectLayer { // @Ignore
 EffectLayer .fakeConstructor$() ;
 external get JS$_vertexBuffers; external set JS$_vertexBuffers(v); external get JS$_indexBuffer; external set JS$_indexBuffer(v); external get JS$_cachedDefines; external set JS$_cachedDefines(v); external get JS$_effectLayerMapGenerationEffect; external set JS$_effectLayerMapGenerationEffect(v); external get JS$_effectLayerOptions; external set JS$_effectLayerOptions(v); external get JS$_mergeEffect; external set JS$_mergeEffect(v); external Scene get JS$_scene; external set JS$_scene(Scene v); external Engine get JS$_engine; external set JS$_engine(Engine v); external num get JS$_maxSize; external set JS$_maxSize(num v); external ISize get JS$_mainTextureDesiredSize; external set JS$_mainTextureDesiredSize(ISize v); external RenderTargetTexture get JS$_mainTexture; external set JS$_mainTexture(RenderTargetTexture v); external bool get JS$_shouldRender; external set JS$_shouldRender(bool v); external List<PostProcess> get JS$_postProcesses; external set JS$_postProcesses(List<PostProcess> v); external List<BaseTexture> get JS$_textures; external set JS$_textures(List<BaseTexture> v); external dynamic/*{
            texture: Nullable<BaseTexture>;
            color: Color4;
        }*/ get JS$_emissiveTextureAndColor; external set JS$_emissiveTextureAndColor(dynamic/*{
            texture: Nullable<BaseTexture>;
            color: Color4;
        }*/ v);
 /// The name of the layer
 external String get name; external set name(String v);
 /// The clear color of the texture used to generate the glow map.
 external Color4 get neutralColor; external set neutralColor(Color4 v);
 /// Specifies wether the highlight layer is enabled or not.
 external bool get isEnabled; external set isEnabled(bool v);
 /// Gets the camera attached to the layer.
 external Camera/*Camera|Null*/ get camera; external set camera(Camera/*Camera|Null*/ v);
 /// An event triggered when the effect layer has been disposed.
 external Observable<EffectLayer> get onDisposeObservable; external set onDisposeObservable(Observable<EffectLayer> v);
 /// An event triggered when the effect layer is about rendering the main texture with the glowy parts.
 external Observable<EffectLayer> get onBeforeRenderMainTextureObservable; external set onBeforeRenderMainTextureObservable(Observable<EffectLayer> v);
 /// An event triggered when the generated texture is being merged in the scene.
 external Observable<EffectLayer> get onBeforeComposeObservable; external set onBeforeComposeObservable(Observable<EffectLayer> v);
 /// An event triggered when the generated texture has been merged in the scene.
 external Observable<EffectLayer> get onAfterComposeObservable; external set onAfterComposeObservable(Observable<EffectLayer> v);
 /// An event triggered when the efffect layer changes its size.
 external Observable<EffectLayer> get onSizeChangedObservable; external set onSizeChangedObservable(Observable<EffectLayer> v);
 /// Instantiates a new effect Layer and references it in the scene.
 external factory EffectLayer(
 /// The Friendly of the effect in the scene
 String name, Scene scene);
 /// Get the effect name of the layer.
 external String getEffectName();
 /// Checks for the readiness of the element composing the layer.
 external bool isReady(SubMesh subMesh, bool useInstances);
 /// Returns wether or nood the layer needs stencil enabled during the mesh rendering.
 external bool needStencil();
 /// Create the merge effect. This is the shader use to blit the information back
 /// to the main canvas at the end of the scene rendering.
 external Effect JS$_createMergeEffect();
 /// Creates the render target textures and post processes used in the effect layer.
 external void JS$_createTextureAndPostProcesses();
 /// Implementation specific of rendering the generating effect on the main canvas.
 external void JS$_internalRender(Effect effect);
 /// Sets the required values for both the emissive texture and and the main color.
 external void JS$_setEmissiveTextureAndColor(Mesh mesh, SubMesh subMesh, Material material);
 /// Free any resources and references associated to a mesh.
 /// Internal use
 external void JS$_disposeMesh(Mesh mesh);
 /// Serializes this layer (Glow or Highlight for example)
 external dynamic serialize();
 /// Initializes the effect layer with the required options.
 external void JS$_init(Partial<IEffectLayerOptions> options);
 /// Generates the index buffer of the full screen quad blending to the main canvas.
 external JS$_generateIndexBuffer();
 /// Generates the vertex buffer of the full screen quad blending to the main canvas.
 external JS$_genrateVertexBuffer();
 /// Sets the main texture desired size which is the closest power of two
 /// of the engine canvas size.
 external JS$_setMainTextureSize();
 /// Creates the main texture for the effect layer.
 external void JS$_createMainTexture();
 /// Checks for the readiness of the element composing the layer.
 external bool JS$_isReady(SubMesh subMesh, bool useInstances, BaseTexture/*BaseTexture|Null*/ emissiveTexture);
 /// Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.
 external void render();
 /// Determine if a given mesh will be used in the current effect.
 external bool hasMesh(AbstractMesh mesh);
 /// Returns true if the layer contains information to display, otherwise false.
 external bool shouldRender();
 /// Returns true if the mesh should render, otherwise false.
 external bool JS$_shouldRenderMesh(Mesh mesh);
 /// Returns true if the mesh should render, otherwise false.
 external bool JS$_shouldRenderEmissiveTextureForMesh(Mesh mesh);
 /// Renders the submesh passed in parameter to the generation map.
 external void JS$_renderSubMesh(SubMesh subMesh);
 /// Rebuild the required buffers.
 /// @hidden Internal use only.
 external void JS$_rebuild();
 /// Dispose only the render target textures and post process.
 external JS$_disposeTextureAndPostProcesses();
 /// Dispose the highlight layer and free resources.
 external void dispose();
 /// Gets the class name of the effect layer
 external String getClassName();
 /// Creates an effect layer from parsed effect layer data
 external static EffectLayer Parse(dynamic parsedEffectLayer, Scene scene, String rootUrl); }

 /// Glow layer options. This helps customizing the behaviour
 /// of the glow layer.
 @anonymous @JS() abstract class IGlowLayerOptions {
 /// Multiplication factor apply to the canvas size to compute the render target size
 /// used to generated the glowing objects (the smaller the faster).
 external num get mainTextureRatio; external set mainTextureRatio(num v);
 /// Enforces a fixed size texture to ensure resize independant blur.
 external num get mainTextureFixedSize; external set mainTextureFixedSize(num v);
 /// How big is the kernel of the blur texture.
 external num get blurKernelSize; external set blurKernelSize(num v);
 /// The camera attached to the layer.
 external Camera/*Camera|Null*/ get camera; external set camera(Camera/*Camera|Null*/ v);
 /// Enable MSAA by chosing the number of samples.
 external num get mainTextureSamples; external set mainTextureSamples(num v); external factory IGlowLayerOptions({ num mainTextureRatio, num mainTextureFixedSize, num blurKernelSize, Camera/*Camera|Null*/ camera, num mainTextureSamples}); }

 /// The glow layer Helps adding a glow effect around the emissive parts of a mesh.
 /// Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
 /// glowy meshes to your scene.
 /// Documentation: https://doc.babylonjs.com/how_to/glow_layer
 @JS("BABYLON.GlowLayer" ) class GlowLayer extends EffectLayer { // @Ignore
 GlowLayer .fakeConstructor$() : super.fakeConstructor$() ;
 /// Effect Name of the layer.
 external static String get EffectName; external static set EffectName(String v);
 /// The default blur kernel size used for the glow.
 external static num get DefaultBlurKernelSize; external static set DefaultBlurKernelSize(num v);
 /// The default texture size ratio used for the glow.
 external static num get DefaultTextureRatio; external static set DefaultTextureRatio(num v);
 /// Gets the kernel size of the blur.
 /// Sets the kernel size of the blur.
 external num get blurKernelSize; external set blurKernelSize(num v);
 /// Gets the glow intensity.
 /// Sets the glow intensity.
 external num get intensity; external set intensity(num v); external get JS$_options; external set JS$_options(v); external get JS$_intensity; external set JS$_intensity(v); external get JS$_horizontalBlurPostprocess1; external set JS$_horizontalBlurPostprocess1(v); external get JS$_verticalBlurPostprocess1; external set JS$_verticalBlurPostprocess1(v); external get JS$_horizontalBlurPostprocess2; external set JS$_horizontalBlurPostprocess2(v); external get JS$_verticalBlurPostprocess2; external set JS$_verticalBlurPostprocess2(v); external get JS$_blurTexture1; external set JS$_blurTexture1(v); external get JS$_blurTexture2; external set JS$_blurTexture2(v); external get JS$_postProcesses1; external set JS$_postProcesses1(v); external get JS$_postProcesses2; external set JS$_postProcesses2(v); external get JS$_includedOnlyMeshes; external set JS$_includedOnlyMeshes(v); external get JS$_excludedMeshes; external set JS$_excludedMeshes(v);
 /// Callback used to let the user override the color selection on a per mesh basis
 external VoidFunc4<Mesh, SubMesh, Material, Color4> get customEmissiveColorSelector; external set customEmissiveColorSelector(VoidFunc4<Mesh, SubMesh, Material, Color4> v);
 /// Callback used to let the user override the texture selection on a per mesh basis
 external Func3<Mesh, SubMesh, Material, Texture> get customEmissiveTextureSelector; external set customEmissiveTextureSelector(Func3<Mesh, SubMesh, Material, Texture> v);
 /// Instantiates a new glow Layer and references it to the scene.
 external factory GlowLayer(String name, Scene scene, [Partial<IGlowLayerOptions> options]);
 /// Get the effect name of the layer.
 external String getEffectName();
 /// Create the merge effect. This is the shader use to blit the information back
 /// to the main canvas at the end of the scene rendering.
 external Effect JS$_createMergeEffect();
 /// Creates the render target textures and post processes used in the glow layer.
 external void JS$_createTextureAndPostProcesses();
 /// Checks for the readiness of the element composing the layer.
 external bool isReady(SubMesh subMesh, bool useInstances);
 /// Returns wether or nood the layer needs stencil enabled during the mesh rendering.
 external bool needStencil();
 /// Implementation specific of rendering the generating effect on the main canvas.
 external void JS$_internalRender(Effect effect);
 /// Sets the required values for both the emissive texture and and the main color.
 external void JS$_setEmissiveTextureAndColor(Mesh mesh, SubMesh subMesh, Material material);
 /// Returns true if the mesh should render, otherwise false.
 external bool JS$_shouldRenderMesh(Mesh mesh);
 /// Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.
 external void addExcludedMesh(Mesh mesh);
 /// Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.
 external void removeExcludedMesh(Mesh mesh);
 /// Add a mesh in the inclusion list to impact or being impacted by the glow layer.
 external void addIncludedOnlyMesh(Mesh mesh);
 /// Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.
 external void removeIncludedOnlyMesh(Mesh mesh);
 /// Determine if a given mesh will be used in the glow layer
 external bool hasMesh(AbstractMesh mesh);
 /// Free any resources and references associated to a mesh.
 /// Internal use
 external void JS$_disposeMesh(Mesh mesh);
 /// Gets the class name of the effect layer
 external String getClassName();
 /// Serializes this glow layer
 external dynamic serialize();
 /// Creates a Glow Layer from parsed glow layer data
 external static GlowLayer Parse(dynamic parsedGlowLayer, Scene scene, String rootUrl); }

 /// Highlight layer options. This helps customizing the behaviour
 /// of the highlight layer.
 @anonymous @JS() abstract class IHighlightLayerOptions {
 /// Multiplication factor apply to the canvas size to compute the render target size
 /// used to generated the glowing objects (the smaller the faster).
 external num get mainTextureRatio; external set mainTextureRatio(num v);
 /// Enforces a fixed size texture to ensure resize independant blur.
 external num get mainTextureFixedSize; external set mainTextureFixedSize(num v);
 /// Multiplication factor apply to the main texture size in the first step of the blur to reduce the size
 /// of the picture to blur (the smaller the faster).
 external num get blurTextureSizeRatio; external set blurTextureSizeRatio(num v);
 /// How big in texel of the blur texture is the vertical blur.
 external num get blurVerticalSize; external set blurVerticalSize(num v);
 /// How big in texel of the blur texture is the horizontal blur.
 external num get blurHorizontalSize; external set blurHorizontalSize(num v);
 /// Alpha blending mode used to apply the blur. Default is combine.
 external num get alphaBlendingMode; external set alphaBlendingMode(num v);
 /// The camera attached to the layer.
 external Camera/*Camera|Null*/ get camera; external set camera(Camera/*Camera|Null*/ v);
 /// Should we display highlight as a solid stroke?
 external bool get isStroke; external set isStroke(bool v); external factory IHighlightLayerOptions({ num mainTextureRatio, num mainTextureFixedSize, num blurTextureSizeRatio, num blurVerticalSize, num blurHorizontalSize, num alphaBlendingMode, Camera/*Camera|Null*/ camera, bool isStroke}); }

 /// The highlight layer Helps adding a glow effect around a mesh.
 /// Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
 /// glowy meshes to your scene.
 /// !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!
 @JS("BABYLON.HighlightLayer" ) class HighlightLayer extends EffectLayer { // @Ignore
 HighlightLayer .fakeConstructor$() : super.fakeConstructor$() ;
 external String get name; external set name(String v);
 /// Effect Name of the highlight layer.
 external static String get EffectName; external static set EffectName(String v);
 /// The neutral color used during the preparation of the glow effect.
 /// This is black by default as the blend operation is a blend operation.
 external static Color4 get NeutralColor; external static set NeutralColor(Color4 v);
 /// Stencil value used for glowing meshes.
 external static num get GlowingMeshStencilReference; external static set GlowingMeshStencilReference(num v);
 /// Stencil value used for the other meshes in the scene.
 external static num get NormalMeshStencilReference; external static set NormalMeshStencilReference(num v);
 /// Specifies whether or not the inner glow is ACTIVE in the layer.
 external bool get innerGlow; external set innerGlow(bool v);
 /// Specifies whether or not the outer glow is ACTIVE in the layer.
 external bool get outerGlow; external set outerGlow(bool v);
 /// Gets the horizontal size of the blur.
 /// Specifies the horizontal size of the blur.
 external num get blurHorizontalSize; external set blurHorizontalSize(num v);
 /// Gets the vertical size of the blur.
 /// Specifies the vertical size of the blur.
 external num get blurVerticalSize; external set blurVerticalSize(num v);
 /// An event triggered when the highlight layer is being blurred.
 external Observable<HighlightLayer> get onBeforeBlurObservable; external set onBeforeBlurObservable(Observable<HighlightLayer> v);
 /// An event triggered when the highlight layer has been blurred.
 external Observable<HighlightLayer> get onAfterBlurObservable; external set onAfterBlurObservable(Observable<HighlightLayer> v); external get JS$_instanceGlowingMeshStencilReference; external set JS$_instanceGlowingMeshStencilReference(v); external get JS$_options; external set JS$_options(v); external get JS$_downSamplePostprocess; external set JS$_downSamplePostprocess(v); external get JS$_horizontalBlurPostprocess; external set JS$_horizontalBlurPostprocess(v); external get JS$_verticalBlurPostprocess; external set JS$_verticalBlurPostprocess(v); external get JS$_blurTexture; external set JS$_blurTexture(v); external get JS$_meshes; external set JS$_meshes(v); external get JS$_excludedMeshes; external set JS$_excludedMeshes(v);
 /// Instantiates a new highlight Layer and references it to the scene..
 external factory HighlightLayer(String name, Scene scene, [Partial<IHighlightLayerOptions> options]);
 /// Get the effect name of the layer.
 external String getEffectName();
 /// Create the merge effect. This is the shader use to blit the information back
 /// to the main canvas at the end of the scene rendering.
 external Effect JS$_createMergeEffect();
 /// Creates the render target textures and post processes used in the highlight layer.
 external void JS$_createTextureAndPostProcesses();
 /// Returns wether or nood the layer needs stencil enabled during the mesh rendering.
 external bool needStencil();
 /// Checks for the readiness of the element composing the layer.
 external bool isReady(SubMesh subMesh, bool useInstances);
 /// Implementation specific of rendering the generating effect on the main canvas.
 external void JS$_internalRender(Effect effect);
 /// Returns true if the layer contains information to display, otherwise false.
 external bool shouldRender();
 /// Returns true if the mesh should render, otherwise false.
 external bool JS$_shouldRenderMesh(Mesh mesh);
 /// Sets the required values for both the emissive texture and and the main color.
 external void JS$_setEmissiveTextureAndColor(Mesh mesh, SubMesh subMesh, Material material);
 /// Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.
 external void addExcludedMesh(Mesh mesh);
 /// Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.
 external void removeExcludedMesh(Mesh mesh);
 /// Determine if a given mesh will be highlighted by the current HighlightLayer
 external bool hasMesh(AbstractMesh mesh);
 /// Add a mesh in the highlight layer in order to make it glow with the chosen color.
 external void addMesh(Mesh mesh, Color3 color, [bool glowEmissiveOnly]);
 /// Remove a mesh from the highlight layer in order to make it stop glowing.
 external void removeMesh(Mesh mesh);
 /// Force the stencil to the normal expected value for none glowing parts
 external JS$_defaultStencilReference(mesh);
 /// Free any resources and references associated to a mesh.
 /// Internal use
 external void JS$_disposeMesh(Mesh mesh);
 /// Dispose the highlight layer and free resources.
 external void dispose();
 /// Gets the class name of the effect layer
 external String getClassName();
 /// Serializes this Highlight layer
 external dynamic serialize();
 /// Creates a Highlight layer from parsed Highlight layer data
 external static HighlightLayer Parse(dynamic parsedHightlightLayer, Scene scene, String rootUrl); }

 @JS("BABYLON.Layer" ) class Layer { // @Ignore
 Layer .fakeConstructor$() ;
 external String get name; external set name(String v); external Texture/*Texture|Null*/ get texture; external set texture(Texture/*Texture|Null*/ v); external bool get isBackground; external set isBackground(bool v); external Color4 get color; external set color(Color4 v); external Vector2 get scale; external set scale(Vector2 v); external Vector2 get offset; external set offset(Vector2 v); external num get alphaBlendingMode; external set alphaBlendingMode(num v); external bool get alphaTest; external set alphaTest(bool v); external num get layerMask; external set layerMask(num v); external get JS$_scene; external set JS$_scene(v); external get JS$_vertexBuffers; external set JS$_vertexBuffers(v); external get JS$_indexBuffer; external set JS$_indexBuffer(v); external get JS$_effect; external set JS$_effect(v); external get JS$_alphaTestEffect; external set JS$_alphaTestEffect(v);
 /// An event triggered when the layer is disposed.
 external Observable<Layer> get onDisposeObservable; external set onDisposeObservable(Observable<Layer> v); external get JS$_onDisposeObserver; external set JS$_onDisposeObserver(v); external VoidFunc0 get onDispose; external set onDispose(VoidFunc0 v);
 /// An event triggered before rendering the scene
 external Observable<Layer> get onBeforeRenderObservable; external set onBeforeRenderObservable(Observable<Layer> v); external get JS$_onBeforeRenderObserver; external set JS$_onBeforeRenderObserver(v); external VoidFunc0 get onBeforeRender; external set onBeforeRender(VoidFunc0 v);
 /// An event triggered after rendering the scene
 external Observable<Layer> get onAfterRenderObservable; external set onAfterRenderObservable(Observable<Layer> v); external get JS$_onAfterRenderObserver; external set JS$_onAfterRenderObserver(v); external VoidFunc0 get onAfterRender; external set onAfterRender(VoidFunc0 v); external factory Layer(String name, String/*String|Null*/ imgUrl, Scene/*Scene|Null*/ scene, [bool isBackground, Color4 color]); external JS$_createIndexBuffer(); external void JS$_rebuild(); external void render(); external void dispose(); }

 @JS("BABYLON.LensFlare" ) class LensFlare { // @Ignore
 LensFlare .fakeConstructor$() ;
 external num get size; external set size(num v); external num get position; external set position(num v); external Color3 get color; external set color(Color3 v); external Texture/*Texture|Null*/ get texture; external set texture(Texture/*Texture|Null*/ v); external num get alphaMode; external set alphaMode(num v); external get JS$_system; external set JS$_system(v); external static LensFlare AddFlare(num size, num position, Color3 color, String imgUrl, LensFlareSystem system); external factory LensFlare(num size, num position, Color3 color, String imgUrl, LensFlareSystem system); external void dispose(); }

 @JS("BABYLON.LensFlareSystem" ) class LensFlareSystem { // @Ignore
 LensFlareSystem .fakeConstructor$() ;
 external String get name; external set name(String v); external List<LensFlare> get lensFlares; external set lensFlares(List<LensFlare> v); external num get borderLimit; external set borderLimit(num v); external num get viewportBorder; external set viewportBorder(num v); external Func1<AbstractMesh, bool> get meshesSelectionPredicate; external set meshesSelectionPredicate(Func1<AbstractMesh, bool> v); external num get layerMask; external set layerMask(num v); external String get id; external set id(String v); external get JS$_scene; external set JS$_scene(v); external get JS$_emitter; external set JS$_emitter(v); external get JS$_vertexBuffers; external set JS$_vertexBuffers(v); external get JS$_indexBuffer; external set JS$_indexBuffer(v); external get JS$_effect; external set JS$_effect(v); external get JS$_positionX; external set JS$_positionX(v); external get JS$_positionY; external set JS$_positionY(v); external get JS$_isEnabled; external set JS$_isEnabled(v); external factory LensFlareSystem(String name, dynamic emitter, Scene scene); external bool get isEnabled; external set isEnabled(bool v); external Scene getScene(); external dynamic getEmitter(); external void setEmitter(dynamic newEmitter); external Vector3 getEmitterPosition(); external bool computeEffectivePosition(Viewport globalViewport); external bool JS$_isVisible(); external bool render(); external void dispose(); external static LensFlareSystem Parse(dynamic parsedLensFlareSystem, Scene scene, String rootUrl); external dynamic serialize(); }

 /// A directional light is defined by a direction (what a surprise!).
 /// The light is emitted from everywhere in the specified direction, and has an infinite range.
 /// An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.
 /// Documentation: https://doc.babylonjs.com/babylon101/lights
 @JS("BABYLON.DirectionalLight" ) class DirectionalLight extends ShadowLight { // @Ignore
 DirectionalLight .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_shadowFrustumSize; external set JS$_shadowFrustumSize(v);
 /// Fix frustum size for the shadow generation. This is disabled if the value is 0.
 /// Specifies a fix frustum size for the shadow generation.
 external num get shadowFrustumSize; external set shadowFrustumSize(num v); external get JS$_shadowOrthoScale; external set JS$_shadowOrthoScale(v);
 /// Gets the shadow projection scale against the optimal computed one.
 /// 0.1 by default which means that the projection window is increase by 10% from the optimal size.
 /// This does not impact in fixed frustum size (shadowFrustumSize being set)
 /// Sets the shadow projection scale against the optimal computed one.
 /// 0.1 by default which means that the projection window is increase by 10% from the optimal size.
 /// This does not impact in fixed frustum size (shadowFrustumSize being set)
 external num get shadowOrthoScale; external set shadowOrthoScale(num v);
 /// Automatically compute the projection matrix to best fit (including all the casters)
 /// on each frame.
 external bool get autoUpdateExtends; external set autoUpdateExtends(bool v); external get JS$_orthoLeft; external set JS$_orthoLeft(v); external get JS$_orthoRight; external set JS$_orthoRight(v); external get JS$_orthoTop; external set JS$_orthoTop(v); external get JS$_orthoBottom; external set JS$_orthoBottom(v);
 /// Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
 /// The directional light is emitted from everywhere in the given direction.
 /// It can cast shawdows.
 /// Documentation : http://doc.babylonjs.com/tutorials/lights
 external factory DirectionalLight(String name, Vector3 direction, Scene scene);
 /// Returns the string "DirectionalLight".
 external String getClassName();
 /// Returns the integer 1.
 external num getTypeID();
 /// Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
 /// Returns the DirectionalLight Shadow projection matrix.
 external void JS$_setDefaultShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);
 /// Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
 /// Returns the DirectionalLight Shadow projection matrix.
 external void JS$_setDefaultFixedFrustumShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix);
 /// Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
 /// Returns the DirectionalLight Shadow projection matrix.
 external void JS$_setDefaultAutoExtendShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList); external void JS$_buildUniformLayout();
 /// Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.
 external DirectionalLight transferToEffect(Effect effect, String lightIndex);
 /// Gets the minZ used for shadow according to both the scene and the light.
 /// Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
 /// -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
 external num getDepthMinZ(Camera activeCamera);
 /// Gets the maxZ used for shadow according to both the scene and the light.
 /// Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
 /// -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
 external num getDepthMaxZ(Camera activeCamera); }

 /// The HemisphericLight simulates the ambient environment light,
 /// so the passed direction is the light reflection direction, not the incoming direction.
 @JS("BABYLON.HemisphericLight" ) class HemisphericLight extends Light { // @Ignore
 HemisphericLight .fakeConstructor$() : super.fakeConstructor$() ;
 /// The groundColor is the light in the opposite direction to the one specified during creation.
 /// You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.
 external Color3 get groundColor; external set groundColor(Color3 v);
 /// The light reflection direction, not the incoming direction.
 external Vector3 get direction; external set direction(Vector3 v); external get JS$_worldMatrix; external set JS$_worldMatrix(v);
 /// Creates a HemisphericLight object in the scene according to the passed direction (Vector3).
 /// The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.
 /// The HemisphericLight can't cast shadows.
 /// Documentation : http://doc.babylonjs.com/tutorials/lights
 external factory HemisphericLight(String name, Vector3 direction, Scene scene); external void JS$_buildUniformLayout();
 /// Returns the string "HemisphericLight".
 external String getClassName();
 /// Sets the HemisphericLight direction towards the passed target (Vector3).
 /// Returns the updated direction.
 external Vector3 setDirectionToTarget(Vector3 target);
 /// Returns the shadow generator associated to the light.
 external ShadowGenerator/*ShadowGenerator|Null*/ getShadowGenerator();
 /// Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).
 external HemisphericLight transferToEffect(Effect effect, String lightIndex);
 /// @hidden internal use only.
 external Matrix JS$_getWorldMatrix();
 /// Returns the integer 3.
 external num getTypeID(); }

 /// Base class of all the lights in Babylon. It groups all the generic information about lights.
 /// Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.
 /// All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.
 @JS("BABYLON.Light" ) abstract class Light extends Node { // @Ignore
 Light .fakeConstructor$() : super.fakeConstructor$() ;
 external static get JS$_LIGHTMAP_DEFAULT; external static set JS$_LIGHTMAP_DEFAULT(v); external static get JS$_LIGHTMAP_SPECULAR; external static set JS$_LIGHTMAP_SPECULAR(v); external static get JS$_LIGHTMAP_SHADOWSONLY; external static set JS$_LIGHTMAP_SHADOWSONLY(v);
 /// If every light affecting the material is in this lightmapMode,
 /// material.lightmapTexture adds or multiplies
 /// (depends on material.useLightmapAsShadowmap)
 /// after every other light calculations.
 external static num get LIGHTMAP_DEFAULT; external static set LIGHTMAP_DEFAULT(num v);
 /// material.lightmapTexture as only diffuse lighting from this light
 /// adds only specular lighting from this light
 /// adds dynamic shadows
 external static num get LIGHTMAP_SPECULAR; external static set LIGHTMAP_SPECULAR(num v);
 /// material.lightmapTexture as only lighting
 /// no light calculation from this light
 /// only adds dynamic shadows from this light
 external static num get LIGHTMAP_SHADOWSONLY; external static set LIGHTMAP_SHADOWSONLY(num v); external static get JS$_INTENSITYMODE_AUTOMATIC; external static set JS$_INTENSITYMODE_AUTOMATIC(v); external static get JS$_INTENSITYMODE_LUMINOUSPOWER; external static set JS$_INTENSITYMODE_LUMINOUSPOWER(v); external static get JS$_INTENSITYMODE_LUMINOUSINTENSITY; external static set JS$_INTENSITYMODE_LUMINOUSINTENSITY(v); external static get JS$_INTENSITYMODE_ILLUMINANCE; external static set JS$_INTENSITYMODE_ILLUMINANCE(v); external static get JS$_INTENSITYMODE_LUMINANCE; external static set JS$_INTENSITYMODE_LUMINANCE(v);
 /// Each light type uses the default quantity according to its type:
 /// point/spot lights use luminous intensity
 /// directional lights use illuminance
 external static num get INTENSITYMODE_AUTOMATIC; external static set INTENSITYMODE_AUTOMATIC(num v);
 /// lumen (lm)
 external static num get INTENSITYMODE_LUMINOUSPOWER; external static set INTENSITYMODE_LUMINOUSPOWER(num v);
 /// candela (lm/sr)
 external static num get INTENSITYMODE_LUMINOUSINTENSITY; external static set INTENSITYMODE_LUMINOUSINTENSITY(num v);
 /// lux (lm/m^2)
 external static num get INTENSITYMODE_ILLUMINANCE; external static set INTENSITYMODE_ILLUMINANCE(num v);
 /// nit (cd/m^2)
 external static num get INTENSITYMODE_LUMINANCE; external static set INTENSITYMODE_LUMINANCE(num v); external static get JS$_LIGHTTYPEID_POINTLIGHT; external static set JS$_LIGHTTYPEID_POINTLIGHT(v); external static get JS$_LIGHTTYPEID_DIRECTIONALLIGHT; external static set JS$_LIGHTTYPEID_DIRECTIONALLIGHT(v); external static get JS$_LIGHTTYPEID_SPOTLIGHT; external static set JS$_LIGHTTYPEID_SPOTLIGHT(v); external static get JS$_LIGHTTYPEID_HEMISPHERICLIGHT; external static set JS$_LIGHTTYPEID_HEMISPHERICLIGHT(v);
 /// Light type const id of the point light.
 external static num get LIGHTTYPEID_POINTLIGHT; external static set LIGHTTYPEID_POINTLIGHT(num v);
 /// Light type const id of the directional light.
 external static num get LIGHTTYPEID_DIRECTIONALLIGHT; external static set LIGHTTYPEID_DIRECTIONALLIGHT(num v);
 /// Light type const id of the spot light.
 external static num get LIGHTTYPEID_SPOTLIGHT; external static set LIGHTTYPEID_SPOTLIGHT(num v);
 /// Light type const id of the hemispheric light.
 external static num get LIGHTTYPEID_HEMISPHERICLIGHT; external static set LIGHTTYPEID_HEMISPHERICLIGHT(num v);
 /// Diffuse gives the basic color to an object.
 external Color3 get diffuse; external set diffuse(Color3 v);
 /// Specular produces a highlight color on an object.
 /// Note: This is note affecting PBR materials.
 external Color3 get specular; external set specular(Color3 v);
 /// Strength of the light.
 /// Note: By default it is define in the framework own unit.
 /// Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.
 external num get intensity; external set intensity(num v);
 /// Defines how far from the source the light is impacting in scene units.
 /// Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
 external num get range; external set range(num v);
 /// Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type
 /// of light.
 external get JS$_photometricScale; external set JS$_photometricScale(v); external get JS$_intensityMode; external set JS$_intensityMode(v);
 /// Gets the photometric scale used to interpret the intensity.
 /// This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
 /// Sets the photometric scale used to interpret the intensity.
 /// This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
 external num get intensityMode; external set intensityMode(num v); external get JS$_radius; external set JS$_radius(v);
 /// Gets the light radius used by PBR Materials to simulate soft area lights.
 /// sets the light radius used by PBR Materials to simulate soft area lights.
 external num get radius; external set radius(num v); external get JS$_renderPriority; external set JS$_renderPriority(v);
 /// Defines the rendering priority of the lights. It can help in case of fallback or number of lights
 /// exceeding the number allowed of the materials.
 external num get renderPriority; external set renderPriority(num v);
 /// Defines wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
 /// the current shadow generator.
 external bool get shadowEnabled; external set shadowEnabled(bool v); external get JS$_includedOnlyMeshes; external set JS$_includedOnlyMeshes(v);
 /// Gets the only meshes impacted by this light.
 /// Sets the only meshes impacted by this light.
 external List<AbstractMesh> get includedOnlyMeshes; external set includedOnlyMeshes(List<AbstractMesh> v); external get JS$_excludedMeshes; external set JS$_excludedMeshes(v);
 /// Gets the meshes not impacted by this light.
 /// Sets the meshes not impacted by this light.
 external List<AbstractMesh> get excludedMeshes; external set excludedMeshes(List<AbstractMesh> v); external get JS$_excludeWithLayerMask; external set JS$_excludeWithLayerMask(v);
 /// Gets the layer id use to find what meshes are not impacted by the light.
 /// Inactive if 0
 /// Sets the layer id use to find what meshes are not impacted by the light.
 /// Inactive if 0
 external num get excludeWithLayerMask; external set excludeWithLayerMask(num v); external get JS$_includeOnlyWithLayerMask; external set JS$_includeOnlyWithLayerMask(v);
 /// Gets the layer id use to find what meshes are impacted by the light.
 /// Inactive if 0
 /// Sets the layer id use to find what meshes are impacted by the light.
 /// Inactive if 0
 external num get includeOnlyWithLayerMask; external set includeOnlyWithLayerMask(num v); external get JS$_lightmapMode; external set JS$_lightmapMode(v);
 /// Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
 /// Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
 external num get lightmapMode; external set lightmapMode(num v); external get JS$_parentedWorldMatrix; external set JS$_parentedWorldMatrix(v);
 /// Shadow generator associted to the light.
 /// Internal use only.
 external IShadowGenerator/*IShadowGenerator|Null*/ get JS$_shadowGenerator; external set JS$_shadowGenerator(IShadowGenerator/*IShadowGenerator|Null*/ v);
 /// @hidden Internal use only.
 external List<String> get JS$_excludedMeshesIds; external set JS$_excludedMeshesIds(List<String> v);
 /// @hidden Internal use only.
 external List<String> get JS$_includedOnlyMeshesIds; external set JS$_includedOnlyMeshesIds(List<String> v);
 /// The current light unifom buffer.
 /// @hidden Internal use only.
 external UniformBuffer get JS$_uniformBuffer; external set JS$_uniformBuffer(UniformBuffer v);
 /// Creates a Light object in the scene.
 /// Documentation : http://doc.babylonjs.com/tutorials/lights
 external factory Light(String name, Scene scene); external void JS$_buildUniformLayout();
 /// Sets the passed Effect "effect" with the Light information.
 external Light transferToEffect(Effect effect, String lightIndex);
 /// @hidden internal use only.
 external Matrix JS$_getWorldMatrix();
 /// Returns the string "Light".
 external String getClassName();
 /// Converts the light information to a readable string for debug purpose.
 external String toString([bool fullDetails]);
 /// Set the enabled state of this node.
 external void setEnabled(bool value);
 /// Returns the Light associated shadow generator if any.
 external IShadowGenerator/*IShadowGenerator|Null*/ getShadowGenerator();
 /// Returns a Vector3, the absolute light position in the World.
 external Vector3 getAbsolutePosition();
 /// Specifies if the light will affect the passed mesh.
 external bool canAffectMesh(AbstractMesh mesh);
 /// Computes and Returns the light World matrix.
 external Matrix getWorldMatrix();
 /// Sort function to order lights for rendering.
 external static num CompareLightsPriority(Light a, Light b);
 /// Releases resources associated with this node.
 external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);
 /// Returns the light type ID (integer).
 external num getTypeID();
 /// Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
 external num getScaledIntensity();
 /// Returns a new Light object, named "name", from the current one.
 external Light/*Light|Null*/ clone(String name);
 /// Serializes the current light into a Serialization object.
 external dynamic serialize();
 /// Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
 /// This new light is named "name" and added to the passed scene.
 external static Func0<Light>/*Func0<Light>|Null*/ GetConstructorFromName(num type, String name, Scene scene);
 /// Parses the passed "parsedLight" and returns a new instanced Light from this parsing.
 external static Light/*Light|Null*/ Parse(dynamic parsedLight, Scene scene); external JS$_hookArrayForExcluded(array); external JS$_hookArrayForIncludedOnly(array); external JS$_resyncMeshes();
 /// Forces the meshes to update their light related information in their rendering used effects
 /// @hidden Internal Use Only
 external void JS$_markMeshesAsLightDirty();
 /// Recomputes the cached photometric scale if needed.
 external JS$_computePhotometricScale();
 /// Returns the Photometric Scale according to the light type and intensity mode.
 external JS$_getPhotometricScale();
 /// Reorder the light in the scene according to their defined priority.
 /// @hidden Internal Use Only
 external void JS$_reorderLightsInScene(); }

 /// A point light is a light defined by an unique point in world space.
 /// The light is emitted in every direction from this point.
 /// A good example of a point light is a standard light bulb.
 /// Documentation: https://doc.babylonjs.com/babylon101/lights
 @JS("BABYLON.PointLight" ) class PointLight extends ShadowLight { // @Ignore
 PointLight .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_shadowAngle; external set JS$_shadowAngle(v);
 /// Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
 /// This specifies what angle the shadow will use to be created.
 /// It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
 /// Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
 /// This specifies what angle the shadow will use to be created.
 /// It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
 external num get shadowAngle; external set shadowAngle(num v);
 /// Gets the direction if it has been set.
 /// In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
 /// In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
 external Vector3 get direction; external set direction(Vector3 v);
 /// Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.
 /// A PointLight emits the light in every direction.
 /// It can cast shadows.
 /// If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :
 /// ```javascript
 /// var pointLight = new BABYLON.PointLight("pl", camera.position, scene);
 /// ```
 /// Documentation : http://doc.babylonjs.com/tutorials/lights
 external factory PointLight(String name, Vector3 position, Scene scene);
 /// Returns the string "PointLight"
 external String getClassName();
 /// Returns the integer 0.
 external num getTypeID();
 /// Specifies wether or not the shadowmap should be a cube texture.
 external bool needCube();
 /// Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).
 external Vector3 getShadowDirection([num faceIndex]);
 /// Sets the passed matrix "matrix" as a left-handed perspective projection matrix with the following settings :
 /// - fov = PI / 2
 /// - aspect ratio : 1.0
 /// - z-near and far equal to the active camera minZ and maxZ.
 /// Returns the PointLight.
 external void JS$_setDefaultShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList); external void JS$_buildUniformLayout();
 /// Sets the passed Effect "effect" with the PointLight transformed position (or position, if none) and passed name (string).
 external PointLight transferToEffect(Effect effect, String lightIndex); }

 /// Interface describing all the common properties and methods a shadow light needs to implement.
 /// This helps both the shadow generator and materials to genrate the corresponding shadow maps
 /// as well as binding the different shadow properties to the effects.
 @anonymous @JS() abstract class IShadowLight implements Light {
 /// The light id in the scene (used in scene.findLighById for instance)
 external String get id; external set id(String v);
 /// The position the shdow will be casted from.
 external Vector3 get position; external set position(Vector3 v);
 /// In 2d mode (needCube being false), the direction used to cast the shadow.
 external Vector3 get direction; external set direction(Vector3 v);
 /// The transformed position. Position of the light in world space taking parenting in account.
 external Vector3 get transformedPosition; external set transformedPosition(Vector3 v);
 /// The transformed direction. Direction of the light in world space taking parenting in account.
 external Vector3 get transformedDirection; external set transformedDirection(Vector3 v);
 /// The friendly name of the light in the scene.
 external String get name; external set name(String v);
 /// Defines the shadow projection clipping minimum z value.
 external num get shadowMinZ; external set shadowMinZ(num v);
 /// Defines the shadow projection clipping maximum z value.
 external num get shadowMaxZ; external set shadowMaxZ(num v);
 /// Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
 external bool computeTransformedInformation();
 /// Gets the scene the light belongs to.
 external Scene getScene();
 /// Callback defining a custom Projection Matrix Builder.
 /// This can be used to override the default projection matrix computation.
 external VoidFunc3<Matrix, List<AbstractMesh>, Matrix> get customProjectionMatrixBuilder; external set customProjectionMatrixBuilder(VoidFunc3<Matrix, List<AbstractMesh>, Matrix> v);
 /// Sets the shadow projection matrix in parameter to the generated projection matrix.
 external IShadowLight setShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList);
 /// Gets the current depth scale used in ESM.
 external num getDepthScale();
 /// Returns whether or not the shadow generation require a cube texture or a 2d texture.
 external bool needCube();
 /// Detects if the projection matrix requires to be recomputed this frame.
 external bool needProjectionMatrixCompute();
 /// Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
 external void forceProjectionMatrixCompute();
 /// Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
 external Vector3 getShadowDirection([num faceIndex]);
 /// Gets the minZ used for shadow according to both the scene and the light.
 external num getDepthMinZ(Camera activeCamera);
 /// Gets the maxZ used for shadow according to both the scene and the light.
 external num getDepthMaxZ(Camera activeCamera); }

 /// Base implementation IShadowLight
 /// It groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.
 @JS("BABYLON.ShadowLight" ) abstract class ShadowLight extends Light implements IShadowLight { // @Ignore
 ShadowLight .fakeConstructor$() : super.fakeConstructor$() ;
 external void JS$_setDefaultShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList); external Vector3 get JS$_position; external set JS$_position(Vector3 v); external void JS$_setPosition(Vector3 value);
 /// Sets the position the shadow will be casted from. Also use as the light position for both
 /// point and spot lights.
 /// Sets the position the shadow will be casted from. Also use as the light position for both
 /// point and spot lights.
 external Vector3 get position; external set position(Vector3 v); external Vector3 get JS$_direction; external set JS$_direction(Vector3 v); external void JS$_setDirection(Vector3 value);
 /// In 2d mode (needCube being false), gets the direction used to cast the shadow.
 /// Also use as the light direction on spot and directional lights.
 /// In 2d mode (needCube being false), sets the direction used to cast the shadow.
 /// Also use as the light direction on spot and directional lights.
 external Vector3 get direction; external set direction(Vector3 v); external get JS$_shadowMinZ; external set JS$_shadowMinZ(v);
 /// Gets the shadow projection clipping minimum z value.
 /// Sets the shadow projection clipping minimum z value.
 external num get shadowMinZ; external set shadowMinZ(num v); external get JS$_shadowMaxZ; external set JS$_shadowMaxZ(v);
 /// Sets the shadow projection clipping maximum z value.
 /// Gets the shadow projection clipping maximum z value.
 external num get shadowMaxZ; external set shadowMaxZ(num v);
 /// Callback defining a custom Projection Matrix Builder.
 /// This can be used to override the default projection matrix computation.
 external VoidFunc3<Matrix, List<AbstractMesh>, Matrix> get customProjectionMatrixBuilder; external set customProjectionMatrixBuilder(VoidFunc3<Matrix, List<AbstractMesh>, Matrix> v);
 /// The transformed position. Position of the light in world space taking parenting in account.
 external Vector3 get transformedPosition; external set transformedPosition(Vector3 v);
 /// The transformed direction. Direction of the light in world space taking parenting in account.
 external Vector3 get transformedDirection; external set transformedDirection(Vector3 v); external get JS$_worldMatrix; external set JS$_worldMatrix(v); external get JS$_needProjectionMatrixCompute; external set JS$_needProjectionMatrixCompute(v);
 /// Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
 external bool computeTransformedInformation();
 /// Return the depth scale used for the shadow map.
 external num getDepthScale();
 /// Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.
 external Vector3 getShadowDirection([num faceIndex]);
 /// Returns the ShadowLight absolute position in the World.
 external Vector3 getAbsolutePosition();
 /// Sets the ShadowLight direction toward the passed target.
 external Vector3 setDirectionToTarget(Vector3 target);
 /// Returns the light rotation in euler definition.
 external Vector3 getRotation();
 /// Returns whether or not the shadow generation require a cube texture or a 2d texture.
 external bool needCube();
 /// Detects if the projection matrix requires to be recomputed this frame.
 external bool needProjectionMatrixCompute();
 /// Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
 external void forceProjectionMatrixCompute();
 /// Get the world matrix of the sahdow lights.
 /// @hidden Internal Use Only
 external Matrix JS$_getWorldMatrix();
 /// Gets the minZ used for shadow according to both the scene and the light.
 external num getDepthMinZ(Camera activeCamera);
 /// Gets the maxZ used for shadow according to both the scene and the light.
 external num getDepthMaxZ(Camera activeCamera);
 /// Sets the shadow projection matrix in parameter to the generated projection matrix.
 external IShadowLight setShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList); }

 /// A spot light is defined by a position, a direction, an angle, and an exponent.
 /// These values define a cone of light starting from the position, emitting toward the direction.
 /// The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,
 /// and the exponent defines the speed of the decay of the light with distance (reach).
 /// Documentation: https://doc.babylonjs.com/babylon101/lights
 @JS("BABYLON.SpotLight" ) class SpotLight extends ShadowLight { // @Ignore
 SpotLight .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_angle; external set JS$_angle(v);
 /// Gets the cone angle of the spot light in Radians.
 /// Sets the cone angle of the spot light in Radians.
 external num get angle; external set angle(num v); external get JS$_shadowAngleScale; external set JS$_shadowAngleScale(v);
 /// Allows scaling the angle of the light for shadow generation only.
 /// Allows scaling the angle of the light for shadow generation only.
 external num get shadowAngleScale; external set shadowAngleScale(num v);
 /// The light decay speed with the distance from the emission spot.
 external num get exponent; external set exponent(num v); external get JS$_projectionTextureMatrix; external set JS$_projectionTextureMatrix(v);
 /// Allows reading the projecton texture
 external Matrix get projectionTextureMatrix; external set projectionTextureMatrix(Matrix v); external num get JS$_projectionTextureLightNear; external set JS$_projectionTextureLightNear(num v);
 /// Gets the near clip of the Spotlight for texture projection.
 /// Sets the near clip of the Spotlight for texture projection.
 external num get projectionTextureLightNear; external set projectionTextureLightNear(num v); external num get JS$_projectionTextureLightFar; external set JS$_projectionTextureLightFar(num v);
 /// Gets the far clip of the Spotlight for texture projection.
 /// Sets the far clip of the Spotlight for texture projection.
 external num get projectionTextureLightFar; external set projectionTextureLightFar(num v); external Vector3 get JS$_projectionTextureUpDirection; external set JS$_projectionTextureUpDirection(Vector3 v);
 /// Gets the Up vector of the Spotlight for texture projection.
 /// Sets the Up vector of the Spotlight for texture projection.
 external Vector3 get projectionTextureUpDirection; external set projectionTextureUpDirection(Vector3 v); external get JS$_projectionTexture; external set JS$_projectionTexture(v);
 /// Gets the projection texture of the light.
 /// Sets the projection texture of the light.
 external BaseTexture/*BaseTexture|Null*/ get projectionTexture; external set projectionTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_projectionTextureViewLightDirty; external set JS$_projectionTextureViewLightDirty(v); external get JS$_projectionTextureProjectionLightDirty; external set JS$_projectionTextureProjectionLightDirty(v); external get JS$_projectionTextureDirty; external set JS$_projectionTextureDirty(v); external get JS$_projectionTextureViewTargetVector; external set JS$_projectionTextureViewTargetVector(v); external get JS$_projectionTextureViewLightMatrix; external set JS$_projectionTextureViewLightMatrix(v); external get JS$_projectionTextureProjectionLightMatrix; external set JS$_projectionTextureProjectionLightMatrix(v); external get JS$_projectionTextureScalingMatrix; external set JS$_projectionTextureScalingMatrix(v);
 /// Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.
 /// It can cast shadows.
 /// Documentation : http://doc.babylonjs.com/tutorials/lights
 external factory SpotLight(String name, Vector3 position, Vector3 direction, num angle, num exponent, Scene scene);
 /// Returns the string "SpotLight".
 external String getClassName();
 /// Returns the integer 2.
 external num getTypeID();
 /// Overrides the direction setter to recompute the projection texture view light Matrix.
 external void JS$_setDirection(Vector3 value);
 /// Overrides the position setter to recompute the projection texture view light Matrix.
 external void JS$_setPosition(Vector3 value);
 /// Sets the passed matrix "matrix" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.
 /// Returns the SpotLight.
 external void JS$_setDefaultShadowProjectionMatrix(Matrix matrix, Matrix viewMatrix, List<AbstractMesh> renderList); external void JS$_computeProjectionTextureViewLightMatrix(); external void JS$_computeProjectionTextureProjectionLightMatrix();
 /// Main function for light texture projection matrix computing.
 external void JS$_computeProjectionTextureMatrix(); external void JS$_buildUniformLayout();
 /// Sets the passed Effect object with the SpotLight transfomed position (or position if not parented) and normalized direction.
 external SpotLight transferToEffect(Effect effect, String lightIndex);
 /// Disposes the light and the associated resources.
 external void dispose(); }

 @anonymous @JS() abstract class ILoadingScreen { external VoidFunc0 get displayLoadingUI; external set displayLoadingUI(VoidFunc0 v); external VoidFunc0 get hideLoadingUI; external set hideLoadingUI(VoidFunc0 v); external String get loadingUIBackgroundColor; external set loadingUIBackgroundColor(String v); external String get loadingUIText; external set loadingUIText(String v); external factory ILoadingScreen({ VoidFunc0 displayLoadingUI, VoidFunc0 hideLoadingUI, String loadingUIBackgroundColor, String loadingUIText}); }

 @JS("BABYLON.DefaultLoadingScreen" ) class DefaultLoadingScreen implements ILoadingScreen { // @Ignore
 DefaultLoadingScreen .fakeConstructor$() ;
 external get JS$_renderingCanvas; external set JS$_renderingCanvas(v); external get JS$_loadingText; external set JS$_loadingText(v); external get JS$_loadingDivBackgroundColor; external set JS$_loadingDivBackgroundColor(v); external get JS$_loadingDiv; external set JS$_loadingDiv(v); external get JS$_loadingTextDiv; external set JS$_loadingTextDiv(v); external factory DefaultLoadingScreen(CanvasElement JS$_renderingCanvas, [String JS$_loadingText, String JS$_loadingDivBackgroundColor]); external void displayLoadingUI(); external void hideLoadingUI(); external String get loadingUIText; external set loadingUIText(String v); external String get loadingUIBackgroundColor; external set loadingUIBackgroundColor(String v); external get JS$_resizeLoadingUI; external set JS$_resizeLoadingUI(v); }

 @JS("BABYLON.SceneLoaderProgressEvent" ) class SceneLoaderProgressEvent { // @Ignore
 SceneLoaderProgressEvent .fakeConstructor$() ;
 external bool get lengthComputable; external set lengthComputable(bool v); external num get loaded; external set loaded(num v); external num get total; external set total(num v); external factory SceneLoaderProgressEvent(bool lengthComputable, num loaded, num total); external static SceneLoaderProgressEvent FromProgressEvent(ProgressEvent event); }

 @anonymous @JS() abstract class ISceneLoaderPluginExtensions { /* Index signature is not yet supported by JavaScript interop. */
 }

 @anonymous @JS() abstract class ISceneLoaderPluginFactory { external String get name; external set name(String v); external dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync*/ createPlugin(); external Func1<String, bool> get canDirectLoad; external set canDirectLoad(Func1<String, bool> v); }

 @anonymous @JS() abstract class ISceneLoaderPlugin {
 /// The friendly name of this plugin.
 external String get name; external set name(String v);
 /// The file extensions supported by this plugin.
 external dynamic/*String|ISceneLoaderPluginExtensions*/ get extensions; external set extensions(dynamic/*String|ISceneLoaderPluginExtensions*/ v);
 /// Import meshes into a scene.
 external bool importMesh(dynamic meshesNames, Scene scene, dynamic data, String rootUrl, List<AbstractMesh> meshes, List<ParticleSystem> particleSystems, List<Skeleton> skeletons, [void onError(String message, [dynamic exception])]);
 /// Load into a scene.
 external bool load(Scene scene, String data, String rootUrl, [void onError(String message, [dynamic exception])]);
 /// The callback that returns true if the data can be directly loaded.
 external Func1<String, bool> get canDirectLoad; external set canDirectLoad(Func1<String, bool> v);
 /// The callback that allows custom handling of the root url based on the response url.
 external Func2Opt1<String, String, String> get rewriteRootURL; external set rewriteRootURL(Func2Opt1<String, String, String> v);
 /// Load into an asset container.
 external AssetContainer loadAssetContainer(Scene scene, String data, String rootUrl, [void onError(String message, [dynamic exception])]); }

 @anonymous @JS() abstract class ISceneLoaderPluginAsync {
 /// The friendly name of this plugin.
 external String get name; external set name(String v);
 /// The file extensions supported by this plugin.
 external dynamic/*String|ISceneLoaderPluginExtensions*/ get extensions; external set extensions(dynamic/*String|ISceneLoaderPluginExtensions*/ v);
 /// Import meshes into a scene.
 external Promise<dynamic/*{
            meshes: AbstractMesh[];
            particleSystems: ParticleSystem[];
            skeletons: Skeleton[];
            animationGroups: AnimationGroup[];
        }*/> importMeshAsync(dynamic meshesNames, Scene scene, dynamic data, String rootUrl, [void onProgress(SceneLoaderProgressEvent event)]);
 /// Load into a scene.
 external Promise<Null> loadAsync(Scene scene, String data, String rootUrl, [void onProgress(SceneLoaderProgressEvent event)]);
 /// The callback that returns true if the data can be directly loaded.
 external Func1<String, bool> get canDirectLoad; external set canDirectLoad(Func1<String, bool> v);
 /// The callback that allows custom handling of the root url based on the response url.
 external Func2Opt1<String, String, String> get rewriteRootURL; external set rewriteRootURL(Func2Opt1<String, String, String> v);
 /// Load into an asset container.
 external Promise<AssetContainer> loadAssetContainerAsync(Scene scene, String data, String rootUrl, [void onProgress(SceneLoaderProgressEvent event)]); }

 @JS("BABYLON.SceneLoader" ) class SceneLoader { // @Ignore
 SceneLoader .fakeConstructor$() ;
 external static get JS$_ForceFullSceneLoadingForIncremental; external static set JS$_ForceFullSceneLoadingForIncremental(v); external static get JS$_ShowLoadingScreen; external static set JS$_ShowLoadingScreen(v); external static get JS$_CleanBoneMatrixWeights; external static set JS$_CleanBoneMatrixWeights(v); external static num get NO_LOGGING; external static set NO_LOGGING(num v); external static num get MINIMAL_LOGGING; external static set MINIMAL_LOGGING(num v); external static num get SUMMARY_LOGGING; external static set SUMMARY_LOGGING(num v); external static num get DETAILED_LOGGING; external static set DETAILED_LOGGING(num v); external static get JS$_loggingLevel; external static set JS$_loggingLevel(v); external static bool get ForceFullSceneLoadingForIncremental; external static set ForceFullSceneLoadingForIncremental(bool v); external static bool get ShowLoadingScreen; external static set ShowLoadingScreen(bool v); external static num get loggingLevel; external static set loggingLevel(num v); external static bool get CleanBoneMatrixWeights; external static set CleanBoneMatrixWeights(bool v); external static Observable<dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync*/> get OnPluginActivatedObservable; external static set OnPluginActivatedObservable(Observable<dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync*/> v); external static get JS$_registeredPlugins; external static set JS$_registeredPlugins(v); external static JS$_getDefaultPlugin(); external static JS$_getPluginForExtension(extension); external static JS$_getPluginForDirectLoad(data); external static JS$_getPluginForFilename(sceneFilename); external static JS$_getDirectLoad(sceneFilename); external static JS$_loadData(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, onDispose, pluginExtension); external static dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync|ISceneLoaderPluginFactory*/ GetPluginForExtension(String extension); external static bool IsPluginForExtensionAvailable(String extension); external static void RegisterPlugin(dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync*/ plugin);
 /// Import meshes into a scene
 external static dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync|Null*/ ImportMesh(dynamic meshNames, String rootUrl, String sceneFilename, Scene scene, [VoidFunc4<List<AbstractMesh>, List<ParticleSystem>, List<Skeleton>, List<AnimationGroup>>/*VoidFunc4<List<AbstractMesh>, List<ParticleSystem>, List<Skeleton>, List<AnimationGroup>>|Null*/ onSuccess, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, VoidFunc3Opt1<Scene, String, dynamic>/*VoidFunc3Opt1<Scene, String, dynamic>|Null*/ onError, String/*String|Null*/ pluginExtension]);
 /// Import meshes into a scene
 external static Promise<dynamic/*{
            meshes: AbstractMesh[];
            particleSystems: ParticleSystem[];
            skeletons: Skeleton[];
            animationGroups: AnimationGroup[];
        }*/> ImportMeshAsync(dynamic meshNames, String rootUrl, String sceneFilename, Scene scene, [VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, String/*String|Null*/ pluginExtension]);
 /// Load a scene
 external static dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync|Null*/ Load(String rootUrl, dynamic sceneFilename, Engine engine, [VoidFunc1<Scene>/*VoidFunc1<Scene>|Null*/ onSuccess, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, VoidFunc3Opt1<Scene, String, dynamic>/*VoidFunc3Opt1<Scene, String, dynamic>|Null*/ onError, String/*String|Null*/ pluginExtension]);
 /// Load a scene
 external static Promise<Scene> LoadAsync(String rootUrl, dynamic sceneFilename, Engine engine, [VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, String/*String|Null*/ pluginExtension]);
 /// Append a scene
 external static dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync|Null*/ Append(String rootUrl, dynamic sceneFilename, Scene scene, [VoidFunc1<Scene>/*VoidFunc1<Scene>|Null*/ onSuccess, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, VoidFunc3Opt1<Scene, String, dynamic>/*VoidFunc3Opt1<Scene, String, dynamic>|Null*/ onError, String/*String|Null*/ pluginExtension]);
 /// Append a scene
 external static Promise<Scene> AppendAsync(String rootUrl, dynamic sceneFilename, Scene scene, [VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, String/*String|Null*/ pluginExtension]);
 /// Load a scene into an asset container
 external static dynamic/*ISceneLoaderPlugin|ISceneLoaderPluginAsync|Null*/ LoadAssetContainer(String rootUrl, dynamic sceneFilename, Scene scene, [VoidFunc1<AssetContainer>/*VoidFunc1<AssetContainer>|Null*/ onSuccess, VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, VoidFunc3Opt1<Scene, String, dynamic>/*VoidFunc3Opt1<Scene, String, dynamic>|Null*/ onError, String/*String|Null*/ pluginExtension]);
 /// Load a scene into an asset container
 external static Promise<AssetContainer> LoadAssetContainerAsync(String rootUrl, dynamic sceneFilename, Scene scene, [VoidFunc1<SceneLoaderProgressEvent>/*VoidFunc1<SceneLoaderProgressEvent>|Null*/ onProgress, String/*String|Null*/ pluginExtension]); }

 /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
 /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
 /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
 /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
 @JS("BABYLON.ColorCurves" ) class ColorCurves { // @Ignore
 ColorCurves .fakeConstructor$() ;
 external get JS$_dirty; external set JS$_dirty(v); external get JS$_tempColor; external set JS$_tempColor(v); external get JS$_globalCurve; external set JS$_globalCurve(v); external get JS$_highlightsCurve; external set JS$_highlightsCurve(v); external get JS$_midtonesCurve; external set JS$_midtonesCurve(v); external get JS$_shadowsCurve; external set JS$_shadowsCurve(v); external get JS$_positiveCurve; external set JS$_positiveCurve(v); external get JS$_negativeCurve; external set JS$_negativeCurve(v); external get JS$_globalHue; external set JS$_globalHue(v); external get JS$_globalDensity; external set JS$_globalDensity(v); external get JS$_globalSaturation; external set JS$_globalSaturation(v); external get JS$_globalExposure; external set JS$_globalExposure(v);
 /// Gets the global Hue value.
 /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
 /// Sets the global Hue value.
 /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
 external num get globalHue; external set globalHue(num v);
 /// Gets the global Density value.
 /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
 /// Values less than zero provide a filter of opposite hue.
 /// Sets the global Density value.
 /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
 /// Values less than zero provide a filter of opposite hue.
 external num get globalDensity; external set globalDensity(num v);
 /// Gets the global Saturation value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
 /// Sets the global Saturation value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
 external num get globalSaturation; external set globalSaturation(num v); external get JS$_highlightsHue; external set JS$_highlightsHue(v); external get JS$_highlightsDensity; external set JS$_highlightsDensity(v); external get JS$_highlightsSaturation; external set JS$_highlightsSaturation(v); external get JS$_highlightsExposure; external set JS$_highlightsExposure(v);
 /// Gets the highlights Hue value.
 /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
 /// Sets the highlights Hue value.
 /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
 external num get highlightsHue; external set highlightsHue(num v);
 /// Gets the highlights Density value.
 /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
 /// Values less than zero provide a filter of opposite hue.
 /// Sets the highlights Density value.
 /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
 /// Values less than zero provide a filter of opposite hue.
 external num get highlightsDensity; external set highlightsDensity(num v);
 /// Gets the highlights Saturation value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
 /// Sets the highlights Saturation value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
 external num get highlightsSaturation; external set highlightsSaturation(num v);
 /// Gets the highlights Exposure value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
 /// Sets the highlights Exposure value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
 external num get highlightsExposure; external set highlightsExposure(num v); external get JS$_midtonesHue; external set JS$_midtonesHue(v); external get JS$_midtonesDensity; external set JS$_midtonesDensity(v); external get JS$_midtonesSaturation; external set JS$_midtonesSaturation(v); external get JS$_midtonesExposure; external set JS$_midtonesExposure(v);
 /// Gets the midtones Hue value.
 /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
 /// Sets the midtones Hue value.
 /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
 external num get midtonesHue; external set midtonesHue(num v);
 /// Gets the midtones Density value.
 /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
 /// Values less than zero provide a filter of opposite hue.
 /// Sets the midtones Density value.
 /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
 /// Values less than zero provide a filter of opposite hue.
 external num get midtonesDensity; external set midtonesDensity(num v);
 /// Gets the midtones Saturation value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
 /// Sets the midtones Saturation value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
 external num get midtonesSaturation; external set midtonesSaturation(num v);
 /// Gets the midtones Exposure value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
 /// Sets the midtones Exposure value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
 external num get midtonesExposure; external set midtonesExposure(num v); external get JS$_shadowsHue; external set JS$_shadowsHue(v); external get JS$_shadowsDensity; external set JS$_shadowsDensity(v); external get JS$_shadowsSaturation; external set JS$_shadowsSaturation(v); external get JS$_shadowsExposure; external set JS$_shadowsExposure(v);
 /// Gets the shadows Hue value.
 /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
 /// Sets the shadows Hue value.
 /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
 external num get shadowsHue; external set shadowsHue(num v);
 /// Gets the shadows Density value.
 /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
 /// Values less than zero provide a filter of opposite hue.
 /// Sets the shadows Density value.
 /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
 /// Values less than zero provide a filter of opposite hue.
 external num get shadowsDensity; external set shadowsDensity(num v);
 /// Gets the shadows Saturation value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
 /// Sets the shadows Saturation value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
 external num get shadowsSaturation; external set shadowsSaturation(num v);
 /// Gets the shadows Exposure value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
 /// Sets the shadows Exposure value.
 /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
 external num get shadowsExposure; external set shadowsExposure(num v); external String getClassName();
 /// Binds the color curves to the shader.
 external static void Bind(ColorCurves colorCurves, Effect effect, [String positiveUniform, String neutralUniform, String negativeUniform]);
 /// Prepare the list of uniforms associated with the ColorCurves effects.
 external static void PrepareUniforms(List<String> uniformsList);
 /// Returns color grading data based on a hue, density, saturation and exposure value.
 external getColorGradingDataToRef(hue, density, saturation, exposure, result);
 /// Takes an input slider value and returns an adjusted value that provides extra control near the centre.
 external static applyColorGradingSliderNonlinear(value);
 /// Returns an RGBA Color4 based on Hue, Saturation and Brightness (also referred to as value, HSV).
 /// @result An RGBA color represented as Vector4.
 external static fromHSBToRef(hue, saturation, brightness, result);
 /// Returns a value clamped between min and max
 external static clamp(value, min, max);
 /// Clones the current color curve instance.
 external ColorCurves clone();
 /// Serializes the current color curve instance to a json representation.
 external dynamic serialize();
 /// Parses the color curve from a json representation.
 external static ColorCurves Parse(dynamic source); }

 /// EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.
 /// (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)
 @JS("BABYLON.EffectFallbacks" ) class EffectFallbacks { // @Ignore
 EffectFallbacks .fakeConstructor$() ;
 external get JS$_defines; external set JS$_defines(v); external get JS$_currentRank; external set JS$_currentRank(v); external get JS$_maxRank; external set JS$_maxRank(v); external get JS$_mesh; external set JS$_mesh(v);
 /// Removes the fallback from the bound mesh.
 external void unBindMesh();
 /// Adds a fallback on the specified property.
 external void addFallback(num rank, String define);
 /// Sets the mesh to use CPU skinning when needing to fallback.
 external void addCPUSkinningFallback(num rank, AbstractMesh mesh);
 /// Checks to see if more fallbacks are still availible.
 external bool get isMoreFallbacks; external set isMoreFallbacks(bool v);
 /// Removes the defines that shoould be removed when falling back.
 external String reduce(String currentDefines, Effect effect); }

 /// Options to be used when creating an effect.
 @JS("BABYLON.EffectCreationOptions" ) class EffectCreationOptions { // @Ignore
 EffectCreationOptions .fakeConstructor$() ;
 /// Atrributes that will be used in the shader.
 external List<String> get attributes; external set attributes(List<String> v);
 /// Uniform varible names that will be set in the shader.
 external List<String> get uniformsNames; external set uniformsNames(List<String> v);
 /// Uniform buffer varible names that will be set in the shader.
 external List<String> get uniformBuffersNames; external set uniformBuffersNames(List<String> v);
 /// Sampler texture variable names that will be set in the shader.
 external List<String> get samplers; external set samplers(List<String> v);
 /// Define statements that will be set in the shader.
 external dynamic get defines; external set defines(dynamic v);
 /// Possible fallbacks for this effect to improve performance when needed.
 external EffectFallbacks/*EffectFallbacks|Null*/ get fallbacks; external set fallbacks(EffectFallbacks/*EffectFallbacks|Null*/ v);
 /// Callback that will be called when the shader is compiled.
 external VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ get onCompiled; external set onCompiled(VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ v);
 /// Callback that will be called if an error occurs during shader compilation.
 external VoidFunc2<Effect, String>/*VoidFunc2<Effect, String>|Null*/ get onError; external set onError(VoidFunc2<Effect, String>/*VoidFunc2<Effect, String>|Null*/ v);
 /// Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})
 external dynamic get indexParameters; external set indexParameters(dynamic v);
 /// Max number of lights that can be used in the shader.
 external num get maxSimultaneousLights; external set maxSimultaneousLights(num v);
 /// See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings
 external List<String>/*List<String>|Null*/ get transformFeedbackVaryings; external set transformFeedbackVaryings(List<String>/*List<String>|Null*/ v); }

 /// Effect containing vertex and fragment shader that can be executed on an object.
 @JS("BABYLON.Effect" ) class Effect { // @Ignore
 Effect .fakeConstructor$() ;
 /// Name of the effect.
 external dynamic get name; external set name(dynamic v);
 /// String container all the define statements that should be set on the shader.
 external String get defines; external set defines(String v);
 /// Callback that will be called when the shader is compiled.
 external VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ get onCompiled; external set onCompiled(VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ v);
 /// Callback that will be called if an error occurs during shader compilation.
 external VoidFunc2<Effect, String>/*VoidFunc2<Effect, String>|Null*/ get onError; external set onError(VoidFunc2<Effect, String>/*VoidFunc2<Effect, String>|Null*/ v);
 /// Callback that will be called when effect is bound.
 external VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ get onBind; external set onBind(VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ v);
 /// Unique ID of the effect.
 external num get uniqueId; external set uniqueId(num v);
 /// Observable that will be called when the shader is compiled.
 external Observable<Effect> get onCompileObservable; external set onCompileObservable(Observable<Effect> v);
 /// Observable that will be called if an error occurs during shader compilation.
 external Observable<Effect> get onErrorObservable; external set onErrorObservable(Observable<Effect> v);
 /// Observable that will be called when effect is bound.
 external Observable<Effect> get onBindObservable; external set onBindObservable(Observable<Effect> v);
 /// @hidden
 external bool get JS$_bonesComputationForcedToCPU; external set JS$_bonesComputationForcedToCPU(bool v); external static get JS$_uniqueIdSeed; external static set JS$_uniqueIdSeed(v); external get JS$_engine; external set JS$_engine(v); external get JS$_uniformBuffersNames; external set JS$_uniformBuffersNames(v); external get JS$_uniformsNames; external set JS$_uniformsNames(v); external get JS$_samplers; external set JS$_samplers(v); external get JS$_isReady; external set JS$_isReady(v); external get JS$_compilationError; external set JS$_compilationError(v); external get JS$_attributesNames; external set JS$_attributesNames(v); external get JS$_attributes; external set JS$_attributes(v); external get JS$_uniforms; external set JS$_uniforms(v);
 /// Key for the effect.
 external String get JS$_key; external set JS$_key(String v); external get JS$_indexParameters; external set JS$_indexParameters(v); external get JS$_fallbacks; external set JS$_fallbacks(v); external get JS$_vertexSourceCode; external set JS$_vertexSourceCode(v); external get JS$_fragmentSourceCode; external set JS$_fragmentSourceCode(v); external get JS$_vertexSourceCodeOverride; external set JS$_vertexSourceCodeOverride(v); external get JS$_fragmentSourceCodeOverride; external set JS$_fragmentSourceCodeOverride(v); external get JS$_transformFeedbackVaryings; external set JS$_transformFeedbackVaryings(v);
 /// Compiled shader to webGL program.
 external Program get JS$_program; external set JS$_program(Program v); external get JS$_valueCache; external set JS$_valueCache(v); external static get JS$_baseCache; external static set JS$_baseCache(v);
 /// Instantiates an effect.
 /// An effect can be used to create/manage/execute vertex and fragment shaders.
 external factory Effect(dynamic baseName, dynamic/*List<String>|EffectCreationOptions*/ attributesNamesOrOptions, dynamic/*List<String>|Engine*/ uniformsNamesOrEngine, [List<String>/*List<String>|Null*/ samplers, Engine engine, String/*String|Null*/ defines, EffectFallbacks/*EffectFallbacks|Null*/ fallbacks, VoidFunc1<Effect>/*VoidFunc1<Effect>|Null*/ onCompiled, VoidFunc2<Effect, String>/*VoidFunc2<Effect, String>|Null*/ onError, dynamic indexParameters]);
 /// Unique key for this effect
 external String get key; external set key(String v);
 /// If the effect has been compiled and prepared.
 external bool isReady();
 /// The engine the effect was initialized with.
 external Engine getEngine();
 /// The compiled webGL program for the effect
 external Program getProgram();
 /// The set of names of attribute variables for the shader.
 external List<String> getAttributesNames();
 /// Returns the attribute at the given index.
 external num getAttributeLocation(num index);
 /// Returns the attribute based on the name of the variable.
 external num getAttributeLocationByName(String name);
 /// The number of attributes.
 external num getAttributesCount();
 /// Gets the index of a uniform variable.
 external num getUniformIndex(String uniformName);
 /// Returns the attribute based on the name of the variable.
 external UniformLocation/*UniformLocation|Null*/ getUniform(String uniformName);
 /// Returns an array of sampler variable names
 external List<String> getSamplers();
 /// The error from the last compilation.
 external String getCompilationError();
 /// Adds a callback to the onCompiled observable and call the callback imediatly if already ready.
 external void executeWhenCompiled(void func(Effect effect));
 /// @hidden
 external void JS$_loadVertexShader(dynamic vertex, void callback(dynamic data));
 /// @hidden
 external void JS$_loadFragmentShader(dynamic fragment, void callback(dynamic data)); external JS$_dumpShadersSource(vertexCode, fragmentCode, defines); external JS$_processShaderConversion(sourceCode, isFragment, callback); external JS$_processIncludes(sourceCode, callback); external JS$_processPrecision(source);
 /// Recompiles the webGL program
 external void JS$_rebuildProgram(String vertexSourceCode, String fragmentSourceCode, void onCompiled(Program program), void onError(String message));
 /// Gets the uniform locations of the the specified variable names
 external List<UniformLocation/*UniformLocation|Null*/> getSpecificUniformLocations(List<String> names);
 /// Prepares the effect
 external void JS$_prepareEffect();
 /// Checks if the effect is supported. (Must be called after compilation)
 external bool get isSupported; external set isSupported(bool v);
 /// Binds a texture to the engine to be used as output of the shader.
 external void JS$_bindTexture(String channel, InternalTexture texture);
 /// Sets a texture on the engine to be used in the shader.
 external void setTexture(String channel, BaseTexture/*BaseTexture|Null*/ texture);
 /// Sets a depth stencil texture from a render target on the engine to be used in the shader.
 external void setDepthStencilTexture(String channel, RenderTargetTexture/*RenderTargetTexture|Null*/ texture);
 /// Sets an array of textures on the engine to be used in the shader.
 external void setTextureArray(String channel, List<BaseTexture> textures);
 /// Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)
 external void setTextureFromPostProcess(String channel, PostProcess/*PostProcess|Null*/ postProcess);
 /// (Warning! setTextureFromPostProcessOutput may be desired instead)
 /// Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)
 external void setTextureFromPostProcessOutput(String channel, PostProcess/*PostProcess|Null*/ postProcess);
 /// @hidden
 external bool JS$_cacheMatrix(String uniformName, Matrix matrix);
 /// @hidden
 external bool JS$_cacheFloat2(String uniformName, num x, num y);
 /// @hidden
 external bool JS$_cacheFloat3(String uniformName, num x, num y, num z);
 /// @hidden
 external bool JS$_cacheFloat4(String uniformName, num x, num y, num z, num w);
 /// Binds a buffer to a uniform.
 external void bindUniformBuffer(Buffer buffer, String name);
 /// Binds block to a uniform.
 external void bindUniformBlock(String blockName, num index);
 /// Sets an interger value on a uniform variable.
 external Effect setInt(String uniformName, num value);
 /// Sets an int array on a uniform variable.
 external Effect setIntArray(String uniformName, Int32List array);
 /// Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
 external Effect setIntArray2(String uniformName, Int32List array);
 /// Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
 external Effect setIntArray3(String uniformName, Int32List array);
 /// Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
 external Effect setIntArray4(String uniformName, Int32List array);
 /// Sets an float array on a uniform variable.
 external Effect setFloatArray(String uniformName, Float32List array);
 /// Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
 external Effect setFloatArray2(String uniformName, Float32List array);
 /// Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
 external Effect setFloatArray3(String uniformName, Float32List array);
 /// Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
 external Effect setFloatArray4(String uniformName, Float32List array);
 /// Sets an array on a uniform variable.
 external Effect setArray(String uniformName, List<num> array);
 /// Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
 external Effect setArray2(String uniformName, List<num> array);
 /// Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
 external Effect setArray3(String uniformName, List<num> array);
 /// Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
 external Effect setArray4(String uniformName, List<num> array);
 /// Sets matrices on a uniform variable.
 external Effect setMatrices(String uniformName, Float32List matrices);
 /// Sets matrix on a uniform variable.
 external Effect setMatrix(String uniformName, Matrix matrix);
 /// Sets a 3x3 matrix on a uniform variable. (Speicified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)
 external Effect setMatrix3x3(String uniformName, Float32List matrix);
 /// Sets a 2x2 matrix on a uniform variable. (Speicified as [1,2,3,4] will result in [1,2][3,4] matrix)
 external Effect setMatrix2x2(String uniformName, Float32List matrix);
 /// Sets a float on a uniform variable.
 external Effect setFloat(String uniformName, num value);
 /// Sets a boolean on a uniform variable.
 external Effect setBool(String uniformName, bool bool);
 /// Sets a Vector2 on a uniform variable.
 external Effect setVector2(String uniformName, Vector2 vector2);
 /// Sets a float2 on a uniform variable.
 external Effect setFloat2(String uniformName, num x, num y);
 /// Sets a Vector3 on a uniform variable.
 external Effect setVector3(String uniformName, Vector3 vector3);
 /// Sets a float3 on a uniform variable.
 external Effect setFloat3(String uniformName, num x, num y, num z);
 /// Sets a Vector4 on a uniform variable.
 external Effect setVector4(String uniformName, Vector4 vector4);
 /// Sets a float4 on a uniform variable.
 external Effect setFloat4(String uniformName, num x, num y, num z, num w);
 /// Sets a Color3 on a uniform variable.
 external Effect setColor3(String uniformName, Color3 color3);
 /// Sets a Color4 on a uniform variable.
 external Effect setColor4(String uniformName, Color3 color3, num alpha);
 /// Sets a Color4 on a uniform variable
 external Effect setDirectColor4(String uniformName, Color4 color4);
 /// Store of each shader (The can be looked up using effect.key)
 external static dynamic/*JSMap of <String,String>*/ get ShadersStore; external static set ShadersStore(dynamic/*JSMap of <String,String>*/ v);
 /// Store of each included file for a shader (The can be looked up using effect.key)
 external static dynamic/*JSMap of <String,String>*/ get IncludesShadersStore; external static set IncludesShadersStore(dynamic/*JSMap of <String,String>*/ v);
 /// Resets the cache of effects.
 external static void ResetCache(); }

 @JS("BABYLON.FresnelParameters" ) class FresnelParameters { // @Ignore
 FresnelParameters .fakeConstructor$() ;
 external get JS$_isEnabled; external set JS$_isEnabled(v); external bool get isEnabled; external set isEnabled(bool v); external Color3 get leftColor; external set leftColor(Color3 v); external Color3 get rightColor; external set rightColor(Color3 v); external num get bias; external set bias(num v); external num get power; external set power(num v); external FresnelParameters clone(); external dynamic serialize(); external static FresnelParameters Parse(dynamic parsedFresnelParameters); }

 /// Interface to follow in your material defines to integrate easily the
 /// Image proccessing functions.
 /// @hidden
 @anonymous @JS() abstract class IImageProcessingConfigurationDefines { external bool get IMAGEPROCESSING; external set IMAGEPROCESSING(bool v); external bool get VIGNETTE; external set VIGNETTE(bool v); external bool get VIGNETTEBLENDMODEMULTIPLY; external set VIGNETTEBLENDMODEMULTIPLY(bool v); external bool get VIGNETTEBLENDMODEOPAQUE; external set VIGNETTEBLENDMODEOPAQUE(bool v); external bool get TONEMAPPING; external set TONEMAPPING(bool v); external bool get CONTRAST; external set CONTRAST(bool v); external bool get EXPOSURE; external set EXPOSURE(bool v); external bool get COLORCURVES; external set COLORCURVES(bool v); external bool get COLORGRADING; external set COLORGRADING(bool v); external bool get COLORGRADING3D; external set COLORGRADING3D(bool v); external bool get SAMPLER3DGREENDEPTH; external set SAMPLER3DGREENDEPTH(bool v); external bool get SAMPLER3DBGRMAP; external set SAMPLER3DBGRMAP(bool v); external bool get IMAGEPROCESSINGPOSTPROCESS; external set IMAGEPROCESSINGPOSTPROCESS(bool v); external factory IImageProcessingConfigurationDefines({ bool IMAGEPROCESSING, bool VIGNETTE, bool VIGNETTEBLENDMODEMULTIPLY, bool VIGNETTEBLENDMODEOPAQUE, bool TONEMAPPING, bool CONTRAST, bool EXPOSURE, bool COLORCURVES, bool COLORGRADING, bool COLORGRADING3D, bool SAMPLER3DGREENDEPTH, bool SAMPLER3DBGRMAP, bool IMAGEPROCESSINGPOSTPROCESS}); }

 /// This groups together the common properties used for image processing either in direct forward pass
 /// or through post processing effect depending on the use of the image processing pipeline in your scene
 /// or not.
 @JS("BABYLON.ImageProcessingConfiguration" ) class ImageProcessingConfiguration { // @Ignore
 ImageProcessingConfiguration .fakeConstructor$() ;
 /// Color curves setup used in the effect if colorCurvesEnabled is set to true
 external ColorCurves/*ColorCurves|Null*/ get colorCurves; external set colorCurves(ColorCurves/*ColorCurves|Null*/ v); external get JS$_colorCurvesEnabled; external set JS$_colorCurvesEnabled(v);
 /// Gets wether the color curves effect is enabled.
 /// Sets wether the color curves effect is enabled.
 external bool get colorCurvesEnabled; external set colorCurvesEnabled(bool v);
 /// Color grading LUT texture used in the effect if colorGradingEnabled is set to true
 external BaseTexture/*BaseTexture|Null*/ get colorGradingTexture; external set colorGradingTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_colorGradingEnabled; external set JS$_colorGradingEnabled(v);
 /// Gets wether the color grading effect is enabled.
 /// Sets wether the color grading effect is enabled.
 external bool get colorGradingEnabled; external set colorGradingEnabled(bool v); external get JS$_colorGradingWithGreenDepth; external set JS$_colorGradingWithGreenDepth(v);
 /// Gets wether the color grading effect is using a green depth for the 3d Texture.
 /// Sets wether the color grading effect is using a green depth for the 3d Texture.
 external bool get colorGradingWithGreenDepth; external set colorGradingWithGreenDepth(bool v); external get JS$_colorGradingBGR; external set JS$_colorGradingBGR(v);
 /// Gets wether the color grading texture contains BGR values.
 /// Sets wether the color grading texture contains BGR values.
 external bool get colorGradingBGR; external set colorGradingBGR(bool v); external num get JS$_exposure; external set JS$_exposure(num v);
 /// Gets the Exposure used in the effect.
 /// Sets the Exposure used in the effect.
 external num get exposure; external set exposure(num v); external get JS$_toneMappingEnabled; external set JS$_toneMappingEnabled(v);
 /// Gets wether the tone mapping effect is enabled.
 /// Sets wether the tone mapping effect is enabled.
 external bool get toneMappingEnabled; external set toneMappingEnabled(bool v); external num get JS$_contrast; external set JS$_contrast(num v);
 /// Gets the contrast used in the effect.
 /// Sets the contrast used in the effect.
 external num get contrast; external set contrast(num v);
 /// Vignette stretch size.
 external num get vignetteStretch; external set vignetteStretch(num v);
 /// Vignette centre X Offset.
 external num get vignetteCentreX; external set vignetteCentreX(num v);
 /// Vignette centre Y Offset.
 external num get vignetteCentreY; external set vignetteCentreY(num v);
 /// Vignette weight or intensity of the vignette effect.
 external num get vignetteWeight; external set vignetteWeight(num v);
 /// Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
 /// if vignetteEnabled is set to true.
 external Color4 get vignetteColor; external set vignetteColor(Color4 v);
 /// Camera field of view used by the Vignette effect.
 external num get vignetteCameraFov; external set vignetteCameraFov(num v); external get JS$_vignetteBlendMode; external set JS$_vignetteBlendMode(v);
 /// Gets the vignette blend mode allowing different kind of effect.
 /// Sets the vignette blend mode allowing different kind of effect.
 external num get vignetteBlendMode; external set vignetteBlendMode(num v); external get JS$_vignetteEnabled; external set JS$_vignetteEnabled(v);
 /// Gets wether the vignette effect is enabled.
 /// Sets wether the vignette effect is enabled.
 external bool get vignetteEnabled; external set vignetteEnabled(bool v); external get JS$_applyByPostProcess; external set JS$_applyByPostProcess(v);
 /// Gets wether the image processing is applied through a post process or not.
 /// Sets wether the image processing is applied through a post process or not.
 external bool get applyByPostProcess; external set applyByPostProcess(bool v); external get JS$_isEnabled; external set JS$_isEnabled(v);
 /// Gets wether the image processing is enabled or not.
 /// Sets wether the image processing is enabled or not.
 external bool get isEnabled; external set isEnabled(bool v);
 /// An event triggered when the configuration changes and requires Shader to Update some parameters.
 external Observable<ImageProcessingConfiguration> get onUpdateParameters; external set onUpdateParameters(Observable<ImageProcessingConfiguration> v);
 /// Method called each time the image processing information changes requires to recompile the effect.
 external void JS$_updateParameters(); external String getClassName();
 /// Prepare the list of uniforms associated with the Image Processing effects.
 external static void PrepareUniforms(List<String> uniforms, IImageProcessingConfigurationDefines defines);
 /// Prepare the list of samplers associated with the Image Processing effects.
 external static void PrepareSamplers(List<String> samplersList, IImageProcessingConfigurationDefines defines);
 /// Prepare the list of defines associated to the shader.
 external void prepareDefines(IImageProcessingConfigurationDefines defines, [bool forPostProcess]);
 /// Returns true if all the image processing information are ready.
 external bool isReady();
 /// Binds the image processing to the shader.
 external void bind(Effect effect, [num aspectRatio]);
 /// Clones the current image processing instance.
 external ImageProcessingConfiguration clone();
 /// Serializes the current image processing instance to a json representation.
 external dynamic serialize();
 /// Parses the image processing from a json representation.
 external static ImageProcessingConfiguration Parse(dynamic source); external static get JS$_VIGNETTEMODE_MULTIPLY; external static set JS$_VIGNETTEMODE_MULTIPLY(v); external static get JS$_VIGNETTEMODE_OPAQUE; external static set JS$_VIGNETTEMODE_OPAQUE(v);
 /// Used to apply the vignette as a mix with the pixel color.
 external static num get VIGNETTEMODE_MULTIPLY; external static set VIGNETTEMODE_MULTIPLY(num v);
 /// Used to apply the vignette as a replacement of the pixel color.
 external static num get VIGNETTEMODE_OPAQUE; external static set VIGNETTEMODE_OPAQUE(num v); }

 /// Manages the defines for the Material
 @JS("BABYLON.MaterialDefines" ) class MaterialDefines { // @Ignore
 MaterialDefines .fakeConstructor$() ;
 external get JS$_keys; external set JS$_keys(v); external get JS$_isDirty; external set JS$_isDirty(v);
 /// @hidden
 external num get JS$_renderId; external set JS$_renderId(num v);
 /// @hidden
 external bool get JS$_areLightsDirty; external set JS$_areLightsDirty(bool v);
 /// @hidden
 external bool get JS$_areAttributesDirty; external set JS$_areAttributesDirty(bool v);
 /// @hidden
 external bool get JS$_areTexturesDirty; external set JS$_areTexturesDirty(bool v);
 /// @hidden
 external bool get JS$_areFresnelDirty; external set JS$_areFresnelDirty(bool v);
 /// @hidden
 external bool get JS$_areMiscDirty; external set JS$_areMiscDirty(bool v);
 /// @hidden
 external bool get JS$_areImageProcessingDirty; external set JS$_areImageProcessingDirty(bool v);
 /// @hidden
 external bool get JS$_normals; external set JS$_normals(bool v);
 /// @hidden
 external bool get JS$_uvs; external set JS$_uvs(bool v);
 /// @hidden
 external bool get JS$_needNormals; external set JS$_needNormals(bool v);
 /// @hidden
 external bool get JS$_needUVs; external set JS$_needUVs(bool v);
 /// Specifies if the material needs to be re-calculated
 external bool get isDirty; external set isDirty(bool v);
 /// Marks the material to indicate that it has been re-calculated
 external void markAsProcessed();
 /// Marks the material to indicate that it needs to be re-calculated
 external void markAsUnprocessed();
 /// Marks the material to indicate all of its defines need to be re-calculated
 external void markAllAsDirty();
 /// Marks the material to indicate that image processing needs to be re-calculated
 external void markAsImageProcessingDirty();
 /// Marks the material to indicate the lights need to be re-calculated
 external void markAsLightDirty();
 /// Marks the attribute state as changed
 external void markAsAttributesDirty();
 /// Marks the texture state as changed
 external void markAsTexturesDirty();
 /// Marks the fresnel state as changed
 external void markAsFresnelDirty();
 /// Marks the misc state as changed
 external void markAsMiscDirty();
 /// Rebuilds the material defines
 external void rebuild();
 /// Specifies if two material defines are equal
 external bool isEqual(MaterialDefines other);
 /// Clones this instance's defines to another instance
 external void cloneTo(MaterialDefines other);
 /// Resets the material define values
 external void reset();
 /// Converts the material define values to a string
 external String toString(); }

 /// Base class for the main features of a material in Babylon.js
 @JS("BABYLON.Material" ) class Material implements IAnimatable { // @Ignore
 Material .fakeConstructor$() ;
 external static get JS$_TriangleFillMode; external static set JS$_TriangleFillMode(v); external static get JS$_WireFrameFillMode; external static set JS$_WireFrameFillMode(v); external static get JS$_PointFillMode; external static set JS$_PointFillMode(v); external static get JS$_PointListDrawMode; external static set JS$_PointListDrawMode(v); external static get JS$_LineListDrawMode; external static set JS$_LineListDrawMode(v); external static get JS$_LineLoopDrawMode; external static set JS$_LineLoopDrawMode(v); external static get JS$_LineStripDrawMode; external static set JS$_LineStripDrawMode(v); external static get JS$_TriangleStripDrawMode; external static set JS$_TriangleStripDrawMode(v); external static get JS$_TriangleFanDrawMode; external static set JS$_TriangleFanDrawMode(v);
 /// Returns the triangle fill mode
 external static num get TriangleFillMode; external static set TriangleFillMode(num v);
 /// Returns the wireframe mode
 external static num get WireFrameFillMode; external static set WireFrameFillMode(num v);
 /// Returns the point fill mode
 external static num get PointFillMode; external static set PointFillMode(num v);
 /// Returns the point list draw mode
 external static num get PointListDrawMode; external static set PointListDrawMode(num v);
 /// Returns the line list draw mode
 external static num get LineListDrawMode; external static set LineListDrawMode(num v);
 /// Returns the line loop draw mode
 external static num get LineLoopDrawMode; external static set LineLoopDrawMode(num v);
 /// Returns the line strip draw mode
 external static num get LineStripDrawMode; external static set LineStripDrawMode(num v);
 /// Returns the triangle strip draw mode
 external static num get TriangleStripDrawMode; external static set TriangleStripDrawMode(num v);
 /// Returns the triangle fan draw mode
 external static num get TriangleFanDrawMode; external static set TriangleFanDrawMode(num v);
 /// Stores the clock-wise side orientation
 external static get JS$_ClockWiseSideOrientation; external static set JS$_ClockWiseSideOrientation(v);
 /// Stores the counter clock-wise side orientation
 external static get JS$_CounterClockWiseSideOrientation; external static set JS$_CounterClockWiseSideOrientation(v);
 /// Returns the clock-wise side orientation
 external static num get ClockWiseSideOrientation; external static set ClockWiseSideOrientation(num v);
 /// Returns the counter clock-wise side orientation
 external static num get CounterClockWiseSideOrientation; external static set CounterClockWiseSideOrientation(num v);
 /// The dirty texture flag value
 external static get JS$_TextureDirtyFlag; external static set JS$_TextureDirtyFlag(v);
 /// The dirty light flag value
 external static get JS$_LightDirtyFlag; external static set JS$_LightDirtyFlag(v);
 /// The dirty fresnel flag value
 external static get JS$_FresnelDirtyFlag; external static set JS$_FresnelDirtyFlag(v);
 /// The dirty attribute flag value
 external static get JS$_AttributesDirtyFlag; external static set JS$_AttributesDirtyFlag(v);
 /// The dirty misc flag value
 external static get JS$_MiscDirtyFlag; external static set JS$_MiscDirtyFlag(v);
 /// Returns the dirty texture flag value
 external static num get TextureDirtyFlag; external static set TextureDirtyFlag(num v);
 /// Returns the dirty light flag value
 external static num get LightDirtyFlag; external static set LightDirtyFlag(num v);
 /// Returns the dirty fresnel flag value
 external static num get FresnelDirtyFlag; external static set FresnelDirtyFlag(num v);
 /// Returns the dirty attributes flag value
 external static num get AttributesDirtyFlag; external static set AttributesDirtyFlag(num v);
 /// Returns the dirty misc flag value
 external static num get MiscDirtyFlag; external static set MiscDirtyFlag(num v);
 /// The ID of the material
 external String get id; external set id(String v);
 /// The name of the material
 external String get name; external set name(String v);
 /// Specifies if the ready state should be checked on each call
 external bool get checkReadyOnEveryCall; external set checkReadyOnEveryCall(bool v);
 /// Specifies if the ready state should be checked once
 external bool get checkReadyOnlyOnce; external set checkReadyOnlyOnce(bool v);
 /// The state of the material
 external String get state; external set state(String v);
 /// The alpha value of the material
 external num get JS$_alpha; external set JS$_alpha(num v);
 /// Gets the alpha value of the material
 /// Sets the alpha value of the material
 external num get alpha; external set alpha(num v);
 /// Specifies if back face culling is enabled
 external bool get JS$_backFaceCulling; external set JS$_backFaceCulling(bool v);
 /// Gets the back-face culling state
 /// Sets the back-face culling state
 external bool get backFaceCulling; external set backFaceCulling(bool v);
 /// Stores the value for side orientation
 external num get sideOrientation; external set sideOrientation(num v);
 /// Callback triggered when the material is compiled
 external VoidFunc1<Effect> get onCompiled; external set onCompiled(VoidFunc1<Effect> v);
 /// Callback triggered when an error occurs
 external VoidFunc2<Effect, String> get onError; external set onError(VoidFunc2<Effect, String> v);
 /// Callback triggered to get the render target textures
 external Func0<SmartArray<RenderTargetTexture>> get getRenderTargetTextures; external set getRenderTargetTextures(Func0<SmartArray<RenderTargetTexture>> v);
 /// Specifies if the material should be serialized
 external bool get doNotSerialize; external set doNotSerialize(bool v);
 /// Specifies if the effect should be stored on sub meshes
 external bool get storeEffectOnSubMeshes; external set storeEffectOnSubMeshes(bool v);
 /// Stores the animations for the material
 external List<Animation> get animations; external set animations(List<Animation> v);
 /// An event triggered when the material is disposed
 external Observable<Material> get onDisposeObservable; external set onDisposeObservable(Observable<Material> v);
 /// An observer which watches for dispose events
 external get JS$_onDisposeObserver; external set JS$_onDisposeObserver(v);
 /// Called during a dispose event
 external VoidFunc0 get onDispose; external set onDispose(VoidFunc0 v);
 /// An event triggered when the material is bound
 external Observable<AbstractMesh> get onBindObservable; external set onBindObservable(Observable<AbstractMesh> v);
 /// An observer which watches for bind events
 external get JS$_onBindObserver; external set JS$_onBindObserver(v);
 /// Called during a bind event
 external VoidFunc1<AbstractMesh> get onBind; external set onBind(VoidFunc1<AbstractMesh> v);
 /// An event triggered when the material is unbound
 external Observable<Material> get onUnBindObservable; external set onUnBindObservable(Observable<Material> v);
 /// Stores the value of the alpha mode
 external get JS$_alphaMode; external set JS$_alphaMode(v);
 /// Gets the value of the alpha mode
 /// Sets the value of the alpha mode.
 /// | Value | Type | Description |
 /// | --- | --- | --- |
 /// | 0 | ALPHA_DISABLE |   |
 /// | 1 | ALPHA_ADD |   |
 /// | 2 | ALPHA_COMBINE |   |
 /// | 3 | ALPHA_SUBTRACT |   |
 /// | 4 | ALPHA_MULTIPLY |   |
 /// | 5 | ALPHA_MAXIMIZED |   |
 /// | 6 | ALPHA_ONEONE |   |
 /// | 7 | ALPHA_PREMULTIPLIED |   |
 /// | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |
 /// | 9 | ALPHA_INTERPOLATE |   |
 /// | 10 | ALPHA_SCREENMODE |   |
 external num get alphaMode; external set alphaMode(num v);
 /// Stores the state of the need depth pre-pass value
 external get JS$_needDepthPrePass; external set JS$_needDepthPrePass(v);
 /// Gets the depth pre-pass value
 /// Sets the need depth pre-pass value
 external bool get needDepthPrePass; external set needDepthPrePass(bool v);
 /// Specifies if depth writing should be disabled
 external bool get disableDepthWrite; external set disableDepthWrite(bool v);
 /// Specifies if depth writing should be forced
 external bool get forceDepthWrite; external set forceDepthWrite(bool v);
 /// Specifies if there should be a separate pass for culling
 external bool get separateCullingPass; external set separateCullingPass(bool v);
 /// Stores the state specifing if fog should be enabled
 external get JS$_fogEnabled; external set JS$_fogEnabled(v);
 /// Gets the value of the fog enabled state
 /// Sets the state for enabling fog
 external bool get fogEnabled; external set fogEnabled(bool v);
 /// Stores the size of points
 external num get pointSize; external set pointSize(num v);
 /// Stores the z offset value
 external num get zOffset; external set zOffset(num v);
 /// Gets a value specifying if wireframe mode is enabled
 /// Sets the state of wireframe mode
 external bool get wireframe; external set wireframe(bool v);
 /// Gets the value specifying if point clouds are enabled
 /// Sets the state of point cloud mode
 external bool get pointsCloud; external set pointsCloud(bool v);
 /// Gets the material fill mode
 /// Sets the material fill mode
 external num get fillMode; external set fillMode(num v);
 /// Stores the effects for the material
 external Effect/*Effect|Null*/ get JS$_effect; external set JS$_effect(Effect/*Effect|Null*/ v);
 /// Specifies if the material was previously ready
 external bool get JS$_wasPreviouslyReady; external set JS$_wasPreviouslyReady(bool v);
 /// Specifies if uniform buffers should be used
 external get JS$_useUBO; external set JS$_useUBO(v);
 /// Stores a reference to the scene
 external get JS$_scene; external set JS$_scene(v);
 /// Stores the fill mode state
 external get JS$_fillMode; external set JS$_fillMode(v);
 /// Specifies if the depth write state should be cached
 external get JS$_cachedDepthWriteState; external set JS$_cachedDepthWriteState(v);
 /// Stores the uniform buffer
 external UniformBuffer get JS$_uniformBuffer; external set JS$_uniformBuffer(UniformBuffer v);
 /// Creates a material instance
 external factory Material(String name, Scene scene, [bool doNotAdd]);
 /// Returns a string representation of the current material
 external String toString([bool fullDetails]);
 /// Gets the class name of the material
 external String getClassName();
 /// Specifies if updates for the material been locked
 external bool get isFrozen; external set isFrozen(bool v);
 /// Locks updates for the material
 external void freeze();
 /// Unlocks updates for the material
 external void unfreeze();
 /// Specifies if the material is ready to be used
 external bool isReady([AbstractMesh mesh, bool useInstances]);
 /// Specifies that the submesh is ready to be used
 external bool isReadyForSubMesh(AbstractMesh mesh, BaseSubMesh subMesh, [bool useInstances]);
 /// Returns the material effect
 external Effect/*Effect|Null*/ getEffect();
 /// Returns the current scene
 external Scene getScene();
 /// Specifies if the material will require alpha blending
 external bool needAlphaBlending();
 /// Specifies if the mesh will require alpha blending
 external bool needAlphaBlendingForMesh(AbstractMesh mesh);
 /// Specifies if this material should be rendered in alpha test mode
 external bool needAlphaTesting();
 /// Gets the texture used for the alpha test
 external BaseTexture/*BaseTexture|Null*/ getAlphaTestTexture();
 /// Marks the material to indicate that it needs to be re-calculated
 external void markDirty();
 /// @hidden
 external bool JS$_preBind([Effect effect, num/*num|Null*/ overrideOrientation]);
 /// Binds the material to the mesh
 external void bind(Matrix world, [Mesh mesh]);
 /// Binds the submesh to the material
 external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);
 /// Binds the world matrix to the material
 external void bindOnlyWorldMatrix(Matrix world);
 /// Binds the scene's uniform buffer to the effect.
 external void bindSceneUniformBuffer(Effect effect, UniformBuffer sceneUbo);
 /// Binds the view matrix to the effect
 external void bindView(Effect effect);
 /// Binds the view projection matrix to the effect
 external void bindViewProjection(Effect effect);
 /// Specifies if material alpha testing should be turned on for the mesh
 external bool JS$_shouldTurnAlphaTestOn(AbstractMesh mesh);
 /// Processes to execute after binding the material to a mesh
 external void JS$_afterBind([Mesh mesh]);
 /// Unbinds the material from the mesh
 external void unbind();
 /// Gets the active textures from the material
 external List<BaseTexture> getActiveTextures();
 /// Specifies if the material uses a texture
 external bool hasTexture(BaseTexture texture);
 /// Makes a duplicate of the material, and gives it a new name
 external Material/*Material|Null*/ clone(String name);
 /// Gets the meshes bound to the material
 external List<AbstractMesh> getBindedMeshes();
 /// Force shader compilation
 external void forceCompilation(AbstractMesh mesh, [void onCompiled(Material material), Partial<dynamic/*{
            clipPlane: boolean;
        }*/> options]);
 /// Force shader compilation
 external Promise<Null> forceCompilationAsync(AbstractMesh mesh, [Partial<dynamic/*{
            clipPlane: boolean;
        }*/> options]);
 /// Marks a define in the material to indicate that it needs to be re-computed
 external void markAsDirty(num flag);
 /// Marks all submeshes of a material to indicate that their material defines need to be re-calculated
 external void JS$_markAllSubMeshesAsDirty(void func(MaterialDefines defines));
 /// Indicates that image processing needs to be re-calculated for all submeshes
 external void JS$_markAllSubMeshesAsImageProcessingDirty();
 /// Indicates that textures need to be re-calculated for all submeshes
 external void JS$_markAllSubMeshesAsTexturesDirty();
 /// Indicates that fresnel needs to be re-calculated for all submeshes
 external void JS$_markAllSubMeshesAsFresnelDirty();
 /// Indicates that fresnel and misc need to be re-calculated for all submeshes
 external void JS$_markAllSubMeshesAsFresnelAndMiscDirty();
 /// Indicates that lights need to be re-calculated for all submeshes
 external void JS$_markAllSubMeshesAsLightsDirty();
 /// Indicates that attributes need to be re-calculated for all submeshes
 external void JS$_markAllSubMeshesAsAttributesDirty();
 /// Indicates that misc needs to be re-calculated for all submeshes
 external void JS$_markAllSubMeshesAsMiscDirty();
 /// Indicates that textures and misc need to be re-calculated for all submeshes
 external void JS$_markAllSubMeshesAsTexturesAndMiscDirty();
 /// Disposes the material
 external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]);
 /// Serializes this material
 external dynamic serialize();
 /// Creates a MultiMaterial from parsed MultiMaterial data.
 external static MultiMaterial ParseMultiMaterial(dynamic parsedMultiMaterial, Scene scene);
 /// Creates a material from parsed material data
 external static dynamic Parse(dynamic parsedMaterial, Scene scene, String rootUrl); }

 /// "Static Class" containing the most commonly used helper while dealing with material for
 /// rendering purpose.
 /// It contains the basic tools to help defining defines, binding uniform for the common part of the materials.
 /// This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.
 @JS("BABYLON.MaterialHelper" ) class MaterialHelper { // @Ignore
 MaterialHelper .fakeConstructor$() ;
 /// Bind the current view position to an effect.
 external static void BindEyePosition(Effect effect, Scene scene);
 /// Helps preparing the defines values about the UVs in used in the effect.
 /// UVs are shared as much as we can accross chanels in the shaders.
 external static void PrepareDefinesForMergedUV(BaseTexture texture, dynamic defines, String key);
 /// Binds a texture matrix value to its corrsponding uniform
 external static void BindTextureMatrix(BaseTexture texture, UniformBuffer uniformBuffer, String key);
 /// Helper used to prepare the list of defines associated with misc. values for shader compilation
 external static void PrepareDefinesForMisc(AbstractMesh mesh, Scene scene, bool useLogarithmicDepth, bool pointsCloud, bool fogEnabled, bool alphaTest, dynamic defines);
 /// Helper used to prepare the list of defines associated with frame values for shader compilation
 external static void PrepareDefinesForFrameBoundValues(Scene scene, Engine engine, dynamic defines, bool useInstances, [bool/*bool|Null*/ useClipPlane]);
 /// Prepares the defines used in the shader depending on the attributes data available in the mesh
 external static bool PrepareDefinesForAttributes(AbstractMesh mesh, dynamic defines, bool useVertexColor, bool useBones, [bool useMorphTargets, bool useVertexAlpha]);
 /// Prepares the defines related to the light information passed in parameter
 external static bool PrepareDefinesForLights(Scene scene, AbstractMesh mesh, dynamic defines, bool specularSupported, [num maxSimultaneousLights, bool disableLighting]);
 /// Prepares the uniforms and samplers list to be used in the effect. This can automatically remove from the list uniforms
 /// that won t be acctive due to defines being turned off.
 external static void PrepareUniformsAndSamplersList(dynamic/*List<String>|EffectCreationOptions*/ uniformsListOrOptions, [List<String> samplersList, dynamic defines, num maxSimultaneousLights]);
 /// This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)
 external static num HandleFallbacksForShadows(dynamic defines, EffectFallbacks fallbacks, [num maxSimultaneousLights, num rank]);
 /// Prepares the list of attributes required for morph targets according to the effect defines.
 external static void PrepareAttributesForMorphTargets(List<String> attribs, AbstractMesh mesh, dynamic defines);
 /// Prepares the list of attributes required for bones according to the effect defines.
 external static void PrepareAttributesForBones(List<String> attribs, AbstractMesh mesh, dynamic defines, EffectFallbacks fallbacks);
 /// Prepares the list of attributes required for instances according to the effect defines.
 external static void PrepareAttributesForInstances(List<String> attribs, dynamic defines);
 /// Binds the light shadow information to the effect for the given mesh.
 external static void BindLightShadow(Light light, Scene scene, AbstractMesh mesh, String lightIndex, Effect effect);
 /// Binds the light information to the effect.
 external static void BindLightProperties(Light light, Effect effect, num lightIndex);
 /// Binds the lights information from the scene to the effect for the given mesh.
 external static void BindLights(Scene scene, AbstractMesh mesh, Effect effect, dynamic defines, [num maxSimultaneousLights, bool usePhysicalLightFalloff]);
 /// Binds the fog information from the scene to the effect for the given mesh.
 external static void BindFogParameters(Scene scene, AbstractMesh mesh, Effect effect);
 /// Binds the bones information from the mesh to the effect.
 external static void BindBonesParameters([AbstractMesh mesh, Effect effect]);
 /// Binds the morph targets information from the mesh to the effect.
 external static void BindMorphTargetParameters(AbstractMesh abstractMesh, Effect effect);
 /// Binds the logarithmic depth information from the scene to the effect for the given defines.
 external static void BindLogDepth(dynamic defines, Effect effect, Scene scene);
 /// Binds the clip plane information from the scene to the effect.
 external static void BindClipPlane(Effect effect, Scene scene); }

 @JS("BABYLON.MultiMaterial" ) class MultiMaterial extends Material { // @Ignore
 MultiMaterial .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_subMaterials; external set JS$_subMaterials(v); external List<Material/*Material|Null*/> get subMaterials; external set subMaterials(List<Material/*Material|Null*/> v); external factory MultiMaterial(String name, Scene scene); external JS$_hookArray(array); external Material/*Material|Null*/ getSubMaterial(num index); external List<BaseTexture> getActiveTextures(); external String getClassName(); external bool isReadyForSubMesh(AbstractMesh mesh, BaseSubMesh subMesh, [bool useInstances]); external MultiMaterial clone(String name, [bool cloneChildren]); external dynamic serialize(); external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]); }

 @JS("BABYLON.PushMaterial" ) class PushMaterial extends Material { // @Ignore
 PushMaterial .fakeConstructor$() : super.fakeConstructor$() ;
 external Effect get JS$_activeEffect; external set JS$_activeEffect(Effect v); external Matrix get JS$_normalMatrix; external set JS$_normalMatrix(Matrix v); external factory PushMaterial(String name, Scene scene); external Effect getEffect(); external bool isReady([AbstractMesh mesh, bool useInstances]);
 /// Binds the given world matrix to the active effect
 external void bindOnlyWorldMatrix(Matrix world);
 /// Binds the given normal matrix to the active effect
 external void bindOnlyNormalMatrix(Matrix normalMatrix); external void bind(Matrix world, [Mesh mesh]); external void JS$_afterBind(Mesh mesh, [Effect/*Effect|Null*/ effect]); external bool JS$_mustRebind(Scene scene, Effect effect, [num visibility]); }

 @JS("BABYLON.ShaderMaterial" ) class ShaderMaterial extends Material { // @Ignore
 ShaderMaterial .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_shaderPath; external set JS$_shaderPath(v); external get JS$_options; external set JS$_options(v); external get JS$_textures; external set JS$_textures(v); external get JS$_textureArrays; external set JS$_textureArrays(v); external get JS$_floats; external set JS$_floats(v); external get JS$_ints; external set JS$_ints(v); external get JS$_floatsArrays; external set JS$_floatsArrays(v); external get JS$_colors3; external set JS$_colors3(v); external get JS$_colors3Arrays; external set JS$_colors3Arrays(v); external get JS$_colors4; external set JS$_colors4(v); external get JS$_vectors2; external set JS$_vectors2(v); external get JS$_vectors3; external set JS$_vectors3(v); external get JS$_vectors4; external set JS$_vectors4(v); external get JS$_matrices; external set JS$_matrices(v); external get JS$_matrices3x3; external set JS$_matrices3x3(v); external get JS$_matrices2x2; external set JS$_matrices2x2(v); external get JS$_vectors2Arrays; external set JS$_vectors2Arrays(v); external get JS$_vectors3Arrays; external set JS$_vectors3Arrays(v); external get JS$_cachedWorldViewMatrix; external set JS$_cachedWorldViewMatrix(v); external get JS$_renderId; external set JS$_renderId(v); external factory ShaderMaterial(String name, Scene scene, dynamic shaderPath, dynamic options); external String getClassName(); external bool needAlphaBlending(); external bool needAlphaTesting(); external JS$_checkUniform(uniformName); external ShaderMaterial setTexture(String name, Texture texture); external ShaderMaterial setTextureArray(String name, List<Texture> textures); external ShaderMaterial setFloat(String name, num value); external ShaderMaterial setInt(String name, num value); external ShaderMaterial setFloats(String name, List<num> value); external ShaderMaterial setColor3(String name, Color3 value); external ShaderMaterial setColor3Array(String name, List<Color3> value); external ShaderMaterial setColor4(String name, Color4 value); external ShaderMaterial setVector2(String name, Vector2 value); external ShaderMaterial setVector3(String name, Vector3 value); external ShaderMaterial setVector4(String name, Vector4 value); external ShaderMaterial setMatrix(String name, Matrix value); external ShaderMaterial setMatrix3x3(String name, Float32List value); external ShaderMaterial setMatrix2x2(String name, Float32List value); external ShaderMaterial setArray2(String name, List<num> value); external ShaderMaterial setArray3(String name, List<num> value); external JS$_checkCache(scene, [mesh, useInstances]); external bool isReady([AbstractMesh mesh, bool useInstances]); external void bindOnlyWorldMatrix(Matrix world); external void bind(Matrix world, [Mesh mesh]); external List<BaseTexture> getActiveTextures(); external bool hasTexture(BaseTexture texture); external ShaderMaterial clone(String name); external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]); external dynamic serialize(); external static ShaderMaterial Parse(dynamic source, Scene scene, String rootUrl); }

 /// @hidden
 @JS("BABYLON.StandardMaterialDefines" ) class StandardMaterialDefines extends MaterialDefines implements IImageProcessingConfigurationDefines { // @Ignore
 StandardMaterialDefines .fakeConstructor$() : super.fakeConstructor$() ;
 external bool get MAINUV1; external set MAINUV1(bool v); external bool get MAINUV2; external set MAINUV2(bool v); external bool get DIFFUSE; external set DIFFUSE(bool v); external num get DIFFUSEDIRECTUV; external set DIFFUSEDIRECTUV(num v); external bool get AMBIENT; external set AMBIENT(bool v); external num get AMBIENTDIRECTUV; external set AMBIENTDIRECTUV(num v); external bool get OPACITY; external set OPACITY(bool v); external num get OPACITYDIRECTUV; external set OPACITYDIRECTUV(num v); external bool get OPACITYRGB; external set OPACITYRGB(bool v); external bool get REFLECTION; external set REFLECTION(bool v); external bool get EMISSIVE; external set EMISSIVE(bool v); external num get EMISSIVEDIRECTUV; external set EMISSIVEDIRECTUV(num v); external bool get SPECULAR; external set SPECULAR(bool v); external num get SPECULARDIRECTUV; external set SPECULARDIRECTUV(num v); external bool get BUMP; external set BUMP(bool v); external num get BUMPDIRECTUV; external set BUMPDIRECTUV(num v); external bool get PARALLAX; external set PARALLAX(bool v); external bool get PARALLAXOCCLUSION; external set PARALLAXOCCLUSION(bool v); external bool get SPECULAROVERALPHA; external set SPECULAROVERALPHA(bool v); external bool get CLIPPLANE; external set CLIPPLANE(bool v); external bool get ALPHATEST; external set ALPHATEST(bool v); external bool get DEPTHPREPASS; external set DEPTHPREPASS(bool v); external bool get ALPHAFROMDIFFUSE; external set ALPHAFROMDIFFUSE(bool v); external bool get POINTSIZE; external set POINTSIZE(bool v); external bool get FOG; external set FOG(bool v); external bool get SPECULARTERM; external set SPECULARTERM(bool v); external bool get DIFFUSEFRESNEL; external set DIFFUSEFRESNEL(bool v); external bool get OPACITYFRESNEL; external set OPACITYFRESNEL(bool v); external bool get REFLECTIONFRESNEL; external set REFLECTIONFRESNEL(bool v); external bool get REFRACTIONFRESNEL; external set REFRACTIONFRESNEL(bool v); external bool get EMISSIVEFRESNEL; external set EMISSIVEFRESNEL(bool v); external bool get FRESNEL; external set FRESNEL(bool v); external bool get NORMAL; external set NORMAL(bool v); external bool get UV1; external set UV1(bool v); external bool get UV2; external set UV2(bool v); external bool get VERTEXCOLOR; external set VERTEXCOLOR(bool v); external bool get VERTEXALPHA; external set VERTEXALPHA(bool v); external num get NUM_BONE_INFLUENCERS; external set NUM_BONE_INFLUENCERS(num v); external num get BonesPerMesh; external set BonesPerMesh(num v); external bool get INSTANCES; external set INSTANCES(bool v); external bool get GLOSSINESS; external set GLOSSINESS(bool v); external bool get ROUGHNESS; external set ROUGHNESS(bool v); external bool get EMISSIVEASILLUMINATION; external set EMISSIVEASILLUMINATION(bool v); external bool get LINKEMISSIVEWITHDIFFUSE; external set LINKEMISSIVEWITHDIFFUSE(bool v); external bool get REFLECTIONFRESNELFROMSPECULAR; external set REFLECTIONFRESNELFROMSPECULAR(bool v); external bool get LIGHTMAP; external set LIGHTMAP(bool v); external num get LIGHTMAPDIRECTUV; external set LIGHTMAPDIRECTUV(num v); external bool get OBJECTSPACE_NORMALMAP; external set OBJECTSPACE_NORMALMAP(bool v); external bool get USELIGHTMAPASSHADOWMAP; external set USELIGHTMAPASSHADOWMAP(bool v); external bool get REFLECTIONMAP_3D; external set REFLECTIONMAP_3D(bool v); external bool get REFLECTIONMAP_SPHERICAL; external set REFLECTIONMAP_SPHERICAL(bool v); external bool get REFLECTIONMAP_PLANAR; external set REFLECTIONMAP_PLANAR(bool v); external bool get REFLECTIONMAP_CUBIC; external set REFLECTIONMAP_CUBIC(bool v); external bool get USE_LOCAL_REFLECTIONMAP_CUBIC; external set USE_LOCAL_REFLECTIONMAP_CUBIC(bool v); external bool get REFLECTIONMAP_PROJECTION; external set REFLECTIONMAP_PROJECTION(bool v); external bool get REFLECTIONMAP_SKYBOX; external set REFLECTIONMAP_SKYBOX(bool v); external bool get REFLECTIONMAP_EXPLICIT; external set REFLECTIONMAP_EXPLICIT(bool v); external bool get REFLECTIONMAP_EQUIRECTANGULAR; external set REFLECTIONMAP_EQUIRECTANGULAR(bool v); external bool get REFLECTIONMAP_EQUIRECTANGULAR_FIXED; external set REFLECTIONMAP_EQUIRECTANGULAR_FIXED(bool v); external bool get REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED; external set REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED(bool v); external bool get INVERTCUBICMAP; external set INVERTCUBICMAP(bool v); external bool get LOGARITHMICDEPTH; external set LOGARITHMICDEPTH(bool v); external bool get REFRACTION; external set REFRACTION(bool v); external bool get REFRACTIONMAP_3D; external set REFRACTIONMAP_3D(bool v); external bool get REFLECTIONOVERALPHA; external set REFLECTIONOVERALPHA(bool v); external bool get TWOSIDEDLIGHTING; external set TWOSIDEDLIGHTING(bool v); external bool get SHADOWFLOAT; external set SHADOWFLOAT(bool v); external bool get MORPHTARGETS; external set MORPHTARGETS(bool v); external bool get MORPHTARGETS_NORMAL; external set MORPHTARGETS_NORMAL(bool v); external bool get MORPHTARGETS_TANGENT; external set MORPHTARGETS_TANGENT(bool v); external num get NUM_MORPH_INFLUENCERS; external set NUM_MORPH_INFLUENCERS(num v); external bool get NONUNIFORMSCALING; external set NONUNIFORMSCALING(bool v); external bool get PREMULTIPLYALPHA; external set PREMULTIPLYALPHA(bool v); external bool get IMAGEPROCESSING; external set IMAGEPROCESSING(bool v); external bool get VIGNETTE; external set VIGNETTE(bool v); external bool get VIGNETTEBLENDMODEMULTIPLY; external set VIGNETTEBLENDMODEMULTIPLY(bool v); external bool get VIGNETTEBLENDMODEOPAQUE; external set VIGNETTEBLENDMODEOPAQUE(bool v); external bool get TONEMAPPING; external set TONEMAPPING(bool v); external bool get CONTRAST; external set CONTRAST(bool v); external bool get COLORCURVES; external set COLORCURVES(bool v); external bool get COLORGRADING; external set COLORGRADING(bool v); external bool get COLORGRADING3D; external set COLORGRADING3D(bool v); external bool get SAMPLER3DGREENDEPTH; external set SAMPLER3DGREENDEPTH(bool v); external bool get SAMPLER3DBGRMAP; external set SAMPLER3DBGRMAP(bool v); external bool get IMAGEPROCESSINGPOSTPROCESS; external set IMAGEPROCESSINGPOSTPROCESS(bool v);
 /// If the reflection texture on this material is in linear color space
 /// @hidden
 external bool get IS_REFLECTION_LINEAR; external set IS_REFLECTION_LINEAR(bool v);
 /// If the refraction texture on this material is in linear color space
 /// @hidden
 external bool get IS_REFRACTION_LINEAR; external set IS_REFRACTION_LINEAR(bool v); external bool get EXPOSURE; external set EXPOSURE(bool v); external factory StandardMaterialDefines(); external void setReflectionMode(String modeToEnable); }

 @JS("BABYLON.StandardMaterial" ) class StandardMaterial extends PushMaterial { // @Ignore
 StandardMaterial .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_diffuseTexture; external set JS$_diffuseTexture(v); external BaseTexture/*BaseTexture|Null*/ get diffuseTexture; external set diffuseTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_ambientTexture; external set JS$_ambientTexture(v); external BaseTexture/*BaseTexture|Null*/ get ambientTexture; external set ambientTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_opacityTexture; external set JS$_opacityTexture(v); external BaseTexture/*BaseTexture|Null*/ get opacityTexture; external set opacityTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_reflectionTexture; external set JS$_reflectionTexture(v); external BaseTexture/*BaseTexture|Null*/ get reflectionTexture; external set reflectionTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_emissiveTexture; external set JS$_emissiveTexture(v); external BaseTexture/*BaseTexture|Null*/ get emissiveTexture; external set emissiveTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_specularTexture; external set JS$_specularTexture(v); external BaseTexture/*BaseTexture|Null*/ get specularTexture; external set specularTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_bumpTexture; external set JS$_bumpTexture(v); external BaseTexture/*BaseTexture|Null*/ get bumpTexture; external set bumpTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_lightmapTexture; external set JS$_lightmapTexture(v); external BaseTexture/*BaseTexture|Null*/ get lightmapTexture; external set lightmapTexture(BaseTexture/*BaseTexture|Null*/ v); external get JS$_refractionTexture; external set JS$_refractionTexture(v); external BaseTexture/*BaseTexture|Null*/ get refractionTexture; external set refractionTexture(BaseTexture/*BaseTexture|Null*/ v); external Color3 get ambientColor; external set ambientColor(Color3 v); external Color3 get diffuseColor; external set diffuseColor(Color3 v); external Color3 get specularColor; external set specularColor(Color3 v); external Color3 get emissiveColor; external set emissiveColor(Color3 v); external num get specularPower; external set specularPower(num v); external get JS$_useAlphaFromDiffuseTexture; external set JS$_useAlphaFromDiffuseTexture(v); external bool get useAlphaFromDiffuseTexture; external set useAlphaFromDiffuseTexture(bool v); external get JS$_useEmissiveAsIllumination; external set JS$_useEmissiveAsIllumination(v); external bool get useEmissiveAsIllumination; external set useEmissiveAsIllumination(bool v); external get JS$_linkEmissiveWithDiffuse; external set JS$_linkEmissiveWithDiffuse(v); external bool get linkEmissiveWithDiffuse; external set linkEmissiveWithDiffuse(bool v); external get JS$_useSpecularOverAlpha; external set JS$_useSpecularOverAlpha(v); external bool get useSpecularOverAlpha; external set useSpecularOverAlpha(bool v); external get JS$_useReflectionOverAlpha; external set JS$_useReflectionOverAlpha(v); external bool get useReflectionOverAlpha; external set useReflectionOverAlpha(bool v); external get JS$_disableLighting; external set JS$_disableLighting(v); external bool get disableLighting; external set disableLighting(bool v); external get JS$_useObjectSpaceNormalMap; external set JS$_useObjectSpaceNormalMap(v);
 /// Allows using an object space normal map (instead of tangent space).
 external bool get useObjectSpaceNormalMap; external set useObjectSpaceNormalMap(bool v); external get JS$_useParallax; external set JS$_useParallax(v); external bool get useParallax; external set useParallax(bool v); external get JS$_useParallaxOcclusion; external set JS$_useParallaxOcclusion(v); external bool get useParallaxOcclusion; external set useParallaxOcclusion(bool v); external num get parallaxScaleBias; external set parallaxScaleBias(num v); external get JS$_roughness; external set JS$_roughness(v); external num get roughness; external set roughness(num v); external num get indexOfRefraction; external set indexOfRefraction(num v); external bool get invertRefractionY; external set invertRefractionY(bool v);
 /// Defines the alpha limits in alpha test mode
 external num get alphaCutOff; external set alphaCutOff(num v); external get JS$_useLightmapAsShadowmap; external set JS$_useLightmapAsShadowmap(v); external bool get useLightmapAsShadowmap; external set useLightmapAsShadowmap(bool v); external get JS$_diffuseFresnelParameters; external set JS$_diffuseFresnelParameters(v); external FresnelParameters get diffuseFresnelParameters; external set diffuseFresnelParameters(FresnelParameters v); external get JS$_opacityFresnelParameters; external set JS$_opacityFresnelParameters(v); external FresnelParameters get opacityFresnelParameters; external set opacityFresnelParameters(FresnelParameters v); external get JS$_reflectionFresnelParameters; external set JS$_reflectionFresnelParameters(v); external FresnelParameters get reflectionFresnelParameters; external set reflectionFresnelParameters(FresnelParameters v); external get JS$_refractionFresnelParameters; external set JS$_refractionFresnelParameters(v); external FresnelParameters get refractionFresnelParameters; external set refractionFresnelParameters(FresnelParameters v); external get JS$_emissiveFresnelParameters; external set JS$_emissiveFresnelParameters(v); external FresnelParameters get emissiveFresnelParameters; external set emissiveFresnelParameters(FresnelParameters v); external get JS$_useReflectionFresnelFromSpecular; external set JS$_useReflectionFresnelFromSpecular(v); external bool get useReflectionFresnelFromSpecular; external set useReflectionFresnelFromSpecular(bool v); external get JS$_useGlossinessFromSpecularMapAlpha; external set JS$_useGlossinessFromSpecularMapAlpha(v); external bool get useGlossinessFromSpecularMapAlpha; external set useGlossinessFromSpecularMapAlpha(bool v); external get JS$_maxSimultaneousLights; external set JS$_maxSimultaneousLights(v); external num get maxSimultaneousLights; external set maxSimultaneousLights(num v);
 /// If sets to true, x component of normal map value will invert (x = 1.0 - x).
 external get JS$_invertNormalMapX; external set JS$_invertNormalMapX(v); external bool get invertNormalMapX; external set invertNormalMapX(bool v);
 /// If sets to true, y component of normal map value will invert (y = 1.0 - y).
 external get JS$_invertNormalMapY; external set JS$_invertNormalMapY(v); external bool get invertNormalMapY; external set invertNormalMapY(bool v);
 /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
 external get JS$_twoSidedLighting; external set JS$_twoSidedLighting(v); external bool get twoSidedLighting; external set twoSidedLighting(bool v);
 /// Default configuration related to image processing available in the standard Material.
 external ImageProcessingConfiguration get JS$_imageProcessingConfiguration; external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);
 /// Gets the image processing configuration used either in this material.
 /// Sets the Default image processing configuration used either in the this material.
 /// If sets to null, the scene one is in use.
 external ImageProcessingConfiguration get imageProcessingConfiguration; external set imageProcessingConfiguration(ImageProcessingConfiguration v);
 /// Keep track of the image processing observer to allow dispose and replace.
 external get JS$_imageProcessingObserver; external set JS$_imageProcessingObserver(v);
 /// Attaches a new image processing configuration to the Standard Material.
 external void JS$_attachImageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ configuration);
 /// Gets wether the color curves effect is enabled.
 /// Sets wether the color curves effect is enabled.
 external bool get cameraColorCurvesEnabled; external set cameraColorCurvesEnabled(bool v);
 /// Gets wether the color grading effect is enabled.
 /// Gets wether the color grading effect is enabled.
 external bool get cameraColorGradingEnabled; external set cameraColorGradingEnabled(bool v);
 /// Gets wether tonemapping is enabled or not.
 /// Sets wether tonemapping is enabled or not
 external bool get cameraToneMappingEnabled; external set cameraToneMappingEnabled(bool v);
 /// The camera exposure used on this material.
 /// This property is here and not in the camera to allow controlling exposure without full screen post process.
 /// This corresponds to a photographic exposure.
 /// The camera exposure used on this material.
 /// This property is here and not in the camera to allow controlling exposure without full screen post process.
 /// This corresponds to a photographic exposure.
 external num get cameraExposure; external set cameraExposure(num v);
 /// Gets The camera contrast used on this material.
 /// Sets The camera contrast used on this material.
 external num get cameraContrast; external set cameraContrast(num v);
 /// Gets the Color Grading 2D Lookup Texture.
 /// Sets the Color Grading 2D Lookup Texture.
 external BaseTexture/*BaseTexture|Null*/ get cameraColorGradingTexture; external set cameraColorGradingTexture(BaseTexture/*BaseTexture|Null*/ v);
 /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
 /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
 /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
 /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
 /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
 /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
 /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
 /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
 external ColorCurves/*ColorCurves|Null*/ get cameraColorCurves; external set cameraColorCurves(ColorCurves/*ColorCurves|Null*/ v); external Function/*(shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: StandardMaterialDefines) => string*/ get customShaderNameResolve; external set customShaderNameResolve(Function/*(shaderName: string, uniforms: string[], uniformBuffers: string[], samplers: string[], defines: StandardMaterialDefines) => string*/ v); external SmartArray<RenderTargetTexture> get JS$_renderTargets; external set JS$_renderTargets(SmartArray<RenderTargetTexture> v); external Matrix get JS$_worldViewProjectionMatrix; external set JS$_worldViewProjectionMatrix(Matrix v); external Color3 get JS$_globalAmbientColor; external set JS$_globalAmbientColor(Color3 v); external bool get JS$_useLogarithmicDepth; external set JS$_useLogarithmicDepth(bool v); external factory StandardMaterial(String name, Scene scene); external String getClassName(); external bool get useLogarithmicDepth; external set useLogarithmicDepth(bool v); external bool needAlphaBlending(); external bool needAlphaTesting(); external bool JS$_shouldUseAlphaFromDiffuseTexture(); external BaseTexture/*BaseTexture|Null*/ getAlphaTestTexture();
 /// Child classes can use it to update shaders
 external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool useInstances]); external void buildUniformLayout(); external void unbind(); external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh); external List<IAnimatable> getAnimatables(); external List<BaseTexture> getActiveTextures(); external bool hasTexture(BaseTexture texture); external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]); external StandardMaterial clone(String name); external dynamic serialize(); external static StandardMaterial Parse(dynamic source, Scene scene, String rootUrl); external static bool get JS$_DiffuseTextureEnabled; external static set JS$_DiffuseTextureEnabled(bool v); external static bool get DiffuseTextureEnabled; external static set DiffuseTextureEnabled(bool v); external static bool get JS$_AmbientTextureEnabled; external static set JS$_AmbientTextureEnabled(bool v); external static bool get AmbientTextureEnabled; external static set AmbientTextureEnabled(bool v); external static bool get JS$_OpacityTextureEnabled; external static set JS$_OpacityTextureEnabled(bool v); external static bool get OpacityTextureEnabled; external static set OpacityTextureEnabled(bool v); external static bool get JS$_ReflectionTextureEnabled; external static set JS$_ReflectionTextureEnabled(bool v); external static bool get ReflectionTextureEnabled; external static set ReflectionTextureEnabled(bool v); external static bool get JS$_EmissiveTextureEnabled; external static set JS$_EmissiveTextureEnabled(bool v); external static bool get EmissiveTextureEnabled; external static set EmissiveTextureEnabled(bool v); external static bool get JS$_SpecularTextureEnabled; external static set JS$_SpecularTextureEnabled(bool v); external static bool get SpecularTextureEnabled; external static set SpecularTextureEnabled(bool v); external static bool get JS$_BumpTextureEnabled; external static set JS$_BumpTextureEnabled(bool v); external static bool get BumpTextureEnabled; external static set BumpTextureEnabled(bool v); external static bool get JS$_LightmapTextureEnabled; external static set JS$_LightmapTextureEnabled(bool v); external static bool get LightmapTextureEnabled; external static set LightmapTextureEnabled(bool v); external static bool get JS$_RefractionTextureEnabled; external static set JS$_RefractionTextureEnabled(bool v); external static bool get RefractionTextureEnabled; external static set RefractionTextureEnabled(bool v); external static bool get JS$_ColorGradingTextureEnabled; external static set JS$_ColorGradingTextureEnabled(bool v); external static bool get ColorGradingTextureEnabled; external static set ColorGradingTextureEnabled(bool v); external static bool get JS$_FresnelEnabled; external static set JS$_FresnelEnabled(bool v); external static bool get FresnelEnabled; external static set FresnelEnabled(bool v); }

 @JS("BABYLON.UniformBuffer" ) class UniformBuffer { // @Ignore
 UniformBuffer .fakeConstructor$() ;
 external get JS$_engine; external set JS$_engine(v); external get JS$_buffer; external set JS$_buffer(v); external get JS$_data; external set JS$_data(v); external get JS$_bufferData; external set JS$_bufferData(v); external get JS$_dynamic; external set JS$_dynamic(v); external get JS$_uniformLocations; external set JS$_uniformLocations(v); external get JS$_uniformSizes; external set JS$_uniformSizes(v); external get JS$_uniformLocationPointer; external set JS$_uniformLocationPointer(v); external get JS$_needSync; external set JS$_needSync(v); external get JS$_noUBO; external set JS$_noUBO(v); external get JS$_currentEffect; external set JS$_currentEffect(v); external static get JS$_MAX_UNIFORM_SIZE; external static set JS$_MAX_UNIFORM_SIZE(v); external static get JS$_tempBuffer; external static set JS$_tempBuffer(v);
 /// Wrapper for updateUniform.
 /// @method updateMatrix3x3
 external VoidFunc2<String, Float32List> get updateMatrix3x3; external set updateMatrix3x3(VoidFunc2<String, Float32List> v);
 /// Wrapper for updateUniform.
 external VoidFunc2<String, Float32List> get updateMatrix2x2; external set updateMatrix2x2(VoidFunc2<String, Float32List> v);
 /// Wrapper for updateUniform.
 external VoidFunc2<String, num> get updateFloat; external set updateFloat(VoidFunc2<String, num> v);
 /// Wrapper for updateUniform.
 external VoidFunc4Opt1<String, num, num, String> get updateFloat2; external set updateFloat2(VoidFunc4Opt1<String, num, num, String> v);
 /// Wrapper for updateUniform.
 external Function/*(name: string, x: number, y: number, z: number, suffix?: string) => void*/ get updateFloat3; external set updateFloat3(Function/*(name: string, x: number, y: number, z: number, suffix?: string) => void*/ v);
 /// Wrapper for updateUniform.
 external Function/*(name: string, x: number, y: number, z: number, w: number, suffix?: string) => void*/ get updateFloat4; external set updateFloat4(Function/*(name: string, x: number, y: number, z: number, w: number, suffix?: string) => void*/ v);
 /// Wrapper for updateUniform.
 external VoidFunc2<String, Matrix> get updateMatrix; external set updateMatrix(VoidFunc2<String, Matrix> v);
 /// Wrapper for updateUniform.
 external VoidFunc2<String, Vector3> get updateVector3; external set updateVector3(VoidFunc2<String, Vector3> v);
 /// Wrapper for updateUniform.
 external VoidFunc2<String, Vector4> get updateVector4; external set updateVector4(VoidFunc2<String, Vector4> v);
 /// Wrapper for updateUniform.
 external VoidFunc3Opt1<String, Color3, String> get updateColor3; external set updateColor3(VoidFunc3Opt1<String, Color3, String> v);
 /// Wrapper for updateUniform.
 external VoidFunc4Opt1<String, Color3, num, String> get updateColor4; external set updateColor4(VoidFunc4Opt1<String, Color3, num, String> v);
 /// Uniform buffer objects.
 /// Handles blocks of uniform on the GPU.
 /// If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.
 /// For more information, please refer to :
 /// https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
 external factory UniformBuffer(Engine engine, [List<num> data, bool JS$dynamic]);
 /// Indicates if the buffer is using the WebGL2 UBO implementation,
 /// or just falling back on setUniformXXX calls.
 external bool get useUbo; external set useUbo(bool v);
 /// Indicates if the WebGL underlying uniform buffer is in sync
 /// with the javascript cache data.
 external bool get isSync; external set isSync(bool v);
 /// Indicates if the WebGL underlying uniform buffer is dynamic.
 /// Also, a dynamic UniformBuffer will disable cache verification and always
 /// update the underlying WebGL uniform buffer to the GPU.
 external bool isDynamic();
 /// The data cache on JS side.
 external Float32List getData();
 /// The underlying WebGL Uniform buffer.
 external Buffer/*Buffer|Null*/ getBuffer();
 /// std140 layout specifies how to align data within an UBO structure.
 /// See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159
 /// for specs.
 external JS$_fillAlignment(size);
 /// Adds an uniform in the buffer.
 /// Warning : the subsequents calls of this function must be in the same order as declared in the shader
 /// for the layout to be correct !
 external void addUniform(String name, dynamic/*num|List<num>*/ size);
 /// Wrapper for addUniform.
 external void addMatrix(String name, Matrix mat);
 /// Wrapper for addUniform.
 external void addFloat2(String name, num x, num y);
 /// Wrapper for addUniform.
 external void addFloat3(String name, num x, num y, num z);
 /// Wrapper for addUniform.
 external void addColor3(String name, Color3 color);
 /// Wrapper for addUniform.
 external void addColor4(String name, Color3 color, num alpha);
 /// Wrapper for addUniform.
 external void addVector3(String name, Vector3 vector);
 /// Wrapper for addUniform.
 external void addMatrix3x3(String name);
 /// Wrapper for addUniform.
 external void addMatrix2x2(String name);
 /// Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.
 external void create(); external void JS$_rebuild();
 /// Updates the WebGL Uniform Buffer on the GPU.
 /// If the `dynamic` flag is set to true, no cache comparison is done.
 /// Otherwise, the buffer will be updated only if the cache differs.
 external void update();
 /// Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.
 external void updateUniform(String uniformName, dynamic/*List<num>|Float32List*/ data, num size); external JS$_updateMatrix3x3ForUniform(name, matrix); external JS$_updateMatrix3x3ForEffect(name, matrix); external JS$_updateMatrix2x2ForEffect(name, matrix); external JS$_updateMatrix2x2ForUniform(name, matrix); external JS$_updateFloatForEffect(name, x); external JS$_updateFloatForUniform(name, x); external JS$_updateFloat2ForEffect(name, x, y, [suffix]); external JS$_updateFloat2ForUniform(name, x, y, [suffix]); external JS$_updateFloat3ForEffect(name, x, y, z, [suffix]); external JS$_updateFloat3ForUniform(name, x, y, z, [suffix]); external JS$_updateFloat4ForEffect(name, x, y, z, w, [suffix]); external JS$_updateFloat4ForUniform(name, x, y, z, w, [suffix]); external JS$_updateMatrixForEffect(name, mat); external JS$_updateMatrixForUniform(name, mat); external JS$_updateVector3ForEffect(name, vector); external JS$_updateVector3ForUniform(name, vector); external JS$_updateVector4ForEffect(name, vector); external JS$_updateVector4ForUniform(name, vector); external JS$_updateColor3ForEffect(name, color, [suffix]); external JS$_updateColor3ForUniform(name, color, [suffix]); external JS$_updateColor4ForEffect(name, color, alpha, [suffix]); external JS$_updateColor4ForUniform(name, color, alpha, [suffix]);
 /// Sets a sampler uniform on the effect.
 external void setTexture(String name, BaseTexture/*BaseTexture|Null*/ texture);
 /// Directly updates the value of the uniform in the cache AND on the GPU.
 external void updateUniformDirectly(String uniformName, dynamic/*List<num>|Float32List*/ data);
 /// Binds this uniform buffer to an effect.
 external void bindToEffect(Effect effect, String name);
 /// Disposes the uniform buffer.
 external void dispose(); }

 @JS("BABYLON.Scalar" ) class Scalar { // @Ignore
 Scalar .fakeConstructor$() ;
 /// Two pi constants convenient for computation.
 external static num get TwoPi; external static set TwoPi(num v);
 /// Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)
 external static bool WithinEpsilon(num a, num b, [num epsilon]);
 /// Returns a string : the upper case translation of the number i to hexadecimal.
 external static String ToHex(num i);
 /// Returns -1 if value is negative and +1 is value is positive.
 /// Returns the value itself if it's equal to zero.
 external static num Sign(num value);
 /// Returns the value itself if it's between min and max.
 /// Returns min if the value is lower than min.
 /// Returns max if the value is greater than max.
 external static num Clamp(num value, [num min, num max]);
 /// Returns the log2 of value.
 external static num Log2(num value);
 /// Loops the value, so that it is never larger than length and never smaller than 0.
 /// This is similar to the modulo operator but it works with floating point numbers.
 /// For example, using 3.0 for t and 2.5 for length, the result would be 0.5.
 /// With t = 5 and length = 2.5, the result would be 0.0.
 /// Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator
 external static num Repeat(num value, num length);
 /// Normalize the value between 0.0 and 1.0 using min and max values
 external static num Normalize(num value, num min, num max);
 /// Denormalize the value from 0.0 and 1.0 using min and max values
 external static num Denormalize(num normalized, num min, num max);
 /// Calculates the shortest difference between two given angles given in degrees.
 external static num DeltaAngle(num current, num target);
 /// PingPongs the value t, so that it is never larger than length and never smaller than 0.
 /// The returned value will move back and forth between 0 and length
 external static num PingPong(num tx, num length);
 /// Interpolates between min and max with smoothing at the limits.
 /// This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up
 /// from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.
 external static num SmoothStep(num from, num to, num tx);
 /// Moves a value current towards target.
 /// This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.
 /// Negative values of maxDelta pushes the value away from target.
 external static num MoveTowards(num current, num target, num maxDelta);
 /// Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
 /// Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta
 /// are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.
 external static num MoveTowardsAngle(num current, num target, num maxDelta);
 /// Creates a new scalar with values linearly interpolated of "amount" between the start scalar and the end scalar.
 external static num Lerp(num start, num end, num amount);
 /// Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
 /// The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.
 external static num LerpAngle(num start, num end, num amount);
 /// Calculates the linear parameter t that produces the interpolant value within the range [a, b].
 external static num InverseLerp(num a, num b, num value);
 /// Returns a new scalar located for "amount" (float) on the Hermite spline defined by the scalars "value1", "value3", "tangent1", "tangent2".
 external static num Hermite(num value1, num tangent1, num value2, num tangent2, num amount);
 /// Returns a random float number between and min and max values
 external static num RandomRange(num min, num max);
 /// This function returns percentage of a number in a given range.
 /// RangeToPercent(40,20,60) will return 0.5 (50%)
 /// RangeToPercent(34,0,100) will return 0.34 (34%)
 external static num RangeToPercent(num number, num min, num max);
 /// This function returns number that corresponds to the percentage in a given range.
 /// PercentToRange(0.34,0,100) will return 34.
 external static num PercentToRange(num percent, num min, num max);
 /// Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.
 external static num NormalizeRadians(num angle); }

 @JS("BABYLON.ToGammaSpace" ) external num get ToGammaSpace; @JS("BABYLON.ToLinearSpace" ) external get ToLinearSpace; @JS("BABYLON.Epsilon" ) external get Epsilon;
 /// Class used to hold a RBG color
 @JS("BABYLON.Color3" ) class Color3 { // @Ignore
 Color3 .fakeConstructor$() ;
 /// Defines the red component (between 0 and 1, default is 0)
 external num get r; external set r(num v);
 /// Defines the green component (between 0 and 1, default is 0)
 external num get g; external set g(num v);
 /// Defines the blue component (between 0 and 1, default is 0)
 external num get b; external set b(num v);
 /// Creates a new Color3 object from red, green, blue values, all between 0 and 1
 external factory Color3([
 /// Defines the red component (between 0 and 1, default is 0)
 num r,
 /// Defines the green component (between 0 and 1, default is 0)
 num g,
 /// Defines the blue component (between 0 and 1, default is 0)
 num b]);
 /// Creates a string with the Color3 current values
 external String toString();
 /// Returns the string "Color3"
 external String getClassName();
 /// Compute the Color3 hash code
 external num getHashCode();
 /// Stores in the given array from the given starting index the red, green, blue values as successive elements
 external Color3 toArray(dynamic/*List<num>|Float32List*/ array, [num index]);
 /// Returns a new {BABYLON.Color4} object from the current Color3 and the given alpha
 external Color4 toColor4([num alpha]);
 /// Returns a new array populated with 3 numeric elements : red, green and blue values
 external List<num> asArray();
 /// Returns the luminance value
 external num toLuminance();
 /// Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object
 external Color3 multiply(Color3 otherColor);
 /// Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object "result"
 external Color3 multiplyToRef(Color3 otherColor, Color3 result);
 /// Determines equality between Color3 objects
 external bool equals(Color3 otherColor);
 /// Determines equality between the current Color3 object and a set of r,b,g values
 external bool equalsFloats(num r, num g, num b);
 /// Multiplies in place each rgb value by scale
 external Color3 scale(num scale);
 /// Multiplies the rgb values by scale and stores the result into "result"
 external Color3 scaleToRef(num scale, Color3 result);
 /// Scale the current Color3 values by a factor and add the result to a given Color3
 external Color3 scaleAndAddToRef(num scale, Color3 result);
 /// Clamps the rgb values by the min and max values and stores the result into "result"
 external Color3 clampToRef(dynamic/*num|dynamic*/ min, dynamic/*num|dynamic*/ max, Color3 result);
 /// Creates a new Color3 set with the added values of the current Color3 and of the given one
 external Color3 add(Color3 otherColor);
 /// Stores the result of the addition of the current Color3 and given one rgb values into "result"
 external Color3 addToRef(Color3 otherColor, Color3 result);
 /// Returns a new Color3 set with the subtracted values of the given one from the current Color3
 external Color3 subtract(Color3 otherColor);
 /// Stores the result of the subtraction of given one from the current Color3 rgb values into "result"
 external Color3 subtractToRef(Color3 otherColor, Color3 result);
 /// Copy the current object
 external Color3 clone();
 /// Copies the rgb values from the source in the current Color3
 external Color3 copyFrom(Color3 source);
 /// Updates the Color3 rgb values from the given floats
 external Color3 copyFromFloats(num r, num g, num b);
 /// Updates the Color3 rgb values from the given floats
 external Color3 JS$set(num r, num g, num b);
 /// Compute the Color3 hexadecimal code as a string
 external String toHexString();
 /// Computes a new Color3 converted from the current one to linear space
 external Color3 toLinearSpace();
 /// Converts the Color3 values to linear space and stores the result in "convertedColor"
 external Color3 toLinearSpaceToRef(Color3 convertedColor);
 /// Computes a new Color3 converted from the current one to gamma space
 external Color3 toGammaSpace();
 /// Converts the Color3 values to gamma space and stores the result in "convertedColor"
 external Color3 toGammaSpaceToRef(Color3 convertedColor);
 /// Creates a new Color3 from the string containing valid hexadecimal values
 external static Color3 FromHexString(String hex);
 /// Creates a new Vector3 from the starting index of the given array
 external static Color3 FromArray(ArrayLike<num> array, [num offset]);
 /// Creates a new Color3 from integer values (< 256)
 external static Color3 FromInts(num r, num g, num b);
 /// Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
 external static Color3 Lerp(Color3 start, Color3 end, num amount);
 /// Returns a Color3 value containing a red color
 external static Color3 Red();
 /// Returns a Color3 value containing a green color
 external static Color3 Green();
 /// Returns a Color3 value containing a blue color
 external static Color3 Blue();
 /// Returns a Color3 value containing a black color
 external static Color3 Black();
 /// Returns a Color3 value containing a white color
 external static Color3 White();
 /// Returns a Color3 value containing a purple color
 external static Color3 Purple();
 /// Returns a Color3 value containing a magenta color
 external static Color3 Magenta();
 /// Returns a Color3 value containing a yellow color
 external static Color3 Yellow();
 /// Returns a Color3 value containing a gray color
 external static Color3 Gray();
 /// Returns a Color3 value containing a teal color
 external static Color3 Teal();
 /// Returns a Color3 value containing a random color
 external static Color3 Random(); }

 /// Class used to hold a RBGA color
 @JS("BABYLON.Color4" ) class Color4 { // @Ignore
 Color4 .fakeConstructor$() ;
 /// Defines the red component (between 0 and 1, default is 0)
 external num get r; external set r(num v);
 /// Defines the green component (between 0 and 1, default is 0)
 external num get g; external set g(num v);
 /// Defines the blue component (between 0 and 1, default is 0)
 external num get b; external set b(num v);
 /// Defines the alpha component (between 0 and 1, default is 1)
 external num get a; external set a(num v);
 /// Creates a new Color4 object from red, green, blue values, all between 0 and 1
 external factory Color4([
 /// Defines the red component (between 0 and 1, default is 0)
 num r,
 /// Defines the green component (between 0 and 1, default is 0)
 num g,
 /// Defines the blue component (between 0 and 1, default is 0)
 num b,
 /// Defines the alpha component (between 0 and 1, default is 1)
 num a]);
 /// Adds in place the given Color4 values to the current Color4 object
 external Color4 addInPlace(Color4 right);
 /// Creates a new array populated with 4 numeric elements : red, green, blue, alpha values
 external List<num> asArray();
 /// Stores from the starting index in the given array the Color4 successive values
 external Color4 toArray(List<num> array, [num index]);
 /// Creates a new Color4 set with the added values of the current Color4 and of the given one
 external Color4 add(Color4 right);
 /// Creates a new Color4 set with the subtracted values of the given one from the current Color4
 external Color4 subtract(Color4 right);
 /// Subtracts the given ones from the current Color4 values and stores the results in "result"
 external Color4 subtractToRef(Color4 right, Color4 result);
 /// Creates a new Color4 with the current Color4 values multiplied by scale
 external Color4 scale(num scale);
 /// Multiplies the current Color4 values by scale and stores the result in "result"
 external Color4 scaleToRef(num scale, Color4 result);
 /// Scale the current Color4 values by a factor and add the result to a given Color4
 external Color4 scaleAndAddToRef(num scale, Color4 result);
 /// Clamps the rgb values by the min and max values and stores the result into "result"
 external Color4 clampToRef(dynamic/*num|dynamic*/ min, dynamic/*num|dynamic*/ max, Color4 result);
 /// Multipy an Color4 value by another and return a new Color4 object
 external Color4 multiply(Color4 color);
 /// Multipy a Color4 value by another and push the result in a reference value
 external Color4 multiplyToRef(Color4 color, Color4 result);
 /// Creates a string with the Color4 current values
 external String toString();
 /// Returns the string "Color4"
 external String getClassName();
 /// Compute the Color4 hash code
 external num getHashCode();
 /// Creates a new Color4 copied from the current one
 external Color4 clone();
 /// Copies the given Color4 values into the current one
 external Color4 copyFrom(Color4 source);
 /// Copies the given float values into the current one
 external Color4 copyFromFloats(num r, num g, num b, num a);
 /// Copies the given float values into the current one
 external Color4 JS$set(num r, num g, num b, num a);
 /// Compute the Color4 hexadecimal code as a string
 external String toHexString();
 /// Computes a new Color4 converted from the current one to linear space
 external Color4 toLinearSpace();
 /// Converts the Color4 values to linear space and stores the result in "convertedColor"
 external Color4 toLinearSpaceToRef(Color4 convertedColor);
 /// Computes a new Color4 converted from the current one to gamma space
 external Color4 toGammaSpace();
 /// Converts the Color4 values to gamma space and stores the result in "convertedColor"
 external Color4 toGammaSpaceToRef(Color4 convertedColor);
 /// Creates a new Color4 from the string containing valid hexadecimal values
 external static Color4 FromHexString(String hex);
 /// Creates a new Color4 object set with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
 external static Color4 Lerp(Color4 left, Color4 right, num amount);
 /// Set the given "result" with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
 external static void LerpToRef(Color4 left, Color4 right, num amount, Color4 result);
 /// Creates a new Color4 from the starting index element of the given array
 external static Color4 FromArray(ArrayLike<num> array, [num offset]);
 /// Creates a new Color3 from integer values (< 256)
 external static Color4 FromInts(num r, num g, num b, num a);
 /// Check the content of a given array and convert it to an array containing RGBA data
 /// If the original array was already containing count * 4 values then it is returned directly
 external static List<num> CheckColors4(List<num> colors, num count); }

 /// Class representing a vector containing 2 coordinates
 @JS("BABYLON.Vector2" ) class Vector2 { // @Ignore
 Vector2 .fakeConstructor$() ;
 /// defines the first coordinate
 external num get x; external set x(num v);
 /// defines the second coordinate
 external num get y; external set y(num v);
 /// Creates a new Vector2 from the given x and y coordinates
 external factory Vector2(
 /// defines the first coordinate
 num x,
 /// defines the second coordinate
 num y);
 /// Gets a string with the Vector2 coordinates
 external String toString();
 /// Gets class name
 external String getClassName();
 /// Gets current vector hash code
 external num getHashCode();
 /// Sets the Vector2 coordinates in the given array or Float32Array from the given index.
 external Vector2 toArray(dynamic/*List<num>|Float32List*/ array, [num index]);
 /// Copy the current vector to an array
 external List<num> asArray();
 /// Sets the Vector2 coordinates with the given Vector2 coordinates
 external Vector2 copyFrom(Vector2 source);
 /// Sets the Vector2 coordinates with the given floats
 external Vector2 copyFromFloats(num x, num y);
 /// Sets the Vector2 coordinates with the given floats
 external Vector2 JS$set(num x, num y);
 /// Add another vector with the current one
 external Vector2 add(Vector2 otherVector);
 /// Sets the "result" coordinates with the addition of the current Vector2 and the given one coordinates
 external Vector2 addToRef(Vector2 otherVector, Vector2 result);
 /// Set the Vector2 coordinates by adding the given Vector2 coordinates
 external Vector2 addInPlace(Vector2 otherVector);
 /// Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates
 external Vector2 addVector3(Vector3 otherVector);
 /// Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2
 external Vector2 subtract(Vector2 otherVector);
 /// Sets the "result" coordinates with the subtraction of the given one from the current Vector2 coordinates.
 external Vector2 subtractToRef(Vector2 otherVector, Vector2 result);
 /// Sets the current Vector2 coordinates by subtracting from it the given one coordinates
 external Vector2 subtractInPlace(Vector2 otherVector);
 /// Multiplies in place the current Vector2 coordinates by the given ones
 external Vector2 multiplyInPlace(Vector2 otherVector);
 /// Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates
 external Vector2 multiply(Vector2 otherVector);
 /// Sets "result" coordinates with the multiplication of the current Vector2 and the given one coordinates
 external Vector2 multiplyToRef(Vector2 otherVector, Vector2 result);
 /// Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats
 external Vector2 multiplyByFloats(num x, num y);
 /// Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates
 external Vector2 divide(Vector2 otherVector);
 /// Sets the "result" coordinates with the Vector2 divided by the given one coordinates
 external Vector2 divideToRef(Vector2 otherVector, Vector2 result);
 /// Divides the current Vector3 coordinates by the given ones
 external Vector2 divideInPlace(Vector2 otherVector);
 /// Gets a new Vector2 with current Vector2 negated coordinates
 external Vector2 negate();
 /// Multiply the Vector2 coordinates by scale
 external Vector2 scaleInPlace(num scale);
 /// Returns a new Vector2 scaled by "scale" from the current Vector2
 external Vector2 scale(num scale);
 /// Scale the current Vector2 values by a factor to a given Vector2
 external Vector2 scaleToRef(num scale, Vector2 result);
 /// Scale the current Vector2 values by a factor and add the result to a given Vector2
 external Vector2 scaleAndAddToRef(num scale, Vector2 result);
 /// Gets a boolean if two vectors are equals
 external bool equals(Vector2 otherVector);
 /// Gets a boolean if two vectors are equals (using an epsilon value)
 external bool equalsWithEpsilon(Vector2 otherVector, [num epsilon]);
 /// Gets the length of the vector
 external num length();
 /// Gets the vector squared length
 external num lengthSquared();
 /// Normalize the vector
 external Vector2 normalize();
 /// Gets a new Vector2 copied from the Vector2
 external Vector2 clone();
 /// Gets a new Vector2(0, 0)
 external static Vector2 Zero();
 /// Gets a new Vector2(1, 1)
 external static Vector2 One();
 /// Gets a new Vector2 set from the given index element of the given array
 external static Vector2 FromArray(ArrayLike<num> array, [num offset]);
 /// Sets "result" from the given index element of the given array
 external static void FromArrayToRef(ArrayLike<num> array, num offset, Vector2 result);
 /// Gets a new Vector2 located for "amount" (float) on the CatmullRom spline defined by the given four Vector2
 external static Vector2 CatmullRom(Vector2 value1, Vector2 value2, Vector2 value3, Vector2 value4, num amount);
 /// Returns a new Vector2 set with same the coordinates than "value" ones if the vector "value" is in the square defined by "min" and "max".
 /// If a coordinate of "value" is lower than "min" coordinates, the returned Vector2 is given this "min" coordinate.
 /// If a coordinate of "value" is greater than "max" coordinates, the returned Vector2 is given this "max" coordinate
 external static Vector2 Clamp(Vector2 value, Vector2 min, Vector2 max);
 /// Returns a new Vector2 located for "amount" (float) on the Hermite spline defined by the vectors "value1", "value3", "tangent1", "tangent2"
 external static Vector2 Hermite(Vector2 value1, Vector2 tangent1, Vector2 value2, Vector2 tangent2, num amount);
 /// Returns a new Vector2 located for "amount" (float) on the linear interpolation between the vector "start" adn the vector "end".
 external static Vector2 Lerp(Vector2 start, Vector2 end, num amount);
 /// Gets the dot product of the vector "left" and the vector "right"
 external static num Dot(Vector2 left, Vector2 right);
 /// Returns a new Vector2 equal to the normalized given vector
 external static Vector2 Normalize(Vector2 vector);
 /// Gets a new Vector2 set with the minimal coordinate values from the "left" and "right" vectors
 external static Vector2 Minimize(Vector2 left, Vector2 right);
 /// Gets a new Vecto2 set with the maximal coordinate values from the "left" and "right" vectors
 external static Vector2 Maximize(Vector2 left, Vector2 right);
 /// Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix
 external static Vector2 Transform(Vector2 vector, Matrix transformation);
 /// Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector "result" coordinates
 external static void TransformToRef(Vector2 vector, Matrix transformation, Vector2 result);
 /// Determines if a given vector is included in a triangle
 external static bool PointInTriangle(Vector2 p, Vector2 p0, Vector2 p1, Vector2 p2);
 /// Gets the distance between the vectors "value1" and "value2"
 external static num Distance(Vector2 value1, Vector2 value2);
 /// Returns the squared distance between the vectors "value1" and "value2"
 external static num DistanceSquared(Vector2 value1, Vector2 value2);
 /// Gets a new Vector2 located at the center of the vectors "value1" and "value2"
 external static Vector2 Center(Vector2 value1, Vector2 value2);
 /// Gets the shortest distance (float) between the point "p" and the segment defined by the two points "segA" and "segB".
 external static num DistanceOfPointFromSegment(Vector2 p, Vector2 segA, Vector2 segB); }

 /// Classed used to store (x,y,z) vector representation
 /// A Vector3 is the main object used in 3D geometry
 /// It can represent etiher the coordinates of a point the space, either a direction
 /// Reminder: Babylon.js uses a left handed forward facing system
 @JS("BABYLON.Vector3" ) class Vector3 { // @Ignore
 Vector3 .fakeConstructor$() ;
 /// Defines the first coordinates (on X axis)
 external num get x; external set x(num v);
 /// Defines the second coordinates (on Y axis)
 external num get y; external set y(num v);
 /// Defines the third coordinates (on Z axis)
 external num get z; external set z(num v);
 /// Creates a new Vector3 object from the given x, y, z (floats) coordinates.
 external factory Vector3(
 /// Defines the first coordinates (on X axis)
 num x,
 /// Defines the second coordinates (on Y axis)
 num y,
 /// Defines the third coordinates (on Z axis)
 num z);
 /// Creates a string representation of the Vector3
 external String toString();
 /// Gets the class name
 external String getClassName();
 /// Creates the Vector3 hash code
 external num getHashCode();
 /// Creates an array containing three elements : the coordinates of the Vector3
 external List<num> asArray();
 /// Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3
 external Vector3 toArray(dynamic/*List<num>|Float32List*/ array, [num index]);
 /// Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)
 external Quaternion toQuaternion();
 /// Adds the given vector to the current Vector3
 external Vector3 addInPlace(Vector3 otherVector);
 /// Gets a new Vector3, result of the addition the current Vector3 and the given vector
 external Vector3 add(Vector3 otherVector);
 /// Adds the current Vector3 to the given one and stores the result in the vector "result"
 external Vector3 addToRef(Vector3 otherVector, Vector3 result);
 /// Subtract the given vector from the current Vector3
 external Vector3 subtractInPlace(Vector3 otherVector);
 /// Returns a new Vector3, result of the subtraction of the given vector from the current Vector3
 external Vector3 subtract(Vector3 otherVector);
 /// Subtracts the given vector from the current Vector3 and stores the result in the vector "result".
 external Vector3 subtractToRef(Vector3 otherVector, Vector3 result);
 /// Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates
 external Vector3 subtractFromFloats(num x, num y, num z);
 /// Subtracts the given floats from the current Vector3 coordinates and set the given vector "result" with this result
 external Vector3 subtractFromFloatsToRef(num x, num y, num z, Vector3 result);
 /// Gets a new Vector3 set with the current Vector3 negated coordinates
 external Vector3 negate();
 /// Multiplies the Vector3 coordinates by the float "scale"
 external Vector3 scaleInPlace(num scale);
 /// Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float "scale"
 external Vector3 scale(num scale);
 /// Multiplies the current Vector3 coordinates by the float "scale" and stores the result in the given vector "result" coordinates
 external Vector3 scaleToRef(num scale, Vector3 result);
 /// Scale the current Vector3 values by a factor and add the result to a given Vector3
 external Vector3 scaleAndAddToRef(num scale, Vector3 result);
 /// Returns true if the current Vector3 and the given vector coordinates are strictly equal
 external bool equals(Vector3 otherVector);
 /// Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon
 external bool equalsWithEpsilon(Vector3 otherVector, [num epsilon]);
 /// Returns true if the current Vector3 coordinates equals the given floats
 external bool equalsToFloats(num x, num y, num z);
 /// Multiplies the current Vector3 coordinates by the given ones
 external Vector3 multiplyInPlace(Vector3 otherVector);
 /// Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector
 external Vector3 multiply(Vector3 otherVector);
 /// Multiplies the current Vector3 by the given one and stores the result in the given vector "result"
 external Vector3 multiplyToRef(Vector3 otherVector, Vector3 result);
 /// Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats
 external Vector3 multiplyByFloats(num x, num y, num z);
 /// Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones
 external Vector3 divide(Vector3 otherVector);
 /// Divides the current Vector3 coordinates by the given ones and stores the result in the given vector "result"
 external Vector3 divideToRef(Vector3 otherVector, Vector3 result);
 /// Divides the current Vector3 coordinates by the given ones.
 external Vector3 divideInPlace(Vector3 otherVector);
 /// Updates the current Vector3 with the minimal coordinate values between its and the given vector ones
 external Vector3 minimizeInPlace(Vector3 other);
 /// Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.
 external Vector3 maximizeInPlace(Vector3 other);
 /// Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same
 external bool get isNonUniform; external set isNonUniform(bool v);
 /// Gets the length of the Vector3
 external num length();
 /// Gets the squared length of the Vector3
 external num lengthSquared();
 /// Normalize the current Vector3.
 /// Please note that this is an in place operation.
 external Vector3 normalize();
 /// Normalize the current Vector3 to a new vector
 external Vector3 normalizeToNew();
 /// Normalize the current Vector3 to the reference
 external Vector3 normalizeToRef(Vector3 reference);
 /// Creates a new Vector3 copied from the current Vector3
 external Vector3 clone();
 /// Copies the given vector coordinates to the current Vector3 ones
 external Vector3 copyFrom(Vector3 source);
 /// Copies the given floats to the current Vector3 coordinates
 external Vector3 copyFromFloats(num x, num y, num z);
 /// Copies the given floats to the current Vector3 coordinates
 external Vector3 JS$set(num x, num y, num z);
 /// Get the clip factor between two vectors
 external static num GetClipFactor(Vector3 vector0, Vector3 vector1, Vector3 axis, num size);
 /// Get angle between two vectors
 external static num GetAngleBetweenVectors(Vector3 vector0, Vector3 vector1, Vector3 normal);
 /// Returns a new Vector3 set from the index "offset" of the given array
 external static Vector3 FromArray(ArrayLike<num> array, [num offset]);
 /// Returns a new Vector3 set from the index "offset" of the given Float32Array
 /// This function is deprecated.  Use FromArray instead
 external static Vector3 FromFloatArray(Float32List array, [num offset]);
 /// Sets the given vector "result" with the element values from the index "offset" of the given array
 external static void FromArrayToRef(ArrayLike<num> array, num offset, Vector3 result);
 /// Sets the given vector "result" with the element values from the index "offset" of the given Float32Array
 /// This function is deprecated.  Use FromArrayToRef instead.
 external static void FromFloatArrayToRef(Float32List array, num offset, Vector3 result);
 /// Sets the given vector "result" with the given floats.
 external static void FromFloatsToRef(num x, num y, num z, Vector3 result);
 /// Returns a new Vector3 set to (0.0, 0.0, 0.0)
 external static Vector3 Zero();
 /// Returns a new Vector3 set to (1.0, 1.0, 1.0)
 external static Vector3 One();
 /// Returns a new Vector3 set to (0.0, 1.0, 0.0)
 external static Vector3 Up();
 /// Returns a new Vector3 set to (0.0, 0.0, 1.0)
 external static Vector3 Forward();
 /// Returns a new Vector3 set to (1.0, 0.0, 0.0)
 external static Vector3 Right();
 /// Returns a new Vector3 set to (-1.0, 0.0, 0.0)
 external static Vector3 Left();
 /// Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.
 /// This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
 external static Vector3 TransformCoordinates(Vector3 vector, Matrix transformation);
 /// Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given vector
 /// This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
 external static void TransformCoordinatesToRef(Vector3 vector, Matrix transformation, Vector3 result);
 /// Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)
 /// This method computes tranformed coordinates only, not transformed direction vectors
 external static void TransformCoordinatesFromFloatsToRef(num x, num y, num z, Matrix transformation, Vector3 result);
 /// Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector
 /// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
 external static Vector3 TransformNormal(Vector3 vector, Matrix transformation);
 /// Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector
 /// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
 external static void TransformNormalToRef(Vector3 vector, Matrix transformation, Vector3 result);
 /// Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z)
 /// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
 external static void TransformNormalFromFloatsToRef(num x, num y, num z, Matrix transformation, Vector3 result);
 /// Returns a new Vector3 located for "amount" on the CatmullRom interpolation spline defined by the vectors "value1", "value2", "value3", "value4"
 external static Vector3 CatmullRom(Vector3 value1, Vector3 value2, Vector3 value3, Vector3 value4, num amount);
 /// Returns a new Vector3 set with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
 /// If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
 /// If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one
 external static Vector3 Clamp(Vector3 value, Vector3 min, Vector3 max);
 /// Returns a new Vector3 located for "amount" (float) on the Hermite interpolation spline defined by the vectors "value1", "tangent1", "value2", "tangent2"
 external static Vector3 Hermite(Vector3 value1, Vector3 tangent1, Vector3 value2, Vector3 tangent2, num amount);
 /// Returns a new Vector3 located for "amount" (float) on the linear interpolation between the vectors "start" and "end"
 external static Vector3 Lerp(Vector3 start, Vector3 end, num amount);
 /// Sets the given vector "result" with the result of the linear interpolation from the vector "start" for "amount" to the vector "end"
 external static void LerpToRef(Vector3 start, Vector3 end, num amount, Vector3 result);
 /// Returns the dot product (float) between the vectors "left" and "right"
 external static num Dot(Vector3 left, Vector3 right);
 /// Returns a new Vector3 as the cross product of the vectors "left" and "right"
 /// The cross product is then orthogonal to both "left" and "right"
 external static Vector3 Cross(Vector3 left, Vector3 right);
 /// Sets the given vector "result" with the cross product of "left" and "right"
 /// The cross product is then orthogonal to both "left" and "right"
 external static void CrossToRef(Vector3 left, Vector3 right, Vector3 result);
 /// Returns a new Vector3 as the normalization of the given vector
 external static Vector3 Normalize(Vector3 vector);
 /// Sets the given vector "result" with the normalization of the given first vector
 external static void NormalizeToRef(Vector3 vector, Vector3 result); external static get JS$_viewportMatrixCache; external static set JS$_viewportMatrixCache(v);
 /// Project a Vector3 onto screen space
 external static Vector3 Project(Vector3 vector, Matrix world, Matrix transform, Viewport viewport);
 /// Unproject from screen space to object space
 external static Vector3 UnprojectFromTransform(Vector3 source, num viewportWidth, num viewportHeight, Matrix world, Matrix transform);
 /// Unproject from screen space to object space
 external static Vector3 Unproject(Vector3 source, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection);
 /// Unproject from screen space to object space
 external static void UnprojectToRef(Vector3 source, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection, Vector3 result);
 /// Unproject from screen space to object space
 external static void UnprojectFloatsToRef(num sourceX, num sourceY, num sourceZ, num viewportWidth, num viewportHeight, Matrix world, Matrix view, Matrix projection, Vector3 result);
 /// Gets the minimal coordinate values between two Vector3
 external static Vector3 Minimize(Vector3 left, Vector3 right);
 /// Gets the maximal coordinate values between two Vector3
 external static Vector3 Maximize(Vector3 left, Vector3 right);
 /// Returns the distance between the vectors "value1" and "value2"
 external static num Distance(Vector3 value1, Vector3 value2);
 /// Returns the squared distance between the vectors "value1" and "value2"
 external static num DistanceSquared(Vector3 value1, Vector3 value2);
 /// Returns a new Vector3 located at the center between "value1" and "value2"
 external static Vector3 Center(Vector3 value1, Vector3 value2);
 /// Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),
 /// RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply
 /// to something in order to rotate it from its local system to the given target system
 /// Note: axis1, axis2 and axis3 are normalized during this operation
 external static Vector3 RotationFromAxis(Vector3 axis1, Vector3 axis2, Vector3 axis3);
 /// The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3
 external static void RotationFromAxisToRef(Vector3 axis1, Vector3 axis2, Vector3 axis3, Vector3 ref); }

 @JS("BABYLON.Vector4" ) class Vector4 { // @Ignore
 Vector4 .fakeConstructor$() ;
 external num get x; external set x(num v); external num get y; external set y(num v); external num get z; external set z(num v); external num get w; external set w(num v);
 /// Creates a Vector4 object from the given floats.
 external factory Vector4(num x, num y, num z, num w);
 /// Returns the string with the Vector4 coordinates.
 external String toString();
 /// Returns the string "Vector4".
 external String getClassName();
 /// Returns the Vector4 hash code.
 external num getHashCode();
 /// Returns a new array populated with 4 elements : the Vector4 coordinates.
 external List<num> asArray();
 /// Populates the given array from the given index with the Vector4 coordinates.
 /// Returns the Vector4.
 external Vector4 toArray(dynamic/*List<num>|Float32List*/ array, [num index]);
 /// Adds the given vector to the current Vector4.
 /// Returns the updated Vector4.
 external Vector4 addInPlace(Vector4 otherVector);
 /// Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.
 external Vector4 add(Vector4 otherVector);
 /// Updates the given vector "result" with the result of the addition of the current Vector4 and the given one.
 /// Returns the current Vector4.
 external Vector4 addToRef(Vector4 otherVector, Vector4 result);
 /// Subtract in place the given vector from the current Vector4.
 /// Returns the updated Vector4.
 external Vector4 subtractInPlace(Vector4 otherVector);
 /// Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.
 external Vector4 subtract(Vector4 otherVector);
 /// Sets the given vector "result" with the result of the subtraction of the given vector from the current Vector4.
 /// Returns the current Vector4.
 external Vector4 subtractToRef(Vector4 otherVector, Vector4 result);
 /// Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.
 external Vector4 subtractFromFloats(num x, num y, num z, num w);
 /// Sets the given vector "result" set with the result of the subtraction of the given floats from the current Vector4 coordinates.
 /// Returns the current Vector4.
 external Vector4 subtractFromFloatsToRef(num x, num y, num z, num w, Vector4 result);
 /// Returns a new Vector4 set with the current Vector4 negated coordinates.
 external Vector4 negate();
 /// Multiplies the current Vector4 coordinates by scale (float).
 /// Returns the updated Vector4.
 external Vector4 scaleInPlace(num scale);
 /// Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).
 external Vector4 scale(num scale);
 /// Sets the given vector "result" with the current Vector4 coordinates multiplied by scale (float).
 /// Returns the current Vector4.
 external Vector4 scaleToRef(num scale, Vector4 result);
 /// Scale the current Vector4 values by a factor and add the result to a given Vector4
 external Vector4 scaleAndAddToRef(num scale, Vector4 result);
 /// Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.
 external bool equals(Vector4 otherVector);
 /// Boolean : True if the current Vector4 coordinates are each beneath the distance "epsilon" from the given vector ones.
 external bool equalsWithEpsilon(Vector4 otherVector, [num epsilon]);
 /// Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.
 external bool equalsToFloats(num x, num y, num z, num w);
 /// Multiplies in place the current Vector4 by the given one.
 /// Returns the updated Vector4.
 external Vector4 multiplyInPlace(Vector4 otherVector);
 /// Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.
 external Vector4 multiply(Vector4 otherVector);
 /// Updates the given vector "result" with the multiplication result of the current Vector4 and the given one.
 /// Returns the current Vector4.
 external Vector4 multiplyToRef(Vector4 otherVector, Vector4 result);
 /// Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.
 external Vector4 multiplyByFloats(num x, num y, num z, num w);
 /// Returns a new Vector4 set with the division result of the current Vector4 by the given one.
 external Vector4 divide(Vector4 otherVector);
 /// Updates the given vector "result" with the division result of the current Vector4 by the given one.
 /// Returns the current Vector4.
 external Vector4 divideToRef(Vector4 otherVector, Vector4 result);
 /// Divides the current Vector3 coordinates by the given ones.
 external Vector4 divideInPlace(Vector4 otherVector);
 /// Updates the Vector4 coordinates with the minimum values between its own and the given vector ones
 external Vector4 minimizeInPlace(Vector4 other);
 /// Updates the Vector4 coordinates with the maximum values between its own and the given vector ones
 external Vector4 maximizeInPlace(Vector4 other);
 /// Returns the Vector4 length (float).
 external num length();
 /// Returns the Vector4 squared length (float).
 external num lengthSquared();
 /// Normalizes in place the Vector4.
 /// Returns the updated Vector4.
 external Vector4 normalize();
 /// Returns a new Vector3 from the Vector4 (x, y, z) coordinates.
 external Vector3 toVector3();
 /// Returns a new Vector4 copied from the current one.
 external Vector4 clone();
 /// Updates the current Vector4 with the given one coordinates.
 /// Returns the updated Vector4.
 external Vector4 copyFrom(Vector4 source);
 /// Updates the current Vector4 coordinates with the given floats.
 /// Returns the updated Vector4.
 external Vector4 copyFromFloats(num x, num y, num z, num w);
 /// Updates the current Vector4 coordinates with the given floats.
 /// Returns the updated Vector4.
 external Vector4 JS$set(num x, num y, num z, num w);
 /// Returns a new Vector4 set from the starting index of the given array.
 external static Vector4 FromArray(ArrayLike<num> array, [num offset]);
 /// Updates the given vector "result" from the starting index of the given array.
 external static void FromArrayToRef(ArrayLike<num> array, num offset, Vector4 result);
 /// Updates the given vector "result" from the starting index of the given Float32Array.
 external static void FromFloatArrayToRef(Float32List array, num offset, Vector4 result);
 /// Updates the given vector "result" coordinates from the given floats.
 external static void FromFloatsToRef(num x, num y, num z, num w, Vector4 result);
 /// Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)
 external static Vector4 Zero();
 /// Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)
 external static Vector4 One();
 /// Returns a new normalized Vector4 from the given one.
 external static Vector4 Normalize(Vector4 vector);
 /// Updates the given vector "result" from the normalization of the given one.
 external static void NormalizeToRef(Vector4 vector, Vector4 result); external static Vector4 Minimize(Vector4 left, Vector4 right); external static Vector4 Maximize(Vector4 left, Vector4 right);
 /// Returns the distance (float) between the vectors "value1" and "value2".
 external static num Distance(Vector4 value1, Vector4 value2);
 /// Returns the squared distance (float) between the vectors "value1" and "value2".
 external static num DistanceSquared(Vector4 value1, Vector4 value2);
 /// Returns a new Vector4 located at the center between the vectors "value1" and "value2".
 external static Vector4 Center(Vector4 value1, Vector4 value2);
 /// Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.
 /// This methods computes transformed normalized direction vectors only.
 external static Vector4 TransformNormal(Vector4 vector, Matrix transformation);
 /// Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector.
 /// This methods computes transformed normalized direction vectors only.
 external static void TransformNormalToRef(Vector4 vector, Matrix transformation, Vector4 result);
 /// Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).
 /// This methods computes transformed normalized direction vectors only.
 external static void TransformNormalFromFloatsToRef(num x, num y, num z, num w, Matrix transformation, Vector4 result); }

 @anonymous @JS() abstract class ISize { external num get width; external set width(num v); external num get height; external set height(num v); external factory ISize({ num width, num height}); }

 @JS("BABYLON.Size" ) class Size implements ISize { // @Ignore
 Size .fakeConstructor$() ;
 external num get width; external set width(num v); external num get height; external set height(num v);
 /// Creates a Size object from the given width and height (floats).
 external factory Size(num width, num height); external String toString();
 /// Returns the string "Size"
 external String getClassName();
 /// Returns the Size hash code.
 external num getHashCode();
 /// Updates the current size from the given one.
 /// Returns the updated Size.
 external void copyFrom(Size src);
 /// Updates in place the current Size from the given floats.
 /// Returns the updated Size.
 external Size copyFromFloats(num width, num height);
 /// Updates in place the current Size from the given floats.
 /// Returns the updated Size.
 external Size JS$set(num width, num height);
 /// Returns a new Size set with the multiplication result of the current Size and the given floats.
 external Size multiplyByFloats(num w, num h);
 /// Returns a new Size copied from the given one.
 external Size clone();
 /// Boolean : True if the current Size and the given one width and height are strictly equal.
 external bool equals(Size other);
 /// Returns the surface of the Size : width * height (float).
 external num get surface; external set surface(num v);
 /// Returns a new Size set to (0.0, 0.0)
 external static Size Zero();
 /// Returns a new Size set as the addition result of the current Size and the given one.
 external Size add(Size otherSize);
 /// Returns a new Size set as the subtraction result of  the given one from the current Size.
 external Size subtract(Size otherSize);
 /// Returns a new Size set at the linear interpolation "amount" between "start" and "end".
 external static Size Lerp(Size start, Size end, num amount); }

 /// Class used to store quaternion data
 /// @see https://en.wikipedia.org/wiki/Quaternion
 /// @see http://doc.babylonjs.com/features/position,_rotation,_scaling
 @JS("BABYLON.Quaternion" ) class Quaternion { // @Ignore
 Quaternion .fakeConstructor$() ;
 /// defines the first component (0 by default)
 external num get x; external set x(num v);
 /// defines the second component (0 by default)
 external num get y; external set y(num v);
 /// defines the third component (0 by default)
 external num get z; external set z(num v);
 /// defines the fourth component (1.0 by default)
 external num get w; external set w(num v);
 /// Creates a new Quaternion from the given floats
 external factory Quaternion([
 /// defines the first component (0 by default)
 num x,
 /// defines the second component (0 by default)
 num y,
 /// defines the third component (0 by default)
 num z,
 /// defines the fourth component (1.0 by default)
 num w]);
 /// Gets a string representation for the current quaternion
 external String toString();
 /// Gets the class name of the quaternion
 external String getClassName();
 /// Gets a hash code for this quaternion
 external num getHashCode();
 /// Copy the quaternion to an array
 external List<num> asArray();
 /// Check if two quaternions are equals
 external bool equals(Quaternion otherQuaternion);
 /// Clone the current quaternion
 external Quaternion clone();
 /// Copy a quaternion to the current one
 external Quaternion copyFrom(Quaternion other);
 /// Updates the current quaternion with the given float coordinates
 external Quaternion copyFromFloats(num x, num y, num z, num w);
 /// Updates the current quaternion from the given float coordinates
 external Quaternion JS$set(num x, num y, num z, num w);
 /// Adds two quaternions
 external Quaternion add(Quaternion other);
 /// Add a quaternion to the current one
 external Quaternion addInPlace(Quaternion other);
 /// Subtract two quaternions
 external Quaternion subtract(Quaternion other);
 /// Multiplies the current quaternion by a scale factor
 external Quaternion scale(num value);
 /// Scale the current quaternion values by a factor and stores the result to a given quaternion
 external Quaternion scaleToRef(num scale, Quaternion result);
 /// Multiplies in place the current quaternion by a scale factor
 external Quaternion scaleInPlace(num value);
 /// Scale the current quaternion values by a factor and add the result to a given quaternion
 external Quaternion scaleAndAddToRef(num scale, Quaternion result);
 /// Multiplies two quaternions
 external Quaternion multiply(Quaternion q1);
 /// Sets the given "result" as the the multiplication result of the current one with the given one "q1"
 external Quaternion multiplyToRef(Quaternion q1, Quaternion result);
 /// Updates the current quaternion with the multiplication of itself with the given one "q1"
 external Quaternion multiplyInPlace(Quaternion q1);
 /// Conjugates (1-q) the current quaternion and stores the result in the given quaternion
 external Quaternion conjugateToRef(Quaternion ref);
 /// Conjugates in place (1-q) the current quaternion
 external Quaternion conjugateInPlace();
 /// Conjugates in place (1-q) the current quaternion
 external Quaternion conjugate();
 /// Gets length of current quaternion
 external num length();
 /// Normalize in place the current quaternion
 external Quaternion normalize();
 /// Returns a new Vector3 set with the Euler angles translated from the current quaternion
 external Vector3 toEulerAngles([String order]);
 /// Sets the given vector3 "result" with the Euler angles translated from the current quaternion
 external Quaternion toEulerAnglesToRef(Vector3 result, [String order]);
 /// Updates the given rotation matrix with the current quaternion values
 external Quaternion toRotationMatrix(Matrix result);
 /// Updates the current quaternion from the given rotation matrix values
 external Quaternion fromRotationMatrix(Matrix matrix);
 /// Creates a new quaternion from a rotation matrix
 external static Quaternion FromRotationMatrix(Matrix matrix);
 /// Updates the given quaternion with the given rotation matrix values
 external static void FromRotationMatrixToRef(Matrix matrix, Quaternion result);
 /// Returns the dot product (float) between the quaternions "left" and "right"
 external static num Dot(Quaternion left, Quaternion right);
 /// Checks if the two quaternions are close to each other
 external static bool AreClose(Quaternion quat0, Quaternion quat1);
 /// Creates an empty quaternion
 external static Quaternion Zero();
 /// Inverse a given quaternion
 external static Quaternion Inverse(Quaternion q);
 /// Creates an identity quaternion
 external static Quaternion Identity();
 /// Gets a boolean indicating if the given quaternion is identity
 external static bool IsIdentity(Quaternion quaternion);
 /// Creates a quaternion from a rotation around an axis
 external static Quaternion RotationAxis(Vector3 axis, num angle);
 /// Creates a rotation around an axis and stores it into the given quaternion
 external static Quaternion RotationAxisToRef(Vector3 axis, num angle, Quaternion result);
 /// Creates a new quaternion from data stored into an array
 external static Quaternion FromArray(ArrayLike<num> array, [num offset]);
 /// Creates a new quaternion from the given Euler float angles (y, x, z)
 external static Quaternion RotationYawPitchRoll(num yaw, num pitch, num roll);
 /// Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion
 external static void RotationYawPitchRollToRef(num yaw, num pitch, num roll, Quaternion result);
 /// Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation
 external static Quaternion RotationAlphaBetaGamma(num alpha, num beta, num gamma);
 /// Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion
 external static void RotationAlphaBetaGammaToRef(num alpha, num beta, num gamma, Quaternion result);
 /// Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)
 external static Quaternion RotationQuaternionFromAxis(Vector3 axis1, Vector3 axis2, Vector3 axis3);
 /// Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion
 external static void RotationQuaternionFromAxisToRef(Vector3 axis1, Vector3 axis2, Vector3 axis3, Quaternion ref);
 /// Interpolates between two quaternions
 external static Quaternion Slerp(Quaternion left, Quaternion right, num amount);
 /// Interpolates between two quaternions and stores it into a target quaternion
 external static void SlerpToRef(Quaternion left, Quaternion right, num amount, Quaternion result);
 /// Interpolate between two quaternions using Hermite interpolation
 external static Quaternion Hermite(Quaternion value1, Quaternion tangent1, Quaternion value2, Quaternion tangent2, num amount); }

 /// Class used to store matrix data (4x4)
 @JS("BABYLON.Matrix" ) class Matrix { // @Ignore
 Matrix .fakeConstructor$() ;
 external static get JS$_tempQuaternion; external static set JS$_tempQuaternion(v); external static get JS$_xAxis; external static set JS$_xAxis(v); external static get JS$_yAxis; external static set JS$_yAxis(v); external static get JS$_zAxis; external static set JS$_zAxis(v); external static get JS$_updateFlagSeed; external static set JS$_updateFlagSeed(v); external static get JS$_identityReadOnly; external static set JS$_identityReadOnly(v); external get JS$_isIdentity; external set JS$_isIdentity(v); external get JS$_isIdentityDirty; external set JS$_isIdentityDirty(v);
 /// Gets the update flag of the matrix which is an unique number for the matrix.
 /// It will be incremented every time the matrix data change.
 /// You can use it to speed the comparison between two versions of the same matrix.
 external num get updateFlag; external set updateFlag(num v);
 /// Gets or sets the internal data of the matrix
 external Float32List get m; external set m(Float32List v);
 /// @hidden
 external void JS$_markAsUpdated();
 /// Creates an empty matrix (filled with zeros)
 external factory Matrix();
 /// Check if the current matrix is indentity
 external bool isIdentity([bool considerAsTextureMatrix]);
 /// Gets the determinant of the matrix
 external num determinant();
 /// Returns the matrix as a Float32Array
 external Float32List toArray();
 /// Returns the matrix as a Float32Array
 external Float32List asArray();
 /// Inverts the current matrix in place
 external Matrix invert();
 /// Sets all the matrix elements to zero
 external Matrix reset();
 /// Adds the current matrix with a second one
 external Matrix add(Matrix other);
 /// Sets the given matrix "result" to the addition of the current matrix and the given one
 external Matrix addToRef(Matrix other, Matrix result);
 /// Adds in place the given matrix to the current matrix
 external Matrix addToSelf(Matrix other);
 /// Sets the given matrix to the current inverted Matrix
 external Matrix invertToRef(Matrix other);
 /// Inserts the translation vector (using 3 floats) in the current matrix
 external Matrix setTranslationFromFloats(num x, num y, num z);
 /// Inserts the translation vector in the current matrix
 external Matrix setTranslation(Vector3 vector3);
 /// Gets the translation value of the current matrix
 external Vector3 getTranslation();
 /// Fill a Vector3 with the extracted translation from the matrix
 external Matrix getTranslationToRef(Vector3 result);
 /// Remove rotation and scaling part from the matrix
 external Matrix removeRotationAndScaling();
 /// Multiply two matrices
 external Matrix multiply(Matrix other);
 /// Copy the current matrix from the given one
 external Matrix copyFrom(Matrix other);
 /// Populates the given array from the starting index with the current matrix values
 external Matrix copyToArray(Float32List array, [num offset]);
 /// Sets the given matrix "result" with the multiplication result of the current Matrix and the given one
 external Matrix multiplyToRef(Matrix other, Matrix result);
 /// Sets the Float32Array "result" from the given index "offset" with the multiplication of the current matrix and the given one
 external Matrix multiplyToArray(Matrix other, Float32List result, num offset);
 /// Check equality between this matrix and a second one
 external bool equals(Matrix value);
 /// Clone the current matrix
 external Matrix clone();
 /// Returns the name of the current matrix class
 external String getClassName();
 /// Gets the hash code of the current matrix
 external num getHashCode();
 /// Decomposes the current Matrix into a translation, rotation and scaling components
 external bool decompose([Vector3 scale, Quaternion rotation, Vector3 translation]);
 /// Gets specific row of the matrix
 external Vector4/*Vector4|Null*/ getRow(num index);
 /// Sets the index-th row of the current matrix to the vector4 values
 external Matrix setRow(num index, Vector4 row);
 /// Compute the transpose of the matrix
 external Matrix transpose();
 /// Compute the transpose of the matrix and store it in a given matrix
 external Matrix transposeToRef(Matrix result);
 /// Sets the index-th row of the current matrix with the given 4 x float values
 external Matrix setRowFromFloats(num index, num x, num y, num z, num w);
 /// Compute a new matrix set with the current matrix values multiplied by scale (float)
 external Matrix scale(num scale);
 /// Scale the current matrix values by a factor to a given result matrix
 external Matrix scaleToRef(num scale, Matrix result);
 /// Scale the current matrix values by a factor and add the result to a given matrix
 external Matrix scaleAndAddToRef(num scale, Matrix result);
 /// Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).
 external void toNormalMatrix(Matrix ref);
 /// Gets only rotation part of the current matrix
 external Matrix getRotationMatrix();
 /// Extracts the rotation matrix from the current one and sets it as the given "result"
 external Matrix getRotationMatrixToRef(Matrix result);
 /// Creates a matrix from an array
 external static Matrix FromArray(ArrayLike<num> array, [num offset]);
 /// Copy the content of an array into a given matrix
 external static void FromArrayToRef(ArrayLike<num> array, num offset, Matrix result);
 /// Stores an array into a matrix after having multiplied each component by a given factor
 external static void FromFloat32ArrayToRefScaled(Float32List array, num offset, num scale, Matrix result);
 /// Stores a list of values (16) inside a given matrix
 external static void FromValuesToRef(num initialM11, num initialM12, num initialM13, num initialM14, num initialM21, num initialM22, num initialM23, num initialM24, num initialM31, num initialM32, num initialM33, num initialM34, num initialM41, num initialM42, num initialM43, num initialM44, Matrix result);
 /// Gets an identity matrix that must not be updated
 external static Matrix get IdentityReadOnly; external static set IdentityReadOnly(Matrix v);
 /// Creates new matrix from a list of values (16)
 external static Matrix FromValues(num initialM11, num initialM12, num initialM13, num initialM14, num initialM21, num initialM22, num initialM23, num initialM24, num initialM31, num initialM32, num initialM33, num initialM34, num initialM41, num initialM42, num initialM43, num initialM44);
 /// Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)
 external static Matrix Compose(Vector3 scale, Quaternion rotation, Vector3 translation);
 /// Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)
 external static void ComposeToRef(Vector3 scale, Quaternion rotation, Vector3 translation, Matrix result);
 /// Creates a new identity matrix
 external static Matrix Identity();
 /// Creates a new identity matrix and stores the result in a given matrix
 external static void IdentityToRef(Matrix result);
 /// Creates a new zero matrix
 external static Matrix Zero();
 /// Creates a new rotation matrix for "angle" radians around the X axis
 external static Matrix RotationX(num angle);
 /// Creates a new matrix as the invert of a given matrix
 external static Matrix Invert(Matrix source);
 /// Creates a new rotation matrix for "angle" radians around the X axis and stores it in a given matrix
 external static void RotationXToRef(num angle, Matrix result);
 /// Creates a new rotation matrix for "angle" radians around the Y axis
 external static Matrix RotationY(num angle);
 /// Creates a new rotation matrix for "angle" radians around the Y axis and stores it in a given matrix
 external static void RotationYToRef(num angle, Matrix result);
 /// Creates a new rotation matrix for "angle" radians around the Z axis
 external static Matrix RotationZ(num angle);
 /// Creates a new rotation matrix for "angle" radians around the Z axis and stores it in a given matrix
 external static void RotationZToRef(num angle, Matrix result);
 /// Creates a new rotation matrix for "angle" radians around the given axis
 external static Matrix RotationAxis(Vector3 axis, num angle);
 /// Creates a new rotation matrix for "angle" radians around the given axis and stores it in a given matrix
 external static void RotationAxisToRef(Vector3 axis, num angle, Matrix result);
 /// Creates a rotation matrix
 external static Matrix RotationYawPitchRoll(num yaw, num pitch, num roll);
 /// Creates a rotation matrix and stores it in a given matrix
 external static void RotationYawPitchRollToRef(num yaw, num pitch, num roll, Matrix result);
 /// Creates a scaling matrix
 external static Matrix Scaling(num x, num y, num z);
 /// Creates a scaling matrix and stores it in a given matrix
 external static void ScalingToRef(num x, num y, num z, Matrix result);
 /// Creates a translation matrix
 external static Matrix Translation(num x, num y, num z);
 /// Creates a translation matrix and stores it in a given matrix
 external static void TranslationToRef(num x, num y, num z, Matrix result);
 /// Returns a new Matrix whose values are the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".
 external static Matrix Lerp(Matrix startValue, Matrix endValue, num gradient);
 /// Set the given matrix "result" as the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".
 external static void LerpToRef(Matrix startValue, Matrix endValue, num gradient, Matrix result);
 /// Builds a new matrix whose values are computed by:
 /// * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
 /// * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
 /// * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices
 external static Matrix DecomposeLerp(Matrix startValue, Matrix endValue, num gradient);
 /// Update a matrix to values which are computed by:
 /// * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
 /// * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
 /// * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices
 external static void DecomposeLerpToRef(Matrix startValue, Matrix endValue, num gradient, Matrix result);
 /// Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
 /// This function works in left handed mode
 external static Matrix LookAtLH(Vector3 eye, Vector3 target, Vector3 up);
 /// Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
 /// This function works in left handed mode
 external static void LookAtLHToRef(Vector3 eye, Vector3 target, Vector3 up, Matrix result);
 /// Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
 /// This function works in right handed mode
 external static Matrix LookAtRH(Vector3 eye, Vector3 target, Vector3 up);
 /// Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
 /// This function works in right handed mode
 external static void LookAtRHToRef(Vector3 eye, Vector3 target, Vector3 up, Matrix result);
 /// Create a left-handed orthographic projection matrix
 external static Matrix OrthoLH(num width, num height, num znear, num zfar);
 /// Store a left-handed orthographic projection to a given matrix
 external static void OrthoLHToRef(num width, num height, num znear, num zfar, Matrix result);
 /// Create a left-handed orthographic projection matrix
 external static Matrix OrthoOffCenterLH(num left, num right, num bottom, num top, num znear, num zfar);
 /// Stores a left-handed orthographic projection into a given matrix
 external static void OrthoOffCenterLHToRef(num left, num right, num bottom, num top, num znear, num zfar, Matrix result);
 /// Creates a right-handed orthographic projection matrix
 external static Matrix OrthoOffCenterRH(num left, num right, num bottom, num top, num znear, num zfar);
 /// Stores a right-handed orthographic projection into a given matrix
 external static void OrthoOffCenterRHToRef(num left, num right, num bottom, num top, num znear, num zfar, Matrix result);
 /// Creates a left-handed perspective projection matrix
 external static Matrix PerspectiveLH(num width, num height, num znear, num zfar);
 /// Creates a left-handed perspective projection matrix
 external static Matrix PerspectiveFovLH(num fov, num aspect, num znear, num zfar);
 /// Stores a left-handed perspective projection into a given matrix
 external static void PerspectiveFovLHToRef(num fov, num aspect, num znear, num zfar, Matrix result, [bool isVerticalFovFixed]);
 /// Creates a right-handed perspective projection matrix
 external static Matrix PerspectiveFovRH(num fov, num aspect, num znear, num zfar);
 /// Stores a right-handed perspective projection into a given matrix
 external static void PerspectiveFovRHToRef(num fov, num aspect, num znear, num zfar, Matrix result, [bool isVerticalFovFixed]);
 /// Stores a perspective projection for WebVR info a given matrix
 external static void PerspectiveFovWebVRToRef(dynamic/*{
            upDegrees: number;
            downDegrees: number;
            leftDegrees: number;
            rightDegrees: number;
        }*/ fov, num znear, num zfar, Matrix result, [bool rightHanded]);
 /// Computes a complete transformation matrix
 external static Matrix GetFinalMatrix(Viewport viewport, Matrix world, Matrix view, Matrix projection, num zmin, num zmax);
 /// Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array
 external static Float32List GetAsMatrix2x2(Matrix matrix);
 /// Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array
 external static Float32List GetAsMatrix3x3(Matrix matrix);
 /// Compute the transpose of a given matrix
 external static Matrix Transpose(Matrix matrix);
 /// Compute the transpose of a matrix and store it in a target matrix
 external static void TransposeToRef(Matrix matrix, Matrix result);
 /// Computes a reflection matrix from a plane
 external static Matrix Reflection(Plane plane);
 /// Computes a reflection matrix from a plane
 external static void ReflectionToRef(Plane plane, Matrix result);
 /// Sets the given matrix as a rotation matrix composed from the 3 left handed axes
 external static void FromXYZAxesToRef(Vector3 xaxis, Vector3 yaxis, Vector3 zaxis, Matrix result);
 /// Creates a rotation matrix from a quaternion and stores it in a target matrix
 external static void FromQuaternionToRef(Quaternion quat, Matrix result); }

 @JS("BABYLON.Plane" ) class Plane { // @Ignore
 Plane .fakeConstructor$() ;
 external Vector3 get normal; external set normal(Vector3 v); external num get d; external set d(num v);
 /// Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0
 external factory Plane(num a, num b, num c, num d);
 /// Returns the plane coordinates as a new array of 4 elements [a, b, c, d].
 external List<num> asArray();
 /// Returns a new plane copied from the current Plane.
 external Plane clone();
 /// Returns the string "Plane".
 external String getClassName();
 /// Returns the Plane hash code.
 external num getHashCode();
 /// Normalize the current Plane in place.
 /// Returns the updated Plane.
 external Plane normalize();
 /// Returns a new Plane as the result of the transformation of the current Plane by the given matrix.
 external Plane transform(Matrix transformation);
 /// Returns the dot product (float) of the point coordinates and the plane normal.
 external num dotCoordinate(Vector3 point);
 /// Updates the current Plane from the plane defined by the three given points.
 /// Returns the updated Plane.
 external Plane copyFromPoints(Vector3 point1, Vector3 point2, Vector3 point3);
 /// Boolean : True is the vector "direction"  is the same side than the plane normal.
 external bool isFrontFacingTo(Vector3 direction, num epsilon);
 /// Returns the signed distance (float) from the given point to the Plane.
 external num signedDistanceTo(Vector3 point);
 /// Returns a new Plane from the given array.
 external static Plane FromArray(ArrayLike<num> array);
 /// Returns a new Plane defined by the three given points.
 external static Plane FromPoints(Vector3 point1, Vector3 point2, Vector3 point3);
 /// Returns a new Plane the normal vector to this plane at the given origin point.
 /// Note : the vector "normal" is updated because normalized.
 external static Plane FromPositionAndNormal(Vector3 origin, Vector3 normal);
 /// Returns the signed distance between the plane defined by the normal vector at the "origin"" point and the given other point.
 external static num SignedDistanceToPlaneFromPositionAndNormal(Vector3 origin, Vector3 normal, Vector3 point); }

 @JS("BABYLON.Viewport" ) class Viewport { // @Ignore
 Viewport .fakeConstructor$() ;
 external num get x; external set x(num v); external num get y; external set y(num v); external num get width; external set width(num v); external num get height; external set height(num v);
 /// Creates a Viewport object located at (x, y) and sized (width, height).
 external factory Viewport(num x, num y, num width, num height); external Viewport toGlobal(dynamic/*num|Engine*/ renderWidthOrEngine, num renderHeight);
 /// Returns a new Viewport copied from the current one.
 external Viewport clone(); }

 @JS("BABYLON.Frustum" ) class Frustum { // @Ignore
 Frustum .fakeConstructor$() ;
 /// Returns a new array of 6 Frustum planes computed by the given transformation matrix.
 external static List<Plane> GetPlanes(Matrix transform); external static void GetNearPlaneToRef(Matrix transform, Plane frustumPlane); external static void GetFarPlaneToRef(Matrix transform, Plane frustumPlane); external static void GetLeftPlaneToRef(Matrix transform, Plane frustumPlane); external static void GetRightPlaneToRef(Matrix transform, Plane frustumPlane); external static void GetTopPlaneToRef(Matrix transform, Plane frustumPlane); external static void GetBottomPlaneToRef(Matrix transform, Plane frustumPlane);
 /// Sets the given array "frustumPlanes" with the 6 Frustum planes computed by the given transformation matrix.
 external static void GetPlanesToRef(Matrix transform, List<Plane> frustumPlanes); }

 /// Defines supported spaces
 @JS("BABYLON.Space" ) class Space { external static num get
 /// Local (object) space
 LOCAL; external static num get
 /// World space
 WORLD; external static num get
 /// Bone space
 BONE; }
 /// Defines the 3 main axes
 @JS("BABYLON.Axis" ) class Axis { // @Ignore
 Axis .fakeConstructor$() ;
 /// X axis
 external static Vector3 get X; external static set X(Vector3 v);
 /// Y axis
 external static Vector3 get Y; external static set Y(Vector3 v);
 /// Z axis
 external static Vector3 get Z; external static set Z(Vector3 v); }

 @JS("BABYLON.BezierCurve" ) class BezierCurve { // @Ignore
 BezierCurve .fakeConstructor$() ;
 /// Returns the cubic Bezier interpolated value (float) at "t" (float) from the given x1, y1, x2, y2 floats.
 external static num interpolate(num t, num x1, num y1, num x2, num y2); }

 /// Defines potential orientation for back face culling
 @JS("BABYLON.Orientation" ) class Orientation { external static num get
 /// Clockwise
 CW; external static num get
 /// Counter clockwise
 CCW; }
 /// Defines angle representation
 @JS("BABYLON.Angle" ) class Angle { // @Ignore
 Angle .fakeConstructor$() ;
 external get JS$_radians; external set JS$_radians(v);
 /// Creates an Angle object of "radians" radians (float).
 external factory Angle(num radians);
 /// Get value in degrees
 external num degrees();
 /// Get value in radians
 external num radians();
 /// Gets a new Angle object valued with the angle value in radians between the two given vectors
 external static Angle BetweenTwoPoints(Vector2 a, Vector2 b);
 /// Gets a new Angle object from the given float in radians
 external static Angle FromRadians(num radians);
 /// Gets a new Angle object from the given float in degrees
 external static Angle FromDegrees(num degrees); }

 @JS("BABYLON.Arc2" ) class Arc2 { // @Ignore
 Arc2 .fakeConstructor$() ;
 external Vector2 get startPoint; external set startPoint(Vector2 v); external Vector2 get midPoint; external set midPoint(Vector2 v); external Vector2 get endPoint; external set endPoint(Vector2 v); external Vector2 get centerPoint; external set centerPoint(Vector2 v); external num get radius; external set radius(num v); external Angle get angle; external set angle(Angle v); external Angle get startAngle; external set startAngle(Angle v); external num/*enum Orientation*/ get orientation; external set orientation(num/*enum Orientation*/ v);
 /// Creates an Arc object from the three given points : start, middle and end.
 external factory Arc2(Vector2 startPoint, Vector2 midPoint, Vector2 endPoint); }

 @JS("BABYLON.Path2" ) class Path2 { // @Ignore
 Path2 .fakeConstructor$() ;
 external get JS$_points; external set JS$_points(v); external get JS$_length; external set JS$_length(v); external bool get closed; external set closed(bool v);
 /// Creates a Path2 object from the starting 2D coordinates x and y.
 external factory Path2(num x, num y);
 /// Adds a new segment until the given coordinates (x, y) to the current Path2.
 /// Returns the updated Path2.
 external Path2 addLineTo(num x, num y);
 /// Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.
 /// Returns the updated Path2.
 external Path2 addArcTo(num midX, num midY, num endX, num endY, [num numberOfSegments]);
 /// Closes the Path2.
 /// Returns the Path2.
 external Path2 close();
 /// Returns the Path2 total length (float).
 external num length();
 /// Returns the Path2 internal array of points.
 external List<Vector2> getPoints();
 /// Returns a new Vector2 located at a percentage of the Path2 total length on this path.
 external Vector2 getPointAtLengthPosition(num normalizedLengthPosition);
 /// Returns a new Path2 starting at the coordinates (x, y).
 external static Path2 StartingAt(num x, num y); }

 @JS("BABYLON.Path3D" ) class Path3D { // @Ignore
 Path3D .fakeConstructor$() ;
 external List<Vector3> get path; external set path(List<Vector3> v); external get JS$_curve; external set JS$_curve(v); external get JS$_distances; external set JS$_distances(v); external get JS$_tangents; external set JS$_tangents(v); external get JS$_normals; external set JS$_normals(v); external get JS$_binormals; external set JS$_binormals(v); external get JS$_raw; external set JS$_raw(v);
 /// new Path3D(path, normal, raw)
 /// Creates a Path3D. A Path3D is a logical math object, so not a mesh.
 /// please read the description in the tutorial :  http://doc.babylonjs.com/tutorials/How_to_use_Path3D
 /// path : an array of Vector3, the curve axis of the Path3D
 /// normal (optional) : Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.
 /// raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.
 external factory Path3D(List<Vector3> path, [Vector3/*Vector3|Null*/ firstNormal, bool raw]);
 /// Returns the Path3D array of successive Vector3 designing its curve.
 external List<Vector3> getCurve();
 /// Returns an array populated with tangent vectors on each Path3D curve point.
 external List<Vector3> getTangents();
 /// Returns an array populated with normal vectors on each Path3D curve point.
 external List<Vector3> getNormals();
 /// Returns an array populated with binormal vectors on each Path3D curve point.
 external List<Vector3> getBinormals();
 /// Returns an array populated with distances (float) of the i-th point from the first curve point.
 external List<num> getDistances();
 /// Forces the Path3D tangent, normal, binormal and distance recomputation.
 /// Returns the same object updated.
 external Path3D update(List<Vector3> path, [Vector3/*Vector3|Null*/ firstNormal]); external JS$_compute(firstNormal); external JS$_getFirstNonNullVector(index); external JS$_getLastNonNullVector(index); external JS$_normalVector(v0, vt, va); }

 @JS("BABYLON.Curve3" ) class Curve3 { // @Ignore
 Curve3 .fakeConstructor$() ;
 external get JS$_points; external set JS$_points(v); external get JS$_length; external set JS$_length(v);
 /// Returns a Curve3 object along a Quadratic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#quadratic-bezier-curve
 external static Curve3 CreateQuadraticBezier(Vector3 v0, Vector3 v1, Vector3 v2, num nbPoints);
 /// Returns a Curve3 object along a Cubic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#cubic-bezier-curve
 external static Curve3 CreateCubicBezier(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, num nbPoints);
 /// Returns a Curve3 object along a Hermite Spline curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#hermite-spline
 external static Curve3 CreateHermiteSpline(Vector3 p1, Vector3 t1, Vector3 p2, Vector3 t2, num nbPoints);
 /// Returns a Curve3 object along a CatmullRom Spline curve :
 external static Curve3 CreateCatmullRomSpline(List<Vector3> points, num nbPoints);
 /// A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
 /// A Curve3 is designed from a series of successive Vector3.
 /// Tuto : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#curve3-object
 external factory Curve3(List<Vector3> points);
 /// Returns the Curve3 stored array of successive Vector3
 external List<Vector3> getPoints();
 /// Returns the computed length (float) of the curve.
 external num length();
 /// Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);
 /// This new Curve3 is built by translating and sticking the curveB at the end of the curveA.
 /// curveA and curveB keep unchanged.
 external Curve3 JS$continue(Curve3 curve); external JS$_computeLength(path); }

 @JS("BABYLON.PositionNormalVertex" ) class PositionNormalVertex { // @Ignore
 PositionNormalVertex .fakeConstructor$() ;
 external Vector3 get position; external set position(Vector3 v); external Vector3 get normal; external set normal(Vector3 v); external factory PositionNormalVertex([Vector3 position, Vector3 normal]); external PositionNormalVertex clone(); }

 @JS("BABYLON.PositionNormalTextureVertex" ) class PositionNormalTextureVertex { // @Ignore
 PositionNormalTextureVertex .fakeConstructor$() ;
 external Vector3 get position; external set position(Vector3 v); external Vector3 get normal; external set normal(Vector3 v); external Vector2 get uv; external set uv(Vector2 v); external factory PositionNormalTextureVertex([Vector3 position, Vector3 normal, Vector2 uv]); external PositionNormalTextureVertex clone(); }

 @JS("BABYLON.Tmp" ) class Tmp { // @Ignore
 Tmp .fakeConstructor$() ;
 external static List<Color3> get Color3; external static set Color3(List<Color3> v); external static List<Vector2> get Vector2; external static set Vector2(List<Vector2> v); external static List<Vector3> get Vector3; external static set Vector3(List<Vector3> v); external static List<Vector4> get Vector4; external static set Vector4(List<Vector4> v); external static List<Quaternion> get Quaternion; external static set Quaternion(List<Quaternion> v); external static List<Matrix> get Matrix; external static set Matrix(List<Matrix> v); }

 @JS("BABYLON.SphericalPolynomial" ) class SphericalPolynomial { // @Ignore
 SphericalPolynomial .fakeConstructor$() ;
 external Vector3 get x; external set x(Vector3 v); external Vector3 get y; external set y(Vector3 v); external Vector3 get z; external set z(Vector3 v); external Vector3 get xx; external set xx(Vector3 v); external Vector3 get yy; external set yy(Vector3 v); external Vector3 get zz; external set zz(Vector3 v); external Vector3 get xy; external set xy(Vector3 v); external Vector3 get yz; external set yz(Vector3 v); external Vector3 get zx; external set zx(Vector3 v); external void addAmbient(Color3 color); external static SphericalPolynomial getSphericalPolynomialFromHarmonics(SphericalHarmonics harmonics); external void scale(num scale); }

 @JS("BABYLON.SphericalHarmonics" ) class SphericalHarmonics { // @Ignore
 SphericalHarmonics .fakeConstructor$() ;
 external Vector3 get L00; external set L00(Vector3 v); external Vector3 get L1_1; external set L1_1(Vector3 v); external Vector3 get L10; external set L10(Vector3 v); external Vector3 get L11; external set L11(Vector3 v); external Vector3 get L2_2; external set L2_2(Vector3 v); external Vector3 get L2_1; external set L2_1(Vector3 v); external Vector3 get L20; external set L20(Vector3 v); external Vector3 get L21; external set L21(Vector3 v); external Vector3 get L22; external set L22(Vector3 v); external void addLight(Vector3 direction, Color3 color, num deltaSolidAngle); external void scale(num scale); external void convertIncidentRadianceToIrradiance(); external void convertIrradianceToLambertianRadiance(); external static SphericalHarmonics getsphericalHarmonicsFromPolynomial(SphericalPolynomial polynomial); }

 /// Defines a target to use with MorphTargetManager
 /// @see http://doc.babylonjs.com/how_to/how_to_use_morphtargets
 @JS("BABYLON.MorphTarget" ) class MorphTarget implements IAnimatable { // @Ignore
 MorphTarget .fakeConstructor$() ;
 /// defines the name of the target
 external String get name; external set name(String v);
 /// Gets or sets the list of animations
 external List<Animation> get animations; external set animations(List<Animation> v); external get JS$_scene; external set JS$_scene(v); external get JS$_positions; external set JS$_positions(v); external get JS$_normals; external set JS$_normals(v); external get JS$_tangents; external set JS$_tangents(v); external get JS$_influence; external set JS$_influence(v);
 /// Observable raised when the influence changes
 external Observable<bool> get onInfluenceChanged; external set onInfluenceChanged(Observable<bool> v);
 /// Gets or sets the influence of this target (ie. its weight in the overall morphing)
 external num get influence; external set influence(num v); external get JS$_animationPropertiesOverride; external set JS$_animationPropertiesOverride(v);
 /// Gets or sets the animation properties override
 external AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ get animationPropertiesOverride; external set animationPropertiesOverride(AnimationPropertiesOverride/*AnimationPropertiesOverride|Null*/ v);
 /// Creates a new MorphTarget
 external factory MorphTarget(
 /// defines the name of the target
 String name, [num influence, Scene/*Scene|Null*/ scene]);
 /// Gets a boolean defining if the target contains position data
 external bool get hasPositions; external set hasPositions(bool v);
 /// Gets a boolean defining if the target contains normal data
 external bool get hasNormals; external set hasNormals(bool v);
 /// Gets a boolean defining if the target contains tangent data
 external bool get hasTangents; external set hasTangents(bool v);
 /// Affects position data to this target
 external void setPositions(dynamic/*List<num>|Float32List|Null*/ data);
 /// Gets the position data stored in this target
 external dynamic/*List<num>|Float32List|Null*/ getPositions();
 /// Affects normal data to this target
 external void setNormals(dynamic/*List<num>|Float32List|Null*/ data);
 /// Gets the normal data stored in this target
 external dynamic/*List<num>|Float32List|Null*/ getNormals();
 /// Affects tangent data to this target
 external void setTangents(dynamic/*List<num>|Float32List|Null*/ data);
 /// Gets the tangent data stored in this target
 external dynamic/*List<num>|Float32List|Null*/ getTangents();
 /// Serializes the current target into a Serialization object
 external dynamic serialize();
 /// Creates a new target from serialized data
 external static MorphTarget Parse(dynamic serializationObject);
 /// Creates a MorphTarget from mesh data
 external static MorphTarget FromMesh(AbstractMesh mesh, [String name, num influence]); }

 /// This class is used to deform meshes using morphing between different targets
 /// @see http://doc.babylonjs.com/how_to/how_to_use_morphtargets
 @JS("BABYLON.MorphTargetManager" ) class MorphTargetManager { // @Ignore
 MorphTargetManager .fakeConstructor$() ;
 external get JS$_targets; external set JS$_targets(v); external get JS$_targetObservable; external set JS$_targetObservable(v); external get JS$_activeTargets; external set JS$_activeTargets(v); external get JS$_scene; external set JS$_scene(v); external get JS$_influences; external set JS$_influences(v); external get JS$_supportsNormals; external set JS$_supportsNormals(v); external get JS$_supportsTangents; external set JS$_supportsTangents(v); external get JS$_vertexCount; external set JS$_vertexCount(v); external get JS$_uniqueId; external set JS$_uniqueId(v); external get JS$_tempInfluences; external set JS$_tempInfluences(v);
 /// Creates a new MorphTargetManager
 external factory MorphTargetManager([Scene/*Scene|Null*/ scene]);
 /// Gets the unique ID of this manager
 external num get uniqueId; external set uniqueId(num v);
 /// Gets the number of vertices handled by this manager
 external num get vertexCount; external set vertexCount(num v);
 /// Gets a boolean indicating if this manager supports morphing of normals
 external bool get supportsNormals; external set supportsNormals(bool v);
 /// Gets a boolean indicating if this manager supports morphing of tangents
 external bool get supportsTangents; external set supportsTangents(bool v);
 /// Gets the number of targets stored in this manager
 external num get numTargets; external set numTargets(num v);
 /// Gets the number of influencers (ie. the number of targets with influences > 0)
 external num get numInfluencers; external set numInfluencers(num v);
 /// Gets the list of influences (one per target)
 external Float32List get influences; external set influences(Float32List v);
 /// Gets the active target at specified index. An active target is a target with an influence > 0
 external MorphTarget getActiveTarget(num index);
 /// Gets the target at specified index
 external MorphTarget getTarget(num index);
 /// Add a new target to this manager
 external void addTarget(MorphTarget target);
 /// Removes a target from the manager
 external void removeTarget(MorphTarget target);
 /// Serializes the current manager into a Serialization object
 external dynamic serialize(); external JS$_syncActiveTargets(needUpdate);
 /// Syncrhonize the targets with all the meshes using this morph target manager
 external void synchronize();
 /// Creates a new MorphTargetManager from serialized data
 external static MorphTargetManager Parse(dynamic serializationObject, Scene scene); }

 /// Class used to store all common mesh properties
 @JS("BABYLON.AbstractMesh" ) class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData { // @Ignore
 AbstractMesh .fakeConstructor$() : super.fakeConstructor$() ;
 /// No occlusion
 external static num get OCCLUSION_TYPE_NONE; external static set OCCLUSION_TYPE_NONE(num v);
 /// Occlusion set to optimisitic
 external static num get OCCLUSION_TYPE_OPTIMISTIC; external static set OCCLUSION_TYPE_OPTIMISTIC(num v);
 /// Occlusion set to strict
 external static num get OCCLUSION_TYPE_STRICT; external static set OCCLUSION_TYPE_STRICT(num v);
 /// Use an accurante occlusion algorithm
 external static num get OCCLUSION_ALGORITHM_TYPE_ACCURATE; external static set OCCLUSION_ALGORITHM_TYPE_ACCURATE(num v);
 /// Use a conservative occlusion algorithm
 external static num get OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE; external static set OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE(num v);
 /// No billboard
 external static num get BILLBOARDMODE_NONE; external static set BILLBOARDMODE_NONE(num v);
 /// Billboard on X axis
 external static num get BILLBOARDMODE_X; external static set BILLBOARDMODE_X(num v);
 /// Billboard on Y axis
 external static num get BILLBOARDMODE_Y; external static set BILLBOARDMODE_Y(num v);
 /// Billboard on Z axis
 external static num get BILLBOARDMODE_Z; external static set BILLBOARDMODE_Z(num v);
 /// Billboard on all axes
 external static num get BILLBOARDMODE_ALL; external static set BILLBOARDMODE_ALL(num v); external get JS$_facetPositions; external set JS$_facetPositions(v); external get JS$_facetNormals; external set JS$_facetNormals(v); external get JS$_facetPartitioning; external set JS$_facetPartitioning(v); external get JS$_facetNb; external set JS$_facetNb(v); external get JS$_partitioningSubdivisions; external set JS$_partitioningSubdivisions(v); external get JS$_partitioningBBoxRatio; external set JS$_partitioningBBoxRatio(v); external get JS$_facetDataEnabled; external set JS$_facetDataEnabled(v); external get JS$_facetParameters; external set JS$_facetParameters(v); external get JS$_bbSize; external set JS$_bbSize(v); external get JS$_subDiv; external set JS$_subDiv(v); external get JS$_facetDepthSort; external set JS$_facetDepthSort(v); external get JS$_facetDepthSortEnabled; external set JS$_facetDepthSortEnabled(v); external get JS$_depthSortedIndices; external set JS$_depthSortedIndices(v); external get JS$_depthSortedFacets; external set JS$_depthSortedFacets(v); external get JS$_facetDepthSortFunction; external set JS$_facetDepthSortFunction(v); external get JS$_facetDepthSortFrom; external set JS$_facetDepthSortFrom(v); external get JS$_facetDepthSortOrigin; external set JS$_facetDepthSortOrigin(v); external get JS$_invertedMatrix; external set JS$_invertedMatrix(v);
 /// Gets the number of facets in the mesh
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet
 external num get facetNb; external set facetNb(num v);
 /// Gets or set the number (integer) of subdivisions per axis in the partioning space
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning
 external num get partitioningSubdivisions; external set partitioningSubdivisions(num v);
 /// The ratio (float) to apply to the bouding box size to set to the partioning space.
 /// Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#tweaking-the-partitioning
 external num get partitioningBBoxRatio; external set partitioningBBoxRatio(num v);
 /// Gets or sets a boolean indicating that the facets must be depth sorted on next call to `updateFacetData()`.
 /// Works only for updatable meshes.
 /// Doesn't work with multi-materials
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort
 external bool get mustDepthSortFacets; external set mustDepthSortFacets(bool v);
 /// The location (Vector3) where the facet depth sort must be computed from.
 /// By default, the active camera position.
 /// Used only when facet depth sort is enabled
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#facet-depth-sort
 external Vector3 get facetDepthSortFrom; external set facetDepthSortFrom(Vector3 v);
 /// gets a boolean indicating if facetData is enabled
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata#what-is-a-mesh-facet
 external bool get isFacetDataEnabled; external set isFacetDataEnabled(bool v);
 /// @hidden
 external bool JS$_updateNonUniformScalingState(bool value);
 /// An event triggered when this mesh collides with another one
 external Observable<AbstractMesh> get onCollideObservable; external set onCollideObservable(Observable<AbstractMesh> v); external get JS$_onCollideObserver; external set JS$_onCollideObserver(v);
 /// Set a function to call when this mesh collides with another one
 external VoidFunc0 get onCollide; external set onCollide(VoidFunc0 v);
 /// An event triggered when the collision's position changes
 external Observable<Vector3> get onCollisionPositionChangeObservable; external set onCollisionPositionChangeObservable(Observable<Vector3> v); external get JS$_onCollisionPositionChangeObserver; external set JS$_onCollisionPositionChangeObserver(v);
 /// Set a function to call when the collision's position changes
 external VoidFunc0 get onCollisionPositionChange; external set onCollisionPositionChange(VoidFunc0 v);
 /// An event triggered when material is changed
 external Observable<AbstractMesh> get onMaterialChangedObservable; external set onMaterialChangedObservable(Observable<AbstractMesh> v);
 /// Gets or sets the orientation for POV movement & rotation
 external bool get definedFacingForward; external set definedFacingForward(bool v);
 /// This property determines the type of occlusion query algorithm to run in WebGl, you can use:
 /// * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE which is mapped to GL_ANY_SAMPLES_PASSED.
 /// * AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE (Default Value) which is mapped to GL_ANY_SAMPLES_PASSED_CONSERVATIVE which is a false positive algorithm that is faster than GL_ANY_SAMPLES_PASSED but less accurate.
 /// @see http://doc.babylonjs.com/features/occlusionquery
 external num get occlusionQueryAlgorithmType; external set occlusionQueryAlgorithmType(num v);
 /// This property is responsible for starting the occlusion query within the Mesh or not, this property is also used to determine what should happen when the occlusionRetryCount is reached. It has supports 3 values:
 /// * OCCLUSION_TYPE_NONE (Default Value): this option means no occlusion query whith the Mesh.
 /// * OCCLUSION_TYPE_OPTIMISTIC: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken show the mesh.
 /// * OCCLUSION_TYPE_STRICT: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken restore the last state of the mesh occlusion if the mesh was visible then show the mesh if was hidden then hide don't show.
 /// @see http://doc.babylonjs.com/features/occlusionquery
 external num get occlusionType; external set occlusionType(num v);
 /// This number indicates the number of allowed retries before stop the occlusion query, this is useful if the occlusion query is taking long time before to the query result is retireved, the query result indicates if the object is visible within the scene or not and based on that Babylon.Js engine decideds to show or hide the object.
 /// The default value is -1 which means don't break the query and wait till the result
 /// @see http://doc.babylonjs.com/features/occlusionquery
 external num get occlusionRetryCount; external set occlusionRetryCount(num v); external get JS$_occlusionInternalRetryCounter; external set JS$_occlusionInternalRetryCounter(v); external bool get JS$_isOccluded; external set JS$_isOccluded(bool v);
 /// Gets or sets whether the mesh is occluded or not, it is used also to set the intial state of the mesh to be occluded or not
 /// @see http://doc.babylonjs.com/features/occlusionquery
 external bool get isOccluded; external set isOccluded(bool v); external get JS$_isOcclusionQueryInProgress; external set JS$_isOcclusionQueryInProgress(v);
 /// Flag to check the progress status of the query
 /// @see http://doc.babylonjs.com/features/occlusionquery
 external bool get isOcclusionQueryInProgress; external set isOcclusionQueryInProgress(bool v); external get JS$_occlusionQuery; external set JS$_occlusionQuery(v); external get JS$_visibility; external set JS$_visibility(v);
 /// Gets or sets mesh visibility between 0 and 1 (default is 1)
 /// Gets or sets mesh visibility between 0 and 1 (default is 1)
 external num get visibility; external set visibility(num v);
 /// Gets or sets the alpha index used to sort transparent meshes
 /// @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#alpha-index
 external num get alphaIndex; external set alphaIndex(num v);
 /// Gets or sets a boolean indicating if the mesh is visible (renderable). Default is true
 external bool get isVisible; external set isVisible(bool v);
 /// Gets or sets a boolean indicating if the mesh can be picked (by scene.pick for instance or through actions). Default is true
 external bool get isPickable; external set isPickable(bool v);
 /// Gets or sets a boolean indicating if the bounding box must be rendered as well (false by default)
 external bool get showBoundingBox; external set showBoundingBox(bool v);
 /// Gets or sets a boolean indicating that bounding boxes of subMeshes must be rendered as well (false by default)
 external bool get showSubMeshesBoundingBox; external set showSubMeshesBoundingBox(bool v);
 /// Gets or sets a boolean indicating if the mesh must be considered as a ray blocker for lens flares (false by default)
 /// @see http://doc.babylonjs.com/how_to/how_to_use_lens_flares
 external bool get isBlocker; external set isBlocker(bool v);
 /// Gets or sets a boolean indicating that pointer move events must be supported on this mesh (false by default)
 external bool get enablePointerMoveEvents; external set enablePointerMoveEvents(bool v);
 /// Specifies the rendering group id for this mesh (0 by default)
 /// @see http://doc.babylonjs.com/resources/transparency_and_how_meshes_are_rendered#rendering-groups
 external num get renderingGroupId; external set renderingGroupId(num v); external get JS$_material; external set JS$_material(v);
 /// Gets or sets current material
 external Material/*Material|Null*/ get material; external set material(Material/*Material|Null*/ v); external get JS$_receiveShadows; external set JS$_receiveShadows(v);
 /// Gets or sets a boolean indicating that this mesh can receive realtime shadows
 /// @see http://doc.babylonjs.com/babylon101/shadows
 external bool get receiveShadows; external set receiveShadows(bool v);
 /// Gets or sets a boolean indicating if the outline must be rendered as well
 /// @see https://www.babylonjs-playground.com/#10WJ5S#3
 external bool get renderOutline; external set renderOutline(bool v);
 /// Defines color to use when rendering outline
 external Color3 get outlineColor; external set outlineColor(Color3 v);
 /// Define width to use when rendering outline
 external num get outlineWidth; external set outlineWidth(num v);
 /// Gets or sets a boolean indicating if the overlay must be rendered as well
 /// @see https://www.babylonjs-playground.com/#10WJ5S#2
 external bool get renderOverlay; external set renderOverlay(bool v);
 /// Defines color to use when rendering overlay
 external Color3 get overlayColor; external set overlayColor(Color3 v);
 /// Defines alpha to use when rendering overlay
 external num get overlayAlpha; external set overlayAlpha(num v); external get JS$_hasVertexAlpha; external set JS$_hasVertexAlpha(v);
 /// Gets or sets a boolean indicating that this mesh contains vertex color data with alpha values
 external bool get hasVertexAlpha; external set hasVertexAlpha(bool v); external get JS$_useVertexColors; external set JS$_useVertexColors(v);
 /// Gets or sets a boolean indicating that this mesh needs to use vertex color data to render (if this kind of vertex data is available in the geometry)
 external bool get useVertexColors; external set useVertexColors(bool v); external get JS$_computeBonesUsingShaders; external set JS$_computeBonesUsingShaders(v);
 /// Gets or sets a boolean indicating that bone animations must be computed by the CPU (false by default)
 external bool get computeBonesUsingShaders; external set computeBonesUsingShaders(bool v); external get JS$_numBoneInfluencers; external set JS$_numBoneInfluencers(v);
 /// Gets or sets the number of allowed bone influences per vertex (4 by default)
 external num get numBoneInfluencers; external set numBoneInfluencers(num v); external get JS$_applyFog; external set JS$_applyFog(v);
 /// Gets or sets a boolean indicating that this mesh will allow fog to be rendered on it (true by default)
 external bool get applyFog; external set applyFog(bool v);
 /// Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes selection (true by default)
 external bool get useOctreeForRenderingSelection; external set useOctreeForRenderingSelection(bool v);
 /// Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes picking (true by default)
 external bool get useOctreeForPicking; external set useOctreeForPicking(bool v);
 /// Gets or sets a boolean indicating that internal octree (if available) can be used to boost submeshes collision (true by default)
 external bool get useOctreeForCollisions; external set useOctreeForCollisions(bool v); external get JS$_layerMask; external set JS$_layerMask(v);
 /// Gets or sets the current layer mask (default is 0x0FFFFFFF)
 /// @see http://doc.babylonjs.com/how_to/layermasks_and_multi-cam_textures
 external num get layerMask; external set layerMask(num v);
 /// True if the mesh must be rendered in any case (this will shortcut the frustum clipping phase)
 external bool get alwaysSelectAsActiveMesh; external set alwaysSelectAsActiveMesh(bool v);
 /// Gets or sets the current action manager
 /// @see http://doc.babylonjs.com/how_to/how_to_use_actions
 external ActionManager/*ActionManager|Null*/ get actionManager; external set actionManager(ActionManager/*ActionManager|Null*/ v);
 /// Gets or sets impostor used for physic simulation
 /// @see http://doc.babylonjs.com/features/physics_engine
 external PhysicsImpostor/*PhysicsImpostor|Null*/ get physicsImpostor; external set physicsImpostor(PhysicsImpostor/*PhysicsImpostor|Null*/ v); external get JS$_checkCollisions; external set JS$_checkCollisions(v); external get JS$_collisionMask; external set JS$_collisionMask(v); external get JS$_collisionGroup; external set JS$_collisionGroup(v);
 /// Gets or sets the ellipsoid used to impersonate this mesh when using collision engine (default is (0.5, 1, 0.5))
 /// @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
 external Vector3 get ellipsoid; external set ellipsoid(Vector3 v);
 /// Gets or sets the ellipsoid offset used to impersonate this mesh when using collision engine (default is (0, 0, 0))
 /// @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
 external Vector3 get ellipsoidOffset; external set ellipsoidOffset(Vector3 v); external get JS$_collider; external set JS$_collider(v); external get JS$_oldPositionForCollisions; external set JS$_oldPositionForCollisions(v); external get JS$_diffPositionForCollisions; external set JS$_diffPositionForCollisions(v);
 /// Gets or sets a collision mask used to mask collisions (default is -1).
 /// A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
 external num get collisionMask; external set collisionMask(num v);
 /// Gets or sets the current collision group mask (-1 by default).
 /// A collision between A and B will happen if A.collisionGroup & b.collisionMask !== 0
 external num get collisionGroup; external set collisionGroup(num v);
 /// Defines edge width used when edgesRenderer is enabled
 /// @see https://www.babylonjs-playground.com/#10OJSG#13
 external num get edgesWidth; external set edgesWidth(num v);
 /// Defines edge color used when edgesRenderer is enabled
 /// @see https://www.babylonjs-playground.com/#10OJSG#13
 external Color4 get edgesColor; external set edgesColor(Color4 v);
 /// @hidden
 external EdgesRenderer/*EdgesRenderer|Null*/ get JS$_edgesRenderer; external set JS$_edgesRenderer(EdgesRenderer/*EdgesRenderer|Null*/ v); external get JS$_collisionsTransformMatrix; external set JS$_collisionsTransformMatrix(v); external get JS$_collisionsScalingMatrix; external set JS$_collisionsScalingMatrix(v);
 /// @hidden
 external AbstractMesh/*AbstractMesh|Null*/ get JS$_masterMesh; external set JS$_masterMesh(AbstractMesh/*AbstractMesh|Null*/ v);
 /// @hidden
 external BoundingInfo/*BoundingInfo|Null*/ get JS$_boundingInfo; external set JS$_boundingInfo(BoundingInfo/*BoundingInfo|Null*/ v);
 /// @hidden
 external num get JS$_renderId; external set JS$_renderId(num v);
 /// Gets or sets the list of subMeshes
 /// @see http://doc.babylonjs.com/how_to/multi_materials
 external List<SubMesh> get subMeshes; external set subMeshes(List<SubMesh> v);
 /// @hidden
 external Octree<SubMesh> get JS$_submeshesOctree; external set JS$_submeshesOctree(Octree<SubMesh> v);
 /// @hidden
 external List<AbstractMesh> get JS$_intersectionsInProgress; external set JS$_intersectionsInProgress(List<AbstractMesh> v);
 /// @hidden
 external bool get JS$_unIndexed; external set JS$_unIndexed(bool v);
 /// @hidden
 external List<Light> get JS$_lightSources; external set JS$_lightSources(List<Light> v);
 /// @hidden
 external List<Vector3>/*List<Vector3>|Null*/ get JS$_positions; external set JS$_positions(List<Vector3>/*List<Vector3>|Null*/ v);
 /// @hidden
 external dynamic get JS$_waitingActions; external set JS$_waitingActions(dynamic v);
 /// @hidden
 external bool/*bool|Null*/ get JS$_waitingFreezeWorldMatrix; external set JS$_waitingFreezeWorldMatrix(bool/*bool|Null*/ v); external get JS$_skeleton; external set JS$_skeleton(v);
 /// @hidden
 external Float32List/*Float32List|Null*/ get JS$_bonesTransformMatrices; external set JS$_bonesTransformMatrices(Float32List/*Float32List|Null*/ v);
 /// Gets or sets a skeleton to apply skining transformations
 /// @see http://doc.babylonjs.com/how_to/how_to_use_bones_and_skeletons
 external Skeleton/*Skeleton|Null*/ get skeleton; external set skeleton(Skeleton/*Skeleton|Null*/ v);
 /// Creates a new AbstractMesh
 external factory AbstractMesh(String name, [Scene/*Scene|Null*/ scene]);
 /// Returns the string "AbstractMesh"
 external String getClassName();
 /// Gets a string representation of the current mesh
 external String toString([bool fullDetails]);
 /// @hidden
 external void JS$_rebuild();
 /// @hidden
 external void JS$_resyncLightSources();
 /// @hidden
 external void JS$_resyncLighSource(Light light);
 /// @hidden
 external void JS$_unBindEffect();
 /// @hidden
 external void JS$_removeLightSource(Light light); external JS$_markSubMeshesAsDirty(func);
 /// @hidden
 external void JS$_markSubMeshesAsLightDirty();
 /// @hidden
 external void JS$_markSubMeshesAsAttributesDirty();
 /// @hidden
 external void JS$_markSubMeshesAsMiscDirty();
 /// Gets or sets a Vector3 depicting the mesh scaling along each local axis X, Y, Z.  Default is (1.0, 1.0, 1.0)
 external Vector3 get scaling; external set scaling(Vector3 v);
 /// Disables the mesh edge rendering mode
 external AbstractMesh disableEdgesRendering();
 /// Enables the edge rendering mode on the mesh.
 /// This mode makes the mesh edges visible
 /// @see https://www.babylonjs-playground.com/#19O9TU#0
 external AbstractMesh enableEdgesRendering([num epsilon, bool checkVerticesInsteadOfIndices]);
 /// Returns true if the mesh is blocked. Implemented by child classes
 external bool get isBlocked; external set isBlocked(bool v);
 /// Returns the mesh itself by default. Implemented by child classes
 external AbstractMesh getLOD(Camera camera);
 /// Returns 0 by default. Implemented by child classes
 external num getTotalVertices();
 /// Returns null by default. Implemented by child classes
 external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices();
 /// Returns the array of the requested vertex data kind. Implemented by child classes
 external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind);
 /// Sets the vertex data of the mesh geometry for the requested `kind`.
 /// If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
 /// Note that a new underlying VertexBuffer object is created each call.
 /// If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
 /// * BABYLON.VertexBuffer.PositionKind
 /// * BABYLON.VertexBuffer.UVKind
 /// * BABYLON.VertexBuffer.UV2Kind
 /// * BABYLON.VertexBuffer.UV3Kind
 /// * BABYLON.VertexBuffer.UV4Kind
 /// * BABYLON.VertexBuffer.UV5Kind
 /// * BABYLON.VertexBuffer.UV6Kind
 /// * BABYLON.VertexBuffer.ColorKind
 /// * BABYLON.VertexBuffer.MatricesIndicesKind
 /// * BABYLON.VertexBuffer.MatricesIndicesExtraKind
 /// * BABYLON.VertexBuffer.MatricesWeightsKind
 /// * BABYLON.VertexBuffer.MatricesWeightsExtraKind
 external AbstractMesh setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updatable, num stride]);
 /// Updates the existing vertex data of the mesh geometry for the requested `kind`.
 /// If the mesh has no geometry, it is simply returned as it is.
 /// * BABYLON.VertexBuffer.PositionKind
 /// * BABYLON.VertexBuffer.UVKind
 /// * BABYLON.VertexBuffer.UV2Kind
 /// * BABYLON.VertexBuffer.UV3Kind
 /// * BABYLON.VertexBuffer.UV4Kind
 /// * BABYLON.VertexBuffer.UV5Kind
 /// * BABYLON.VertexBuffer.UV6Kind
 /// * BABYLON.VertexBuffer.ColorKind
 /// * BABYLON.VertexBuffer.MatricesIndicesKind
 /// * BABYLON.VertexBuffer.MatricesIndicesExtraKind
 /// * BABYLON.VertexBuffer.MatricesWeightsKind
 /// * BABYLON.VertexBuffer.MatricesWeightsExtraKind
 external AbstractMesh updateVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updateExtends, bool makeItUnique]);
 /// Sets the mesh indices,
 /// If the mesh has no geometry, a new Geometry object is created and set to the mesh.
 external AbstractMesh setIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, num/*num|Null*/ totalVertices);
 /// Gets a boolean indicating if specific vertex data is present
 external bool isVerticesDataPresent(String kind);
 /// Returns the mesh BoundingInfo object or creates a new one and returns if it was undefined
 external BoundingInfo getBoundingInfo();
 /// Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units)
 external AbstractMesh normalizeToUnitCube([bool includeDescendants]);
 /// Overwrite the current bounding info
 external AbstractMesh setBoundingInfo(BoundingInfo boundingInfo);
 /// Gets a boolean indicating if this mesh has skinning data and an attached skeleton
 external bool get useBones; external set useBones(bool v);
 /// @hidden
 external void JS$_preActivate();
 /// @hidden
 external void JS$_preActivateForIntermediateRendering(num renderId);
 /// @hidden
 external void JS$_activate(num renderId);
 /// Gets the current world matrix
 external Matrix getWorldMatrix();
 /// @hidden
 external num JS$_getWorldMatrixDeterminant();
 /// Perform relative position change from the point of view of behind the front of the mesh.
 /// This is performed taking into account the meshes current rotation, so you do not have to care.
 /// Supports definition of mesh facing forward or backward
 external AbstractMesh movePOV(num amountRight, num amountUp, num amountForward);
 /// Calculate relative position change from the point of view of behind the front of the mesh.
 /// This is performed taking into account the meshes current rotation, so you do not have to care.
 /// Supports definition of mesh facing forward or backward
 external Vector3 calcMovePOV(num amountRight, num amountUp, num amountForward);
 /// Perform relative rotation change from the point of view of behind the front of the mesh.
 /// Supports definition of mesh facing forward or backward
 external AbstractMesh rotatePOV(num flipBack, num twirlClockwise, num tiltRight);
 /// Calculate relative rotation change from the point of view of behind the front of the mesh.
 /// Supports definition of mesh facing forward or backward.
 external Vector3 calcRotatePOV(num flipBack, num twirlClockwise, num tiltRight);
 /// Return the minimum and maximum world vectors of the entire hierarchy under current mesh
 external dynamic/*{
            min: Vector3;
            max: Vector3;
        }*/ getHierarchyBoundingVectors([bool includeDescendants]);
 /// @hidden
 external AbstractMesh JS$_updateBoundingInfo();
 /// @hidden
 external AbstractMesh JS$_updateSubMeshesBoundingInfo(Matrix matrix);
 /// @hidden
 external void JS$_afterComputeWorldMatrix();
 /// Returns `true` if the mesh is within the frustum defined by the passed array of planes.
 /// A mesh is in the frustum if its bounding box intersects the frustum
 external bool isInFrustum(List<Plane> frustumPlanes);
 /// Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.
 /// A mesh is completely in the frustum if its bounding box it completely inside the frustum.
 external bool isCompletelyInFrustum(List<Plane> frustumPlanes);
 /// True if the mesh intersects another mesh or a SolidParticle object
 external bool intersectsMesh(dynamic/*AbstractMesh|SolidParticle*/ mesh, [bool precise, bool includeDescendants]);
 /// Returns true if the passed point (Vector3) is inside the mesh bounding box
 external bool intersectsPoint(Vector3 point);
 /// Gets the current physics impostor
 /// @see http://doc.babylonjs.com/features/physics_engine
 external PhysicsImpostor/*PhysicsImpostor|Null*/ getPhysicsImpostor();
 /// Gets the position of the current mesh in camera space
 external Vector3 getPositionInCameraSpace([Camera/*Camera|Null*/ camera]);
 /// Returns the distance from the mesh to the active camera
 external num getDistanceToCamera([Camera/*Camera|Null*/ camera]);
 /// Apply a physic impulse to the mesh
 /// @see http://doc.babylonjs.com/how_to/using_the_physics_engine
 external AbstractMesh applyImpulse(Vector3 force, Vector3 contactPoint);
 /// Creates a physic joint between two meshes
 /// @see https://www.babylonjs-playground.com/#0BS5U0#0
 external AbstractMesh setPhysicsLinkWith(Mesh otherMesh, Vector3 pivot1, Vector3 pivot2, [dynamic options]);
 /// Gets or sets a boolean indicating that this mesh can be used in the collision engine
 /// @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
 external bool get checkCollisions; external set checkCollisions(bool v);
 /// Gets Collider object used to compute collisions (not physics)
 /// @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
 external Collider get collider; external set collider(Collider v);
 /// Move the mesh using collision engine
 /// @see http://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity
 external AbstractMesh moveWithCollisions(Vector3 displacement); external get JS$_onCollisionPositionChange; external set JS$_onCollisionPositionChange(v);
 /// This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.
 /// Please note that you must have a decent number of submeshes to get performance improvements when using an octree
 /// @see https://www.babylonjs-playground.com/#NA4OQ#12
 /// @see http://doc.babylonjs.com/how_to/optimizing_your_scene_with_octrees
 external Octree<SubMesh> createOrUpdateSubmeshesOctree([num maxCapacity, num maxDepth]);
 /// @hidden
 external AbstractMesh JS$_collideForSubMesh(SubMesh subMesh, Matrix transformMatrix, Collider collider);
 /// @hidden
 external AbstractMesh JS$_processCollisionsForSubMeshes(Collider collider, Matrix transformMatrix);
 /// @hidden
 external AbstractMesh JS$_checkCollision(Collider collider);
 /// @hidden
 external bool JS$_generatePointsArray();
 /// Checks if the passed Ray intersects with the mesh
 /// @see http://doc.babylonjs.com/babylon101/intersect_collisions_-_mesh
 external PickingInfo intersects(Ray ray, [bool fastCheck]);
 /// Clones the current mesh
 external AbstractMesh/*AbstractMesh|Null*/ clone(String name, Node newParent, [bool doNotCloneChildren]);
 /// Disposes all the submeshes of the current meshnp
 external AbstractMesh releaseSubMeshes();
 /// Releases resources associated with this abstract mesh.
 external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);
 /// Adds the passed mesh as a child to the current mesh
 external AbstractMesh addChild(AbstractMesh mesh);
 /// Removes the passed mesh from the current mesh children list
 external AbstractMesh removeChild(AbstractMesh mesh);
 /// @hidden
 external JS$_initFacetData();
 /// Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.
 /// This method can be called within the render loop.
 /// You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external AbstractMesh updateFacetData();
 /// Returns the facetLocalNormals array.
 /// The normals are expressed in the mesh local spac
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external List<Vector3> getFacetLocalNormals();
 /// Returns the facetLocalPositions array.
 /// The facet positions are expressed in the mesh local space
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external List<Vector3> getFacetLocalPositions();
 /// Returns the facetLocalPartioning array
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external List<List<num>> getFacetLocalPartitioning();
 /// Returns the i-th facet position in the world system.
 /// This method allocates a new Vector3 per call
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external Vector3 getFacetPosition(num i);
 /// Sets the reference Vector3 with the i-th facet position in the world system
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external AbstractMesh getFacetPositionToRef(num i, Vector3 ref);
 /// Returns the i-th facet normal in the world system.
 /// This method allocates a new Vector3 per call
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external Vector3 getFacetNormal(num i);
 /// Sets the reference Vector3 with the i-th facet normal in the world system
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external AbstractMesh getFacetNormalToRef(num i, Vector3 ref);
 /// Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system)
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external List<num>/*List<num>|Null*/ getFacetsAtLocalCoordinates(num x, num y, num z);
 /// Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external num/*num|Null*/ getClosestFacetAtCoordinates(num x, num y, num z, [Vector3 projected, bool checkFace, bool facing]);
 /// Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external num/*num|Null*/ getClosestFacetAtLocalCoordinates(num x, num y, num z, [Vector3 projected, bool checkFace, bool facing]);
 /// Returns the object "parameter" set with all the expected parameters for facetData computation by ComputeNormals()
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external dynamic getFacetDataParameters();
 /// Disables the feature FacetData and frees the related memory
 /// @see http://doc.babylonjs.com/how_to/how_to_use_facetdata
 external AbstractMesh disableFacetData();
 /// Updates the AbstractMesh indices array
 external AbstractMesh updateIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices);
 /// Creates new normals data for the mesh
 external AbstractMesh createNormals(bool updatable);
 /// Align the mesh with a normal
 external AbstractMesh alignWithNormal(Vector3 normal, [Vector3 upDirection]);
 /// @hidden
 external void JS$_checkOcclusionQuery(); }

 @JS("BABYLON.Buffer" ) class Buffer { // @Ignore
 Buffer .fakeConstructor$() ;
 external get JS$_engine; external set JS$_engine(v); external get JS$_buffer; external set JS$_buffer(v); external get JS$_data; external set JS$_data(v); external get JS$_updatable; external set JS$_updatable(v); external get JS$_instanced; external set JS$_instanced(v);
 /// Gets the byte stride.
 external num get byteStride; external set byteStride(num v);
 /// Constructor
 external factory Buffer(dynamic engine, dynamic/*List<num>|ByteBuffer|TypedData*/ data, bool updatable, [num stride, bool postponeInternalCreation, bool instanced, bool useBytes]);
 /// Create a new {BABYLON.VertexBuffer} based on the current buffer
 external VertexBuffer createVertexBuffer(String kind, num offset, num size, [num stride, bool instanced, bool useBytes]); external bool isUpdatable(); external dynamic/*List<num>|ByteBuffer|TypedData|Null*/ getData(); external Buffer/*Buffer|Null*/ getBuffer();
 /// Gets the stride in float32 units (i.e. byte stride / 4).
 /// May not be an integer if the byte stride is not divisible by 4.
 /// DEPRECATED. Use byteStride instead.
 external num getStrideSize(); external void create([dynamic/*List<num>|ByteBuffer|TypedData|Null*/ data]); external void JS$_rebuild(); external void update(dynamic/*List<num>|ByteBuffer|TypedData*/ data);
 /// Updates the data directly.
 external void updateDirectly(dynamic/*List<num>|ByteBuffer|TypedData*/ data, num offset, [num vertexCount, bool useBytes]); external void dispose(); }

 @JS("BABYLON.CSG" ) class CSG { // @Ignore
 CSG .fakeConstructor$() ;
 external get polygons; external set polygons(v); external Matrix get matrix; external set matrix(Matrix v); external Vector3 get position; external set position(Vector3 v); external Vector3 get rotation; external set rotation(Vector3 v); external Quaternion/*Quaternion|Null*/ get rotationQuaternion; external set rotationQuaternion(Quaternion/*Quaternion|Null*/ v); external Vector3 get scaling; external set scaling(Vector3 v); external static CSG FromMesh(Mesh mesh); external static FromPolygons(polygons); external CSG clone(); external CSG union(CSG csg); external void unionInPlace(CSG csg); external CSG subtract(CSG csg); external void subtractInPlace(CSG csg); external CSG intersect(CSG csg); external void intersectInPlace(CSG csg); external CSG inverse(); external void inverseInPlace(); external CSG copyTransformAttributes(CSG csg); external Mesh buildMeshGeometry(String name, Scene scene, bool keepSubMeshes); external Mesh toMesh(String name, Material/*Material|Null*/ material, Scene scene, bool keepSubMeshes); }

 /// Class used to store geometry data (vertex buffers + index buffer)
 @JS("BABYLON.Geometry" ) class Geometry implements IGetSetVerticesData { // @Ignore
 Geometry .fakeConstructor$() ;
 /// Gets or sets the unique ID of the geometry
 external String get id; external set id(String v);
 /// Gets the delay loading state of the geometry (none by default which means not delayed)
 external num get delayLoadState; external set delayLoadState(num v);
 /// Gets the file containing the data to load when running in delay load state
 external String/*String|Null*/ get delayLoadingFile; external set delayLoadingFile(String/*String|Null*/ v);
 /// Callback called when the geometry is updated
 external VoidFunc2Opt1<Geometry, String> get onGeometryUpdated; external set onGeometryUpdated(VoidFunc2Opt1<Geometry, String> v); external get JS$_scene; external set JS$_scene(v); external get JS$_engine; external set JS$_engine(v); external get JS$_meshes; external set JS$_meshes(v); external get JS$_totalVertices; external set JS$_totalVertices(v); external get JS$_indices; external set JS$_indices(v); external get JS$_vertexBuffers; external set JS$_vertexBuffers(v); external get JS$_isDisposed; external set JS$_isDisposed(v); external get JS$_extend; external set JS$_extend(v); external get JS$_boundingBias; external set JS$_boundingBias(v);
 /// @hidden
 external List<String> get JS$_delayInfo; external set JS$_delayInfo(List<String> v); external get JS$_indexBuffer; external set JS$_indexBuffer(v); external get JS$_indexBufferIsUpdatable; external set JS$_indexBufferIsUpdatable(v);
 /// @hidden
 external BoundingInfo/*BoundingInfo|Null*/ get JS$_boundingInfo; external set JS$_boundingInfo(BoundingInfo/*BoundingInfo|Null*/ v);
 /// @hidden
 external VoidFunc2<dynamic, Geometry>/*VoidFunc2<dynamic, Geometry>|Null*/ get JS$_delayLoadingFunction; external set JS$_delayLoadingFunction(VoidFunc2<dynamic, Geometry>/*VoidFunc2<dynamic, Geometry>|Null*/ v);
 /// @hidden
 external num get JS$_softwareSkinningRenderId; external set JS$_softwareSkinningRenderId(num v); external get JS$_vertexArrayObjects; external set JS$_vertexArrayObjects(v); external get JS$_updatable; external set JS$_updatable(v);
 /// @hidden
 external List<Vector3>/*List<Vector3>|Null*/ get JS$_positions; external set JS$_positions(List<Vector3>/*List<Vector3>|Null*/ v);
 /// Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
 /// Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
 external Vector2 get boundingBias; external set boundingBias(Vector2 v);
 /// Static function used to attach a new empty geometry to a mesh
 external static Geometry CreateGeometryForMesh(Mesh mesh);
 /// Creates a new geometry
 external factory Geometry(String id, Scene scene, [VertexData vertexData, bool updatable, Mesh/*Mesh|Null*/ mesh]);
 /// Gets the current extend of the geometry
 external dynamic/*{
            minimum: Vector3;
            maximum: Vector3;
        }*/ get extend; external set extend(dynamic/*{
            minimum: Vector3;
            maximum: Vector3;
        }*/ v);
 /// Gets the hosting scene
 external Scene getScene();
 /// Gets the hosting engine
 external Engine getEngine();
 /// Defines if the geometry is ready to use
 external bool isReady();
 /// Gets a value indicating that the geometry should not be serialized
 external bool get doNotSerialize; external set doNotSerialize(bool v);
 /// @hidden
 external void JS$_rebuild();
 /// Affects all gemetry data in one call
 external void setAllVerticesData(VertexData vertexData, [bool updatable]);
 /// Set specific vertex data
 external void setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updatable, num stride]);
 /// Removes a specific vertex data
 external void removeVerticesData(String kind);
 /// Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data
 external void setVerticesBuffer(VertexBuffer buffer, [num/*num|Null*/ totalVertices]);
 /// Update a specific vertex buffer
 /// This function will directly update the underlying WebGLBuffer according to the passed numeric array or Float32Array
 /// It will do nothing if the buffer is not updatable
 external void updateVerticesDataDirectly(String kind, dynamic/*List<num>|ByteBuffer|TypedData*/ data, num offset, [bool useBytes]);
 /// Update a specific vertex buffer
 /// This function will create a new buffer if the current one is not updatable
 external void updateVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updateExtends]); external JS$_updateBoundingInfo(updateExtends, data);
 /// @hidden
 external void JS$_bind(Effect/*Effect|Null*/ effect, [Buffer/*Buffer|Null*/ indexToBind]);
 /// Gets total number of vertices
 external num getTotalVertices();
 /// Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.
 external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind, [bool copyWhenShared, bool forceCopy]);
 /// Returns a boolean defining if the vertex data for the requested `kind` is updatable
 external bool isVertexBufferUpdatable(String kind);
 /// Gets a specific vertex buffer
 external VertexBuffer/*VertexBuffer|Null*/ getVertexBuffer(String kind);
 /// Returns all vertex buffers
 external dynamic/*JSMap of <String,VertexBuffer>|Null*/ getVertexBuffers();
 /// Gets a boolean indicating if specific vertex buffer is present
 external bool isVerticesDataPresent(String kind);
 /// Gets a list of all attached data kinds (Position, normal, etc...)
 external List<String> getVerticesDataKinds();
 /// Update index buffer
 external void updateIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num offset]);
 /// Creates a new index buffer
 external void setIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num/*num|Null*/ totalVertices, bool updatable]);
 /// Return the total number of indices
 external num getTotalIndices();
 /// Gets the index buffer array
 external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices([bool copyWhenShared]);
 /// Gets the index buffer
 external Buffer/*Buffer|Null*/ getIndexBuffer();
 /// @hidden
 external void JS$_releaseVertexArrayObject([Effect/*Effect|Null*/ effect]);
 /// Release the associated resources for a specific mesh
 external void releaseForMesh(Mesh mesh, [bool shouldDispose]);
 /// Apply current geometry to a given mesh
 external void applyToMesh(Mesh mesh); external JS$_updateExtend([data]); external JS$_applyToMesh(mesh); external notifyUpdate([kind]);
 /// Load the geometry if it was flagged as delay loaded
 external void load(Scene scene, [void onLoaded()]); external JS$_queueLoad(scene, [onLoaded]);
 /// Invert the geometry to move from a right handed system to a left handed one.
 external void toLeftHanded();
 /// @hidden
 external void JS$_resetPointsArrayCache();
 /// @hidden
 external bool JS$_generatePointsArray();
 /// Gets a value indicating if the geometry is disposed
 external bool isDisposed(); external JS$_disposeVertexArrayObjects();
 /// Free all associated resources
 external void dispose();
 /// Clone the current geometry into a new geometry
 external Geometry copy(String id);
 /// Serialize the current geometry info (and not the vertices data) into a JSON object
 external dynamic serialize(); external toNumberArray(origin);
 /// Serialize all vertices data into a JSON oject
 external dynamic serializeVerticeData();
 /// Extracts a clone of a mesh geometry
 external static Geometry/*Geometry|Null*/ ExtractFromMesh(Mesh mesh, String id);
 /// You should now use Tools.RandomId(), this method is still here for legacy reasons.
 /// Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
 /// Be aware Math.random() could cause collisions, but:
 /// "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
 external static String RandomId();
 /// @hidden
 external static void JS$_ImportGeometry(dynamic parsedGeometry, Mesh mesh); external static JS$_CleanMatricesWeights(parsedGeometry, mesh);
 /// Create a new geometry from persisted data (Using .babylon file format)
 external static Geometry/*Geometry|Null*/ Parse(dynamic parsedVertexData, Scene scene, String rootUrl); }

 /// Abstract class used to provide common services for all typed geometries
 /// @hidden
 @JS("BABYLON._PrimitiveGeometry" ) class JS$_PrimitiveGeometry extends Geometry { // @Ignore
 JS$_PrimitiveGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_canBeRegenerated; external set JS$_canBeRegenerated(v); external get JS$_beingRegenerated; external set JS$_beingRegenerated(v);
 /// Creates a new typed geometry
 external factory JS$_PrimitiveGeometry(String id, Scene scene, [bool JS$_canBeRegenerated, Mesh/*Mesh|Null*/ mesh]);
 /// Gets a value indicating if the geometry supports being regenerated with new parameters (false by default)
 external bool canBeRegenerated();
 /// If the geometry supports regeneration, the function will recreates the geometry with updated parameter values
 external void regenerate();
 /// Clone the geometry
 external Geometry asNewGeometry(String id); external void setAllVerticesData(VertexData vertexData, [bool updatable]); external void setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updatable]);
 /// @hidden
 external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); external dynamic serialize(); }

 /// Creates a ribbon geometry
 /// See http://doc.babylonjs.com/how_to/ribbon_tutorial, http://doc.babylonjs.com/resources/maths_make_ribbons
 @JS("BABYLON.RibbonGeometry" ) class RibbonGeometry extends JS$_PrimitiveGeometry { // @Ignore
 RibbonGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the array of paths to use
 external List<List<Vector3>> get pathArray; external set pathArray(List<List<Vector3>> v);
 /// Defines if the last and first points of each path in your pathArray must be joined
 external bool get closeArray; external set closeArray(bool v);
 /// Defines if the last and first points of each path in your pathArray must be joined
 external bool get closePath; external set closePath(bool v);
 /// Defines the offset between points
 external num get offset; external set offset(num v);
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 external num get side; external set side(num v);
 /// Creates a ribbon geometry
 external factory RibbonGeometry(String id, Scene scene,
 /// Defines the array of paths to use
 List<List<Vector3>> pathArray,
 /// Defines if the last and first points of each path in your pathArray must be joined
 bool closeArray,
 /// Defines if the last and first points of each path in your pathArray must be joined
 bool closePath,
 /// Defines the offset between points
 num offset, [bool canBeRegenerated, Mesh mesh,
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 num side]);
 /// @hidden
 external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); }

 /// Creates a box geometry
 /// see http://doc.babylonjs.com/how_to/set_shapes#box
 @JS("BABYLON.BoxGeometry" ) class BoxGeometry extends JS$_PrimitiveGeometry { // @Ignore
 BoxGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the zise of the box (width, height and depth are the same)
 external num get size; external set size(num v);
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 external num get side; external set side(num v);
 /// Creates a box geometry
 external factory BoxGeometry(String id, Scene scene,
 /// Defines the zise of the box (width, height and depth are the same)
 num size, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh,
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 num side]); external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); external dynamic serialize(); external static BoxGeometry/*BoxGeometry|Null*/ Parse(dynamic parsedBox, Scene scene); }

 /// Creates a sphere geometry
 /// see http://doc.babylonjs.com/how_to/set_shapes#sphere
 @JS("BABYLON.SphereGeometry" ) class SphereGeometry extends JS$_PrimitiveGeometry { // @Ignore
 SphereGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the number of segments to use to create the sphere
 external num get segments; external set segments(num v);
 /// Defines the diameter of the sphere
 external num get diameter; external set diameter(num v);
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 external num get side; external set side(num v);
 /// Create a new sphere geometry
 external factory SphereGeometry(String id, Scene scene,
 /// Defines the number of segments to use to create the sphere
 num segments,
 /// Defines the diameter of the sphere
 num diameter, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh,
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 num side]); external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); external dynamic serialize(); external static SphereGeometry/*SphereGeometry|Null*/ Parse(dynamic parsedSphere, Scene scene); }

 /// Creates a disc geometry
 /// see http://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon
 @JS("BABYLON.DiscGeometry" ) class DiscGeometry extends JS$_PrimitiveGeometry { // @Ignore
 DiscGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the radius of the disc
 external num get radius; external set radius(num v);
 /// Defines the tesselation factor to apply to the disc
 external num get tessellation; external set tessellation(num v);
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 external num get side; external set side(num v);
 /// Creates a new disc geometry
 external factory DiscGeometry(String id, Scene scene,
 /// Defines the radius of the disc
 num radius,
 /// Defines the tesselation factor to apply to the disc
 num tessellation, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh,
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 num side]); external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); }

 /// Creates a new cylinder geometry
 /// see http://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone
 @JS("BABYLON.CylinderGeometry" ) class CylinderGeometry extends JS$_PrimitiveGeometry { // @Ignore
 CylinderGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the height of the cylinder
 external num get height; external set height(num v);
 /// Defines the diameter of the cylinder's top cap
 external num get diameterTop; external set diameterTop(num v);
 /// Defines the diameter of the cylinder's bottom cap
 external num get diameterBottom; external set diameterBottom(num v);
 /// Defines the tessellation factor to apply to the cylinder
 external num get tessellation; external set tessellation(num v);
 /// Defines the number of subdivisions to apply to the cylinder (1 by default)
 external num get subdivisions; external set subdivisions(num v);
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 external num get side; external set side(num v);
 /// Creates a new cylinder geometry
 external factory CylinderGeometry(String id, Scene scene,
 /// Defines the height of the cylinder
 num height,
 /// Defines the diameter of the cylinder's top cap
 num diameterTop,
 /// Defines the diameter of the cylinder's bottom cap
 num diameterBottom,
 /// Defines the tessellation factor to apply to the cylinder
 num tessellation, [
 /// Defines the number of subdivisions to apply to the cylinder (1 by default)
 num subdivisions, bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh,
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 num side]); external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); external dynamic serialize(); external static CylinderGeometry/*CylinderGeometry|Null*/ Parse(dynamic parsedCylinder, Scene scene); }

 /// Creates a new torus geometry
 /// see http://doc.babylonjs.com/how_to/set_shapes#torus
 @JS("BABYLON.TorusGeometry" ) class TorusGeometry extends JS$_PrimitiveGeometry { // @Ignore
 TorusGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the diameter of the torus
 external num get diameter; external set diameter(num v);
 /// Defines the thickness of the torus (ie. internal diameter)
 external num get thickness; external set thickness(num v);
 /// Defines the tesselation factor to apply to the torus
 external num get tessellation; external set tessellation(num v);
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 external num get side; external set side(num v);
 /// Creates a new torus geometry
 external factory TorusGeometry(String id, Scene scene,
 /// Defines the diameter of the torus
 num diameter,
 /// Defines the thickness of the torus (ie. internal diameter)
 num thickness,
 /// Defines the tesselation factor to apply to the torus
 num tessellation, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh,
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 num side]); external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); external dynamic serialize(); external static TorusGeometry/*TorusGeometry|Null*/ Parse(dynamic parsedTorus, Scene scene); }

 /// Creates a new ground geometry
 /// see http://doc.babylonjs.com/how_to/set_shapes#ground
 @JS("BABYLON.GroundGeometry" ) class GroundGeometry extends JS$_PrimitiveGeometry { // @Ignore
 GroundGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the width of the ground
 external num get width; external set width(num v);
 /// Defines the height of the ground
 external num get height; external set height(num v);
 /// Defines the subdivisions to apply to the ground
 external num get subdivisions; external set subdivisions(num v);
 /// Creates a new ground geometry
 external factory GroundGeometry(String id, Scene scene,
 /// Defines the width of the ground
 num width,
 /// Defines the height of the ground
 num height,
 /// Defines the subdivisions to apply to the ground
 num subdivisions, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh]); external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); external dynamic serialize(); external static GroundGeometry/*GroundGeometry|Null*/ Parse(dynamic parsedGround, Scene scene); }

 /// Creates a tiled ground geometry
 /// see http://doc.babylonjs.com/how_to/set_shapes#tiled-ground
 @JS("BABYLON.TiledGroundGeometry" ) class TiledGroundGeometry extends JS$_PrimitiveGeometry { // @Ignore
 TiledGroundGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the minimum value on X axis
 external num get xmin; external set xmin(num v);
 /// Defines the minimum value on Z axis
 external num get zmin; external set zmin(num v);
 /// Defines the maximum value on X axis
 external num get xmax; external set xmax(num v);
 /// Defines the maximum value on Z axis
 external num get zmax; external set zmax(num v);
 /// Defines the subdivisions to apply to the ground
 external dynamic/*{
            w: number;
            h: number;
        }*/ get subdivisions; external set subdivisions(dynamic/*{
            w: number;
            h: number;
        }*/ v);
 /// Defines the precision to use when computing the tiles
 external dynamic/*{
            w: number;
            h: number;
        }*/ get precision; external set precision(dynamic/*{
            w: number;
            h: number;
        }*/ v);
 /// Creates a tiled ground geometry
 external factory TiledGroundGeometry(String id, Scene scene,
 /// Defines the minimum value on X axis
 num xmin,
 /// Defines the minimum value on Z axis
 num zmin,
 /// Defines the maximum value on X axis
 num xmax,
 /// Defines the maximum value on Z axis
 num zmax,
 /// Defines the subdivisions to apply to the ground
 dynamic/*{
            w: number;
            h: number;
        }*/ subdivisions,
 /// Defines the precision to use when computing the tiles
 dynamic/*{
            w: number;
            h: number;
        }*/ precision, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh]); external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); }

 /// Creates a plane geometry
 /// see http://doc.babylonjs.com/how_to/set_shapes#plane
 @JS("BABYLON.PlaneGeometry" ) class PlaneGeometry extends JS$_PrimitiveGeometry { // @Ignore
 PlaneGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the size of the plane (width === height)
 external num get size; external set size(num v);
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 external num get side; external set side(num v);
 /// Creates a plane geometry
 external factory PlaneGeometry(String id, Scene scene,
 /// Defines the size of the plane (width === height)
 num size, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh,
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 num side]); external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); external dynamic serialize(); external static PlaneGeometry/*PlaneGeometry|Null*/ Parse(dynamic parsedPlane, Scene scene); }

 /// Creates a torus knot geometry
 /// see http://doc.babylonjs.com/how_to/set_shapes#torus-knot
 @JS("BABYLON.TorusKnotGeometry" ) class TorusKnotGeometry extends JS$_PrimitiveGeometry { // @Ignore
 TorusKnotGeometry .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the radius of the torus knot
 external num get radius; external set radius(num v);
 /// Defines the thickness of the torus knot tube
 external num get tube; external set tube(num v);
 /// Defines the number of radial segments
 external num get radialSegments; external set radialSegments(num v);
 /// Defines the number of tubular segments
 external num get tubularSegments; external set tubularSegments(num v);
 /// Defines the first number of windings
 external num get p; external set p(num v);
 /// Defines the second number of windings
 external num get q; external set q(num v);
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 external num get side; external set side(num v);
 /// Creates a torus knot geometry
 external factory TorusKnotGeometry(String id, Scene scene,
 /// Defines the radius of the torus knot
 num radius,
 /// Defines the thickness of the torus knot tube
 num tube,
 /// Defines the number of radial segments
 num radialSegments,
 /// Defines the number of tubular segments
 num tubularSegments,
 /// Defines the first number of windings
 num p,
 /// Defines the second number of windings
 num q, [bool canBeRegenerated, Mesh/*Mesh|Null*/ mesh,
 /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
 num side]); external VertexData JS$_regenerateVertexData(); external Geometry copy(String id); external dynamic serialize(); external static TorusKnotGeometry/*TorusKnotGeometry|Null*/ Parse(dynamic parsedTorusKnot, Scene scene); }

 @JS("BABYLON.GroundMesh" ) class GroundMesh extends Mesh { // @Ignore
 GroundMesh .fakeConstructor$() : super.fakeConstructor$() ;
 external bool get generateOctree; external set generateOctree(bool v); external get JS$_heightQuads; external set JS$_heightQuads(v); external num get JS$_subdivisionsX; external set JS$_subdivisionsX(num v); external num get JS$_subdivisionsY; external set JS$_subdivisionsY(num v); external num get JS$_width; external set JS$_width(num v); external num get JS$_height; external set JS$_height(num v); external num get JS$_minX; external set JS$_minX(num v); external num get JS$_maxX; external set JS$_maxX(num v); external num get JS$_minZ; external set JS$_minZ(num v); external num get JS$_maxZ; external set JS$_maxZ(num v); external factory GroundMesh(String name, Scene scene); external String getClassName(); external num get subdivisions; external set subdivisions(num v); external num get subdivisionsX; external set subdivisionsX(num v); external num get subdivisionsY; external set subdivisionsY(num v); external void optimize(num chunksCount, [num octreeBlocksSize]);
 /// Returns a height (y) value in the Worl system :
 /// the ground altitude at the coordinates (x, z) expressed in the World system.
 /// Returns the ground y position if (x, z) are outside the ground surface.
 external num getHeightAtCoordinates(num x, num z);
 /// Returns a normalized vector (Vector3) orthogonal to the ground
 /// at the ground coordinates (x, z) expressed in the World system.
 /// Returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
 external Vector3 getNormalAtCoordinates(num x, num z);
 /// Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
 /// at the ground coordinates (x, z) expressed in the World system.
 /// Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.
 /// Returns the GroundMesh.
 external GroundMesh getNormalAtCoordinatesToRef(num x, num z, Vector3 ref);
 /// Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
 /// if the ground has been updated.
 /// This can be used in the render loop.
 /// Returns the GroundMesh.
 external GroundMesh updateCoordinateHeights(); external JS$_getFacetAt(x, z); external JS$_initHeightQuads(); external JS$_computeHeightQuads(); external void serialize(dynamic serializationObject); external static GroundMesh Parse(dynamic parsedMesh, Scene scene); }

 /// Creates an instance based on a source mesh.
 @JS("BABYLON.InstancedMesh" ) class InstancedMesh extends AbstractMesh { // @Ignore
 InstancedMesh .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_sourceMesh; external set JS$_sourceMesh(v); external get JS$_currentLOD; external set JS$_currentLOD(v); external factory InstancedMesh(String name, Mesh source);
 /// Returns the string "InstancedMesh".
 external String getClassName(); external bool get receiveShadows; external set receiveShadows(bool v); external Material/*Material|Null*/ get material; external set material(Material/*Material|Null*/ v); external num get visibility; external set visibility(num v); external Skeleton/*Skeleton|Null*/ get skeleton; external set skeleton(Skeleton/*Skeleton|Null*/ v); external num get renderingGroupId; external set renderingGroupId(num v);
 /// Returns the total number of vertices (integer).
 external num getTotalVertices(); external Mesh get sourceMesh; external set sourceMesh(Mesh v);
 /// Is this node ready to be used/rendered
 external bool isReady([bool completeCheck]);
 /// Returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.
 external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind, [bool copyWhenShared]);
 /// Sets the vertex data of the mesh geometry for the requested `kind`.
 /// If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
 /// The `data` are either a numeric array either a Float32Array.
 /// The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.
 /// The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
 /// Note that a new underlying VertexBuffer object is created each call.
 /// If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
 /// Possible `kind` values :
 /// - BABYLON.VertexBuffer.PositionKind
 /// - BABYLON.VertexBuffer.UVKind
 /// - BABYLON.VertexBuffer.UV2Kind
 /// - BABYLON.VertexBuffer.UV3Kind
 /// - BABYLON.VertexBuffer.UV4Kind
 /// - BABYLON.VertexBuffer.UV5Kind
 /// - BABYLON.VertexBuffer.UV6Kind
 /// - BABYLON.VertexBuffer.ColorKind
 /// - BABYLON.VertexBuffer.MatricesIndicesKind
 /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
 /// - BABYLON.VertexBuffer.MatricesWeightsKind
 /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
 /// Returns the Mesh.
 external Mesh setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updatable, num stride]);
 /// Updates the existing vertex data of the mesh geometry for the requested `kind`.
 /// If the mesh has no geometry, it is simply returned as it is.
 /// The `data` are either a numeric array either a Float32Array.
 /// No new underlying VertexBuffer object is created.
 /// If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
 /// If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
 /// Possible `kind` values :
 /// - BABYLON.VertexBuffer.PositionKind
 /// - BABYLON.VertexBuffer.UVKind
 /// - BABYLON.VertexBuffer.UV2Kind
 /// - BABYLON.VertexBuffer.UV3Kind
 /// - BABYLON.VertexBuffer.UV4Kind
 /// - BABYLON.VertexBuffer.UV5Kind
 /// - BABYLON.VertexBuffer.UV6Kind
 /// - BABYLON.VertexBuffer.ColorKind
 /// - BABYLON.VertexBuffer.MatricesIndicesKind
 /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
 /// - BABYLON.VertexBuffer.MatricesWeightsKind
 /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
 /// Returns the Mesh.
 external Mesh updateVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updateExtends, bool makeItUnique]);
 /// Sets the mesh indices.
 /// Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
 /// If the mesh has no geometry, a new Geometry object is created and set to the mesh.
 /// This method creates a new index buffer each call.
 /// Returns the Mesh.
 external Mesh setIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num/*num|Null*/ totalVertices]);
 /// Boolean : True if the mesh owns the requested kind of data.
 external bool isVerticesDataPresent(String kind);
 /// Returns an array of indices (IndicesArray).
 external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices(); external List<Vector3>/*List<Vector3>|Null*/ get JS$_positions; external set JS$_positions(List<Vector3>/*List<Vector3>|Null*/ v);
 /// Sets a new updated BoundingInfo to the mesh.
 /// Returns the mesh.
 external InstancedMesh refreshBoundingInfo(); external InstancedMesh JS$_preActivate(); external InstancedMesh JS$_activate(num renderId);
 /// Returns the current associated LOD AbstractMesh.
 external AbstractMesh getLOD(Camera camera); external InstancedMesh JS$_syncSubMeshes(); external bool JS$_generatePointsArray();
 /// Creates a new InstancedMesh from the current mesh.
 /// - name (string) : the cloned mesh name
 /// - newParent (optional Node) : the optional Node to parent the clone to.
 /// - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.
 /// Returns the clone.
 external InstancedMesh clone(String name, Node newParent, [bool doNotCloneChildren]);
 /// Disposes the InstancedMesh.
 /// Returns nothing.
 external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]); }

 @JS("BABYLON.LinesMesh" ) class LinesMesh extends Mesh { // @Ignore
 LinesMesh .fakeConstructor$() : super.fakeConstructor$() ;
 external dynamic/*bool|dynamic*/ get useVertexColor; external set useVertexColor(dynamic/*bool|dynamic*/ v); external dynamic/*bool|dynamic*/ get useVertexAlpha; external set useVertexAlpha(dynamic/*bool|dynamic*/ v); external Color3 get color; external set color(Color3 v); external num get alpha; external set alpha(num v);
 /// The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
 /// This margin is expressed in world space coordinates, so its value may vary.
 /// Default value is 0.1
 /// The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
 /// This margin is expressed in world space coordinates, so its value may vary.
 external num get intersectionThreshold; external set intersectionThreshold(num v); external get JS$_intersectionThreshold; external set JS$_intersectionThreshold(v); external get JS$_colorShader; external set JS$_colorShader(v); external factory LinesMesh(String name, [Scene/*Scene|Null*/ scene, Node/*Node|Null*/ parent, LinesMesh source, bool doNotCloneChildren, dynamic/*bool|dynamic*/ useVertexColor, dynamic/*bool|dynamic*/ useVertexAlpha]);
 /// Returns the string "LineMesh"
 external String getClassName(); external Material get material; external set material(Material v); external bool get checkCollisions; external set checkCollisions(bool v); external InstancedMesh createInstance(String name); external LinesMesh JS$_bind(SubMesh subMesh, Effect effect, num fillMode); external LinesMesh JS$_draw(SubMesh subMesh, num fillMode, [num instancesCount]); external void dispose([bool doNotRecurse]);
 /// Returns a new LineMesh object cloned from the current one.
 external LinesMesh clone(String name, [Node newParent, bool doNotCloneChildren]); }

 /// @hidden
 @JS("BABYLON._InstancesBatch" ) class JS$_InstancesBatch { // @Ignore
 JS$_InstancesBatch .fakeConstructor$() ;
 external bool get mustReturn; external set mustReturn(bool v); external List<List<InstancedMesh>/*List<InstancedMesh>|Null*/> get visibleInstances; external set visibleInstances(List<List<InstancedMesh>/*List<InstancedMesh>|Null*/> v); external List<bool> get renderSelf; external set renderSelf(List<bool> v); }

 @JS("BABYLON.Mesh" ) class Mesh extends AbstractMesh implements IGetSetVerticesData { // @Ignore
 Mesh .fakeConstructor$() : super.fakeConstructor$() ;
 external static num get JS$_FRONTSIDE; external static set JS$_FRONTSIDE(num v); external static num get JS$_BACKSIDE; external static set JS$_BACKSIDE(num v); external static num get JS$_DOUBLESIDE; external static set JS$_DOUBLESIDE(num v); external static num get JS$_DEFAULTSIDE; external static set JS$_DEFAULTSIDE(num v); external static num get JS$_NO_CAP; external static set JS$_NO_CAP(num v); external static num get JS$_CAP_START; external static set JS$_CAP_START(num v); external static num get JS$_CAP_END; external static set JS$_CAP_END(num v); external static num get JS$_CAP_ALL; external static set JS$_CAP_ALL(num v);
 /// Mesh side orientation : usually the external or front surface
 external static num get FRONTSIDE; external static set FRONTSIDE(num v);
 /// Mesh side orientation : usually the internal or back surface
 external static num get BACKSIDE; external static set BACKSIDE(num v);
 /// Mesh side orientation : both internal and external or front and back surfaces
 external static num get DOUBLESIDE; external static set DOUBLESIDE(num v);
 /// Mesh side orientation : by default, `FRONTSIDE`
 external static num get DEFAULTSIDE; external static set DEFAULTSIDE(num v);
 /// Mesh cap setting : no cap
 external static num get NO_CAP; external static set NO_CAP(num v);
 /// Mesh cap setting : one cap at the beginning of the mesh
 external static num get CAP_START; external static set CAP_START(num v);
 /// Mesh cap setting : one cap at the end of the mesh
 external static num get CAP_END; external static set CAP_END(num v);
 /// Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh
 external static num get CAP_ALL; external static set CAP_ALL(num v);
 /// An event triggered before rendering the mesh
 external Observable<Mesh> get onBeforeRenderObservable; external set onBeforeRenderObservable(Observable<Mesh> v);
 /// An event triggered after rendering the mesh
 external Observable<Mesh> get onAfterRenderObservable; external set onAfterRenderObservable(Observable<Mesh> v);
 /// An event triggered before drawing the mesh
 external Observable<Mesh> get onBeforeDrawObservable; external set onBeforeDrawObservable(Observable<Mesh> v); external get JS$_onBeforeDrawObserver; external set JS$_onBeforeDrawObserver(v); external VoidFunc0 get onBeforeDraw; external set onBeforeDraw(VoidFunc0 v); external num get delayLoadState; external set delayLoadState(num v); external List<InstancedMesh> get instances; external set instances(List<InstancedMesh> v); external String get delayLoadingFile; external set delayLoadingFile(String v); external dynamic get JS$_binaryInfo; external set JS$_binaryInfo(dynamic v); external get JS$_LODLevels; external set JS$_LODLevels(v); external VoidFunc3<num, Mesh, Mesh> get onLODLevelSelection; external set onLODLevelSelection(VoidFunc3<num, Mesh, Mesh> v); external get JS$_morphTargetManager; external set JS$_morphTargetManager(v); external MorphTargetManager/*MorphTargetManager|Null*/ get morphTargetManager; external set morphTargetManager(MorphTargetManager/*MorphTargetManager|Null*/ v); external Geometry/*Geometry|Null*/ get JS$_geometry; external set JS$_geometry(Geometry/*Geometry|Null*/ v); external List<String> get JS$_delayInfo; external set JS$_delayInfo(List<String> v); external VoidFunc2<dynamic, Mesh> get JS$_delayLoadingFunction; external set JS$_delayLoadingFunction(VoidFunc2<dynamic, Mesh> v); external dynamic get JS$_visibleInstances; external set JS$_visibleInstances(dynamic v); external get JS$_renderIdForInstances; external set JS$_renderIdForInstances(v); external get JS$_batchCache; external set JS$_batchCache(v); external get JS$_instancesBufferSize; external set JS$_instancesBufferSize(v); external get JS$_instancesBuffer; external set JS$_instancesBuffer(v); external get JS$_instancesData; external set JS$_instancesData(v); external get JS$_overridenInstanceCount; external set JS$_overridenInstanceCount(v); external get JS$_effectiveMaterial; external set JS$_effectiveMaterial(v); external bool get JS$_shouldGenerateFlatShading; external set JS$_shouldGenerateFlatShading(bool v); external get JS$_preActivateId; external set JS$_preActivateId(v); external num get JS$_originalBuilderSideOrientation; external set JS$_originalBuilderSideOrientation(num v); external num/*num|Null*/ get overrideMaterialSideOrientation; external set overrideMaterialSideOrientation(num/*num|Null*/ v); external get JS$_areNormalsFrozen; external set JS$_areNormalsFrozen(v); external get JS$_sourcePositions; external set JS$_sourcePositions(v); external get JS$_sourceNormals; external set JS$_sourceNormals(v); external get JS$_source; external set JS$_source(v); external Mesh/*Mesh|Null*/ get source; external set source(Mesh/*Mesh|Null*/ v); external bool get isUnIndexed; external set isUnIndexed(bool v);
 /// @constructor
 /// When false, achieved by calling a clone(), also passing False.
 /// This will make creation of children, recursive.
 external factory Mesh(String name, [Scene/*Scene|Null*/ scene, Node/*Node|Null*/ parent, Mesh/*Mesh|Null*/ source, bool doNotCloneChildren, bool clonePhysicsImpostor]);
 /// Returns the string "Mesh".
 external String getClassName();
 /// Returns a string.
 external String toString([bool fullDetails]); external void JS$_unBindEffect();
 /// True if the mesh has some Levels Of Details (LOD).
 /// Returns a boolean.
 external bool get hasLODLevels; external set hasLODLevels(bool v);
 /// Gets the list of {BABYLON.MeshLODLevel} associated with the current mesh
 external List<MeshLODLevel> getLODLevels(); external JS$_sortLODLevels();
 /// Add a mesh as LOD level triggered at the given distance.
 /// tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD
 external Mesh addLODLevel(num distance, Mesh mesh);
 /// Returns the LOD level mesh at the passed distance or null if not found.
 /// It is related to the method `addLODLevel(distance, mesh)`.
 /// tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD
 /// Returns an object Mesh or `null`.
 external Mesh/*Mesh|Null*/ getLODLevelAtDistance(num distance);
 /// Remove a mesh from the LOD array
 /// tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD
 external Mesh removeLODLevel(Mesh mesh);
 /// Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.
 /// tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD
 external AbstractMesh getLOD(Camera camera, [BoundingSphere boundingSphere]);
 /// Returns the mesh internal Geometry object.
 external Geometry/*Geometry|Null*/ get geometry; external set geometry(Geometry/*Geometry|Null*/ v);
 /// Returns a positive integer : the total number of vertices within the mesh geometry or zero if the mesh has no geometry.
 external num getTotalVertices();
 /// Returns an array of integers or floats, or a Float32Array, depending on the requested `kind` (positions, indices, normals, etc).
 /// If `copywhenShared` is true (default false) and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
 /// You can force the copy with forceCopy === true
 /// Returns null if the mesh has no geometry or no vertex buffer.
 /// Possible `kind` values :
 /// - BABYLON.VertexBuffer.PositionKind
 /// - BABYLON.VertexBuffer.UVKind
 /// - BABYLON.VertexBuffer.UV2Kind
 /// - BABYLON.VertexBuffer.UV3Kind
 /// - BABYLON.VertexBuffer.UV4Kind
 /// - BABYLON.VertexBuffer.UV5Kind
 /// - BABYLON.VertexBuffer.UV6Kind
 /// - BABYLON.VertexBuffer.ColorKind
 /// - BABYLON.VertexBuffer.MatricesIndicesKind
 /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
 /// - BABYLON.VertexBuffer.MatricesWeightsKind
 /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
 external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind, [bool copyWhenShared, bool forceCopy]);
 /// Returns the mesh VertexBuffer object from the requested `kind` : positions, indices, normals, etc.
 /// Returns `null` if the mesh has no geometry.
 /// Possible `kind` values :
 /// - BABYLON.VertexBuffer.PositionKind
 /// - BABYLON.VertexBuffer.UVKind
 /// - BABYLON.VertexBuffer.UV2Kind
 /// - BABYLON.VertexBuffer.UV3Kind
 /// - BABYLON.VertexBuffer.UV4Kind
 /// - BABYLON.VertexBuffer.UV5Kind
 /// - BABYLON.VertexBuffer.UV6Kind
 /// - BABYLON.VertexBuffer.ColorKind
 /// - BABYLON.VertexBuffer.MatricesIndicesKind
 /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
 /// - BABYLON.VertexBuffer.MatricesWeightsKind
 /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
 external VertexBuffer/*VertexBuffer|Null*/ getVertexBuffer(String kind); external bool isVerticesDataPresent(String kind);
 /// Returns a boolean defining if the vertex data for the requested `kind` is updatable.
 /// Possible `kind` values :
 /// - BABYLON.VertexBuffer.PositionKind
 /// - BABYLON.VertexBuffer.UVKind
 /// - BABYLON.VertexBuffer.UV2Kind
 /// - BABYLON.VertexBuffer.UV3Kind
 /// - BABYLON.VertexBuffer.UV4Kind
 /// - BABYLON.VertexBuffer.UV5Kind
 /// - BABYLON.VertexBuffer.UV6Kind
 /// - BABYLON.VertexBuffer.ColorKind
 /// - BABYLON.VertexBuffer.MatricesIndicesKind
 /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
 /// - BABYLON.VertexBuffer.MatricesWeightsKind
 /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
 external bool isVertexBufferUpdatable(String kind);
 /// Returns a string : the list of existing `kinds` of Vertex Data for this mesh.
 /// Possible `kind` values :
 /// - BABYLON.VertexBuffer.PositionKind
 /// - BABYLON.VertexBuffer.UVKind
 /// - BABYLON.VertexBuffer.UV2Kind
 /// - BABYLON.VertexBuffer.UV3Kind
 /// - BABYLON.VertexBuffer.UV4Kind
 /// - BABYLON.VertexBuffer.UV5Kind
 /// - BABYLON.VertexBuffer.UV6Kind
 /// - BABYLON.VertexBuffer.ColorKind
 /// - BABYLON.VertexBuffer.MatricesIndicesKind
 /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
 /// - BABYLON.VertexBuffer.MatricesWeightsKind
 /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
 external List<String> getVerticesDataKinds();
 /// Returns a positive integer : the total number of indices in this mesh geometry.
 /// Returns zero if the mesh has no geometry.
 external num getTotalIndices();
 /// Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
 /// If the parameter `copyWhenShared` is true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
 /// Returns an empty array if the mesh has no geometry.
 external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices([bool copyWhenShared]); external bool get isBlocked; external set isBlocked(bool v);
 /// Determine if the current mesh is ready to be rendered
 external bool isReady([bool completeCheck, bool forceInstanceSupport]);
 /// Boolean : true if the normals aren't to be recomputed on next mesh `positions` array update.
 /// This property is pertinent only for updatable parametric shapes.
 external bool get areNormalsFrozen; external set areNormalsFrozen(bool v);
 /// This function affects parametric shapes on vertex position update only : ribbons, tubes, etc.
 /// It has no effect at all on other shapes.
 /// It prevents the mesh normals from being recomputed on next `positions` array update.
 /// Returns the Mesh.
 external Mesh freezeNormals();
 /// This function affects parametric shapes on vertex position update only : ribbons, tubes, etc.
 /// It has no effect at all on other shapes.
 /// It reactivates the mesh normals computation if it was previously frozen.
 /// Returns the Mesh.
 external Mesh unfreezeNormals();
 /// Overrides instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs
 external num get overridenInstanceCount; external set overridenInstanceCount(num v); external Mesh JS$_preActivate(); external Mesh JS$_preActivateForIntermediateRendering(num renderId); external Mesh JS$_registerInstanceForRenderId(InstancedMesh instance, num renderId);
 /// This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
 /// This means the mesh underlying bounding box and sphere are recomputed.
 /// Returns the Mesh.
 external Mesh refreshBoundingInfo(); external Mesh JS$_refreshBoundingInfo(bool applySkeleton); external JS$_getPositionData(applySkeleton); external SubMesh/*SubMesh|Null*/ JS$_createGlobalSubMesh(bool force); external void subdivide(num count); external Mesh setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updatable, num stride]); external void markVerticesDataAsUpdatable(String kind, [bool updatable]);
 /// Sets the mesh VertexBuffer.
 /// Returns the Mesh.
 external Mesh setVerticesBuffer(VertexBuffer buffer); external Mesh updateVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updateExtends, bool makeItUnique]);
 /// This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.
 /// tuto : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#other-shapes-updatemeshpositions
 /// The parameter `positionFunction` is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything.
 /// The parameter `computeNormals` is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update.
 /// Returns the Mesh.
 external Mesh updateMeshPositions(void positionFunction(dynamic/*List<num>|Float32List*/ data), [bool computeNormals]);
 /// Creates a un-shared specific occurence of the geometry for the mesh.
 /// Returns the Mesh.
 external Mesh makeGeometryUnique(); external Mesh setIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num/*num|Null*/ totalVertices, bool updatable]);
 /// Update the current index buffer
 /// Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)
 /// Returns the Mesh.
 external Mesh updateIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [num offset]);
 /// Invert the geometry to move from a right handed system to a left handed one.
 /// Returns the Mesh.
 external Mesh toLeftHanded(); external Mesh JS$_bind(SubMesh subMesh, Effect effect, num fillMode); external Mesh JS$_draw(SubMesh subMesh, num fillMode, [num instancesCount, bool alternate]);
 /// Registers for this mesh a javascript function called just before the rendering process.
 /// This function is passed the current mesh.
 /// Return the Mesh.
 external Mesh registerBeforeRender(void func(AbstractMesh mesh));
 /// Disposes a previously registered javascript function called before the rendering.
 /// This function is passed the current mesh.
 /// Returns the Mesh.
 external Mesh unregisterBeforeRender(void func(AbstractMesh mesh));
 /// Registers for this mesh a javascript function called just after the rendering is complete.
 /// This function is passed the current mesh.
 /// Returns the Mesh.
 external Mesh registerAfterRender(void func(AbstractMesh mesh));
 /// Disposes a previously registered javascript function called after the rendering.
 /// This function is passed the current mesh.
 /// Return the Mesh.
 external Mesh unregisterAfterRender(void func(AbstractMesh mesh)); external JS$_InstancesBatch JS$_getInstancesRenderList(num subMeshId); external Mesh JS$_renderWithInstances(SubMesh subMesh, num fillMode, JS$_InstancesBatch batch, Effect effect, Engine engine); external Mesh JS$_processRendering(SubMesh subMesh, Effect effect, num fillMode, JS$_InstancesBatch batch, bool hardwareInstancedRendering, void onBeforeDraw(bool isInstance, Matrix world, [Material effectiveMaterial]), [Material effectiveMaterial]);
 /// Triggers the draw call for the mesh.
 /// Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager.
 /// Returns the Mesh.
 external Mesh render(SubMesh subMesh, bool enableAlphaMode); external JS$_onBeforeDraw(isInstance, world, [effectiveMaterial]);
 /// Returns an array populated with ParticleSystem objects whose the mesh is the emitter.
 external List<IParticleSystem> getEmittedParticleSystems();
 /// Returns an array populated with ParticleSystem objects whose the mesh or its children are the emitter.
 external List<IParticleSystem> getHierarchyEmittedParticleSystems();
 /// Normalize matrix weights so that all vertices have a total weight set to 1
 external void cleanMatrixWeights(); external Mesh JS$_checkDelayState(); external JS$_queueLoad(scene);
 /// Boolean, true is the mesh in the frustum defined by the Plane objects from the `frustumPlanes` array parameter.
 external bool isInFrustum(List<Plane> frustumPlanes);
 /// Sets the mesh material by the material or multiMaterial `id` property.
 /// The material `id` is a string identifying the material or the multiMaterial.
 /// This method returns the Mesh.
 external Mesh setMaterialByID(String id);
 /// Returns as a new array populated with the mesh material and/or skeleton, if any.
 external List<IAnimatable> getAnimatables();
 /// Modifies the mesh geometry according to the passed transformation matrix.
 /// This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.
 /// The mesh normals are modified accordingly the same transformation.
 /// tuto : http://doc.babylonjs.com/resources/baking_transformations
 /// Note that, under the hood, this method sets a new VertexBuffer each call.
 /// Returns the Mesh.
 external Mesh bakeTransformIntoVertices(Matrix transform);
 /// Modifies the mesh geometry according to its own current World Matrix.
 /// The mesh World Matrix is then reset.
 /// This method returns nothing but really modifies the mesh even if it's originally not set as updatable.
 /// tuto : tuto : http://doc.babylonjs.com/resources/baking_transformations
 /// Note that, under the hood, this method sets a new VertexBuffer each call.
 /// Returns the Mesh.
 external Mesh bakeCurrentTransformIntoVertices(); external List<Vector3>/*List<Vector3>|Null*/ get JS$_positions; external set JS$_positions(List<Vector3>/*List<Vector3>|Null*/ v); external Mesh JS$_resetPointsArrayCache(); external bool JS$_generatePointsArray();
 /// Returns a new Mesh object generated from the current mesh properties.
 /// This method must not get confused with createInstance().
 /// The parameter `name` is a string, the name given to the new mesh.
 /// The optional parameter `newParent` can be any Node object (default `null`).
 /// The optional parameter `doNotCloneChildren` (default `false`) allows/denies the recursive cloning of the original mesh children if any.
 /// The parameter `clonePhysicsImpostor` (default `true`)  allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any.
 external Mesh clone(String name, [Node newParent, bool doNotCloneChildren, bool clonePhysicsImpostor]);
 /// Releases resources associated with this mesh.
 external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);
 /// Modifies the mesh geometry according to a displacement map.
 /// A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
 /// The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
 /// This method returns nothing.
 /// The parameter `url` is a string, the URL from the image file is to be downloaded.
 /// The parameters `minHeight` and `maxHeight` are the lower and upper limits of the displacement.
 /// The parameter `onSuccess` is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.
 /// The parameter `uvOffset` is an optional vector2 used to offset UV.
 /// The parameter `uvScale` is an optional vector2 used to scale UV.
 /// Returns the Mesh.
 external Mesh applyDisplacementMap(String url, num minHeight, num maxHeight, [void onSuccess(Mesh mesh), Vector2 uvOffset, Vector2 uvScale]);
 /// Modifies the mesh geometry according to a displacementMap buffer.
 /// A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
 /// The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
 /// This method returns nothing.
 /// The parameter `buffer` is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.
 /// The parameters `heightMapWidth` and `heightMapHeight` are positive integers to set the width and height of the buffer image.
 /// The parameters `minHeight` and `maxHeight` are the lower and upper limits of the displacement.
 /// The parameter `uvOffset` is an optional vector2 used to offset UV.
 /// The parameter `uvScale` is an optional vector2 used to scale UV.
 /// Returns the Mesh.
 external Mesh applyDisplacementMapFromBuffer(Uint8List buffer, num heightMapWidth, num heightMapHeight, num minHeight, num maxHeight, [Vector2 uvOffset, Vector2 uvScale]);
 /// Modify the mesh to get a flat shading rendering.
 /// This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.
 /// This method returns the Mesh.
 /// Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.
 external Mesh convertToFlatShadedMesh();
 /// This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.
 /// In other words, more vertices, no more indices and a single bigger VBO.
 /// The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.
 /// Returns the Mesh.
 external Mesh convertToUnIndexedMesh();
 /// Inverses facet orientations and inverts also the normals with `flipNormals` (default `false`) if true.
 /// This method returns the Mesh.
 /// Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
 external Mesh flipFaces([bool flipNormals]);
 /// Creates a new InstancedMesh object from the mesh model.
 /// An instance shares the same properties and the same material than its model.
 /// Only these properties of each instance can then be set individually :
 /// - position
 /// - rotation
 /// - rotationQuaternion
 /// - setPivotMatrix
 /// - scaling
 /// tuto : http://doc.babylonjs.com/tutorials/How_to_use_Instances
 /// Warning : this method is not supported for Line mesh and LineSystem
 external InstancedMesh createInstance(String name);
 /// Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.
 /// After this call, all the mesh instances have the same submeshes than the current mesh.
 /// This method returns the Mesh.
 external Mesh synchronizeInstances();
 /// Simplify the mesh according to the given array of settings.
 /// Function will return immediately and will simplify async. It returns the Mesh.
 external Mesh simplify(List<ISimplificationSettings> settings, [bool parallelProcessing, num/*enum SimplificationType*/ simplificationType, void successCallback([Mesh mesh, num submeshIndex])]);
 /// Optimization of the mesh's indices, in case a mesh has duplicated vertices.
 /// The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.
 /// This should be used together with the simplification to avoid disappearing triangles.
 /// Returns the Mesh.
 external Mesh optimizeIndices([void successCallback([Mesh mesh])]); external void serialize(dynamic serializationObject); external void JS$_syncGeometryWithMorphTargetManager();
 /// Returns a new Mesh object parsed from the source provided.
 /// The parameter `parsedMesh` is the source.
 /// The parameter `rootUrl` is a string, it's the root URL to prefix the `delayLoadingFile` property with
 external static Mesh Parse(dynamic parsedMesh, Scene scene, String rootUrl);
 /// Creates a ribbon mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The ribbon is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
 /// Please read this full tutorial to understand how to design a ribbon : http://doc.babylonjs.com/tutorials/Ribbon_Tutorial
 /// The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry.
 /// The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array.
 /// The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array.
 /// The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path.
 /// It's the offset to join together the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11.
 /// The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#ribbon
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateRibbon(String name, List<List<Vector3>> pathArray, dynamic/*bool|dynamic*/ closeArray, bool closePath, num offset, [Scene scene, bool updatable, num sideOrientation, Mesh instance]);
 /// Creates a plane polygonal mesh.  By default, this is a disc.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `radius` sets the radius size (float) of the polygon (default 0.5).
 /// The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc.
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateDisc(String name, num radius, num tessellation, [Scene/*Scene|Null*/ scene, bool updatable, num sideOrientation]);
 /// Creates a box mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `size` sets the size (float) of each box side (default 1).
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateBox(String name, num size, [Scene/*Scene|Null*/ scene, bool updatable, num sideOrientation]);
 /// Creates a sphere mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `diameter` sets the diameter size (float) of the sphere (default 1).
 /// The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32).
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateSphere(String name, num segments, num diameter, [Scene scene, bool updatable, num sideOrientation]);
 /// Creates a cylinder or a cone mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
 /// The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
 /// The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
 /// The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
 /// The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateCylinder(String name, num height, num diameterTop, num diameterBottom, num tessellation, dynamic subdivisions, [Scene scene, dynamic updatable, num sideOrientation]);
 /// Creates a torus mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `diameter` sets the diameter size (float) of the torus (default 1).
 /// The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5).
 /// The parameter `tessellation` sets the number of torus sides (postive integer, default 16).
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateTorus(String name, num diameter, num thickness, num tessellation, [Scene scene, bool updatable, num sideOrientation]);
 /// Creates a torus knot mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `radius` sets the global radius size (float) of the torus knot (default 2).
 /// The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32).
 /// The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32).
 /// The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3).
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateTorusKnot(String name, num radius, num tube, num radialSegments, num tubularSegments, num p, num q, [Scene scene, bool updatable, num sideOrientation]);
 /// Creates a line mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter.
 /// Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function.
 /// The parameter `points` is an array successive Vector3.
 /// The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
 /// When updating an instance, remember that only point positions can change, not the number of points.
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static LinesMesh CreateLines(String name, List<Vector3> points, [Scene/*Scene|Null*/ scene, bool updatable, LinesMesh/*LinesMesh|Null*/ instance]);
 /// Creates a dashed line mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter.
 /// Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function.
 /// The parameter `points` is an array successive Vector3.
 /// The parameter `dashNb` is the intended total number of dashes (positive integer, default 200).
 /// The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3).
 /// The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1).
 /// The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
 /// When updating an instance, remember that only point positions can change, not the number of points.
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static LinesMesh CreateDashedLines(String name, List<Vector3> points, num dashSize, num gapSize, num dashNb, [Scene/*Scene|Null*/ scene, bool updatable, LinesMesh instance]);
 /// Creates a polygon mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh.
 /// The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors.
 /// You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 /// Remember you can only change the shape positions, not their number when updating a polygon.
 external static Mesh CreatePolygon(String name, List<Vector3> shape, Scene scene, [List<List<Vector3>> holes, bool updatable, num sideOrientation]);
 /// Creates an extruded polygon mesh, with depth in the Y direction.
 /// Please consider using the same method from the MeshBuilder class instead.
 external static Mesh ExtrudePolygon(String name, List<Vector3> shape, num depth, Scene scene, [List<List<Vector3>> holes, bool updatable, num sideOrientation]);
 /// Creates an extruded shape mesh.
 /// The extrusion is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// Please read this full tutorial to understand how to design an extruded shape : http://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
 /// The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be
 /// extruded along the Z axis.
 /// The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
 /// The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
 /// The parameter `scale` (float, default 1) is the value to scale the shape.
 /// The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 /// The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
 /// Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh ExtrudeShape(String name, List<Vector3> shape, List<Vector3> path, num scale, num rotation, num cap, [Scene/*Scene|Null*/ scene, bool updatable, num sideOrientation, Mesh instance]);
 /// Creates an custom extruded shape mesh.
 /// The custom extrusion is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// Please read this full tutorial to understand how to design a custom extruded shape : http://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
 /// The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be
 /// extruded along the Z axis.
 /// The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
 /// The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path
 /// and the distance of this point from the begining of the path :
 /// ```javascript
 /// var rotationFunction = function(i, distance) {
 /// // do things
 /// return rotationValue; }
 /// ```
 /// It must returns a float value that will be the rotation in radians applied to the shape on each path point.
 /// The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path
 /// and the distance of this point from the begining of the path :
 /// ```javascript
 /// var scaleFunction = function(i, distance) {
 /// // do things
 /// return scaleValue;}
 /// ```
 /// It must returns a float value that will be the scale value applied to the shape on each path point.
 /// The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`.
 /// The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`.
 /// The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 /// The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
 /// Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh ExtrudeShapeCustom(String name, List<Vector3> shape, List<Vector3> path, Function scaleFunction, Function rotationFunction, bool ribbonCloseArray, bool ribbonClosePath, num cap, Scene scene, [bool updatable, num sideOrientation, Mesh instance]);
 /// Creates lathe mesh.
 /// The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be
 /// rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero.
 /// The parameter `radius` (positive float, default 1) is the radius value of the lathe.
 /// The parameter `tessellation` (positive integer, default 64) is the side number of the lathe.
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateLathe(String name, List<Vector3> shape, num radius, num tessellation, Scene scene, [bool updatable, num sideOrientation]);
 /// Creates a plane mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `size` sets the size (float) of both sides of the plane at once (default 1).
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreatePlane(String name, num size, Scene scene, [bool updatable, num sideOrientation]);
 /// Creates a ground mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground.
 /// The parameter `subdivisions` (positive integer) sets the number of subdivisions per side.
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateGround(String name, num width, num height, num subdivisions, [Scene scene, bool updatable]);
 /// Creates a tiled ground mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates.
 /// The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates.
 /// The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the
 /// numbers of subdivisions on the ground width and height. Each subdivision is called a tile.
 /// The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the
 /// numbers of subdivisions on the ground width and height of each tile.
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateTiledGround(String name, num xmin, num zmin, num xmax, num zmax, dynamic/*{
            w: number;
            h: number;
        }*/ subdivisions, dynamic/*{
            w: number;
            h: number;
        }*/ precision, Scene scene, [bool updatable]);
 /// Creates a ground mesh from a height map.
 /// tuto : http://doc.babylonjs.com/babylon101/height_map
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `url` sets the URL of the height map image resource.
 /// The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
 /// The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
 /// The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
 /// The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
 /// The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
 /// This function is passed the newly built mesh :
 /// ```javascript
 /// function(mesh) { // do things
 /// return; }
 /// ```
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static GroundMesh CreateGroundFromHeightMap(String name, String url, num width, num height, num subdivisions, num minHeight, num maxHeight, Scene scene, [bool updatable, void onReady(GroundMesh mesh)]);
 /// Creates a tube mesh.
 /// The tube is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube.
 /// The parameter `radius` (positive float, default 1) sets the tube radius size.
 /// The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface.
 /// The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`.
 /// This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path.
 /// It must return a radius value (positive float) :
 /// ```javascript
 /// var radiusFunction = function(i, distance) {
 /// // do things
 /// return radius; }
 /// ```
 /// The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 /// The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#tube
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateTube(String name, List<Vector3> path, num radius, num tessellation, dynamic/*{
            (i: number, distance: number): number;
        }*/ radiusFunction, num cap, Scene scene, [bool updatable, num sideOrientation, Mesh instance]);
 /// Creates a polyhedron mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial
 /// to choose the wanted type.
 /// The parameter `size` (positive float, default 1) sets the polygon size.
 /// You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value).
 /// You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`.
 /// A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
 /// You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`).
 /// To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
 /// The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored.
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreatePolyhedron(String name, dynamic/*{
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
        }*/ options, Scene scene);
 /// Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// The parameter `radius` sets the radius size (float) of the icosphere (default 1).
 /// You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`).
 /// The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size.
 /// The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface.
 /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 external static Mesh CreateIcoSphere(String name, dynamic/*{
            radius?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            updatable?: boolean;
        }*/ options, Scene scene);
 /// Creates a decal mesh.
 /// Please consider using the same method from the MeshBuilder class instead.
 /// A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal.
 /// The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates.
 /// The parameter `normal` (Vector3, default Vector3.Up) sets the normal of the mesh where the decal is applied onto in World coordinates.
 /// The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling.
 /// The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal.
 external static Mesh CreateDecal(String name, AbstractMesh sourceMesh, Vector3 position, Vector3 normal, Vector3 size, num angle);
 external Float32List setPositionsForCPUSkinning();
 external Float32List setNormalsForCPUSkinning();
 /// Updates the vertex buffer by applying transformation from the bones.
 /// Returns the Mesh.
 external Mesh applySkeleton(Skeleton skeleton);
 /// Returns an object `{min:` Vector3`, max:` Vector3`}`
 /// This min and max Vector3 are the minimum and maximum vectors of each mesh bounding box from the passed array, in the World system
 external static dynamic/*{
            min: Vector3;
            max: Vector3;
        }*/ MinMax(List<AbstractMesh> meshes);
 /// Returns a Vector3, the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array.
 external static Vector3 Center(dynamic/*{
            min: Vector3;
            max: Vector3;
        }|List<AbstractMesh>*/ meshesOrMinMaxVector);
 /// Merge the array of meshes into a single mesh for performance reasons.
 external static Mesh/*Mesh|Null*/ MergeMeshes(List<Mesh> meshes, [bool disposeSource, bool allow32BitsIndices, Mesh meshSubclass, bool subdivideWithSubMeshes]); }

 /// Define an interface for all classes that will get and set the data on vertices
 @anonymous @JS() abstract class IGetSetVerticesData { external bool isVerticesDataPresent(String kind); external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind, [bool copyWhenShared, bool forceCopy]); external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices([bool copyWhenShared]); external void setVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, bool updatable); external void updateVerticesData(String kind, dynamic/*List<num>|Float32List*/ data, [bool updateExtends, bool makeItUnique]); external void setIndices(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, num/*num|Null*/ totalVertices, [bool updatable]); }

 /// This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance
 @JS("BABYLON.VertexData" ) class VertexData { // @Ignore
 VertexData .fakeConstructor$() ;
 /// An array of the x, y, z position of each vertex  [...., x, y, z, .....]
 external dynamic/*List<num>|Float32List|Null*/ get positions; external set positions(dynamic/*List<num>|Float32List|Null*/ v);
 /// An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]
 external dynamic/*List<num>|Float32List|Null*/ get normals; external set normals(dynamic/*List<num>|Float32List|Null*/ v);
 /// An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]
 external dynamic/*List<num>|Float32List|Null*/ get tangents; external set tangents(dynamic/*List<num>|Float32List|Null*/ v);
 /// An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
 external dynamic/*List<num>|Float32List|Null*/ get uvs; external set uvs(dynamic/*List<num>|Float32List|Null*/ v);
 /// A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
 external dynamic/*List<num>|Float32List|Null*/ get uvs2; external set uvs2(dynamic/*List<num>|Float32List|Null*/ v);
 /// A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
 external dynamic/*List<num>|Float32List|Null*/ get uvs3; external set uvs3(dynamic/*List<num>|Float32List|Null*/ v);
 /// A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
 external dynamic/*List<num>|Float32List|Null*/ get uvs4; external set uvs4(dynamic/*List<num>|Float32List|Null*/ v);
 /// A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
 external dynamic/*List<num>|Float32List|Null*/ get uvs5; external set uvs5(dynamic/*List<num>|Float32List|Null*/ v);
 /// A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
 external dynamic/*List<num>|Float32List|Null*/ get uvs6; external set uvs6(dynamic/*List<num>|Float32List|Null*/ v);
 /// An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]
 external dynamic/*List<num>|Float32List|Null*/ get colors; external set colors(dynamic/*List<num>|Float32List|Null*/ v);
 /// An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).
 external dynamic/*List<num>|Float32List|Null*/ get matricesIndices; external set matricesIndices(dynamic/*List<num>|Float32List|Null*/ v);
 /// An array containing the list of weights defining the weight of each indexed matrix in the final computation
 external dynamic/*List<num>|Float32List|Null*/ get matricesWeights; external set matricesWeights(dynamic/*List<num>|Float32List|Null*/ v);
 /// An array extending the number of possible indices
 external dynamic/*List<num>|Float32List|Null*/ get matricesIndicesExtra; external set matricesIndicesExtra(dynamic/*List<num>|Float32List|Null*/ v);
 /// An array extending the number of possible weights when the number of indices is extended
 external dynamic/*List<num>|Float32List|Null*/ get matricesWeightsExtra; external set matricesWeightsExtra(dynamic/*List<num>|Float32List|Null*/ v);
 /// An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]
 external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ get indices; external set indices(dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ v);
 /// Uses the passed data array to set the set the values for the specified kind of data
 external void JS$set(dynamic/*List<num>|Float32List*/ data, String kind);
 /// Associates the vertexData to the passed Mesh.
 /// Sets it as updatable or not (default `false`)
 external VertexData applyToMesh(Mesh mesh, [bool updatable]);
 /// Associates the vertexData to the passed Geometry.
 /// Sets it as updatable or not (default `false`)
 external VertexData applyToGeometry(Geometry geometry, [bool updatable]);
 /// Updates the associated mesh
 external VertexData updateMesh(Mesh mesh, [bool updateExtends, bool makeItUnique]);
 /// Updates the associated geometry
 external VertexData updateGeometry(Geometry geometry, [bool updateExtends, bool makeItUnique]); external JS$_applyTo(meshOrGeometry, [updatable]); external JS$_update(meshOrGeometry, [updateExtends, makeItUnique]);
 /// Transforms each position and each normal of the vertexData according to the passed Matrix
 external VertexData transform(Matrix matrix);
 /// Merges the passed VertexData into the current one
 external VertexData merge(VertexData other); external JS$_mergeElement(source, other); external JS$_validate();
 /// Serializes the VertexData
 external dynamic serialize();
 /// Extracts the vertexData from a mesh
 external static VertexData ExtractFromMesh(Mesh mesh, [bool copyWhenShared, bool forceCopy]);
 /// Extracts the vertexData from the geometry
 external static VertexData ExtractFromGeometry(Geometry geometry, [bool copyWhenShared, bool forceCopy]); external static JS$_ExtractFrom(meshOrGeometry, [copyWhenShared, forceCopy]);
 /// Creates the VertexData for a Ribbon
 /// * pathArray array of paths, each of which an array of successive Vector3
 /// * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false
 /// * closePath creates a seam between the first and the last points of each path of the path array, optional, default false
 /// * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length
 /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 /// * invertUV swaps in the U and V coordinates when applying a texture, optional, default false
 /// * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional
 /// * colors a linear array, of length 4 * number of vertices, of custom color values, optional
 external static VertexData CreateRibbon(dynamic/*{
            pathArray: Vector3[][];
            closeArray?: boolean;
            closePath?: boolean;
            offset?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            invertUV?: boolean;
            uvs?: Vector2[];
            colors?: Color4[];
        }*/ options);
 /// Creates the VertexData for a box
 /// * size sets the width, height and depth of the box to the value of size, optional default 1
 /// * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size
 /// * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size
 /// * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size
 /// * faceUV an array of 6 Vector4 elements used to set different images to each box side
 /// * faceColors an array of 6 Color3 elements used to set different colors to each box side
 /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 external static VertexData CreateBox(dynamic/*{
            size?: number;
            width?: number;
            height?: number;
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options);
 /// Creates the VertexData for an ellipsoid, defaults to a sphere
 /// * segments sets the number of horizontal strips optional, default 32
 /// * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1
 /// * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter
 /// * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter
 /// * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter
 /// * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1
 /// * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1
 /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 external static VertexData CreateSphere(dynamic/*{
            segments?: number;
            diameter?: number;
            diameterX?: number;
            diameterY?: number;
            diameterZ?: number;
            arc?: number;
            slice?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options);
 /// Creates the VertexData for a cylinder, cone or prism
 /// * height sets the height (y direction) of the cylinder, optional, default 2
 /// * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter
 /// * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter
 /// * diameter sets the diameter of the top and bottom of the cone, optional default 1
 /// * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
 /// * subdivisions` the number of rings along the cylinder height, optional, default 1
 /// * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1
 /// * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
 /// * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
 /// * hasRings when true makes each subdivision independantly treated as a face for faceUV and faceColors, optional, default false
 /// * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake
 /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 external static VertexData CreateCylinder(dynamic/*{
            height?: number;
            diameterTop?: number;
            diameterBottom?: number;
            diameter?: number;
            tessellation?: number;
            subdivisions?: number;
            arc?: number;
            faceColors?: Color4[];
            faceUV?: Vector4[];
            hasRings?: boolean;
            enclose?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options);
 /// Creates the VertexData for a torus
 /// * diameter the diameter of the torus, optional default 1
 /// * thickness the diameter of the tube forming the torus, optional default 0.5
 /// * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
 /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 external static VertexData CreateTorus(dynamic/*{
            diameter?: number;
            thickness?: number;
            tessellation?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options);
 /// Creates the VertexData of the LineSystem
 /// - lines an array of lines, each line being an array of successive Vector3
 /// - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point
 external static VertexData CreateLineSystem(dynamic/*{
            lines: Vector3[][];
            colors?: Nullable<Color4[][]>;
        }*/ options);
 /// Create the VertexData for a DashedLines
 /// - points an array successive Vector3
 /// - dashSize the size of the dashes relative to the dash number, optional, default 3
 /// - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1
 /// - dashNb the intended total number of dashes, optional, default 200
 external static VertexData CreateDashedLines(dynamic/*{
            points: Vector3[];
            dashSize?: number;
            gapSize?: number;
            dashNb?: number;
        }*/ options);
 /// Creates the VertexData for a Ground
 /// - width the width (x direction) of the ground, optional, default 1
 /// - height the height (z direction) of the ground, optional, default 1
 /// - subdivisions the number of subdivisions per side, optional, default 1
 external static VertexData CreateGround(dynamic/*{
            width?: number;
            height?: number;
            subdivisions?: number;
            subdivisionsX?: number;
            subdivisionsY?: number;
        }*/ options);
 /// Creates the VertexData for a TiledGround by subdividing the ground into tiles
 /// * xmin the ground minimum X coordinate, optional, default -1
 /// * zmin the ground minimum Z coordinate, optional, default -1
 /// * xmax the ground maximum X coordinate, optional, default 1
 /// * zmax the ground maximum Z coordinate, optional, default 1
 /// * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}
 /// * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}
 external static VertexData CreateTiledGround(dynamic/*{
            xmin: number;
            zmin: number;
            xmax: number;
            zmax: number;
            subdivisions?: {
                w: number;
                h: number;
            };
            precision?: {
                w: number;
                h: number;
            };
        }*/ options);
 /// Creates the VertexData of the Ground designed from a heightmap
 /// * width the width (x direction) of the ground
 /// * height the height (z direction) of the ground
 /// * subdivisions the number of subdivisions per side
 /// * minHeight the minimum altitude on the ground, optional, default 0
 /// * maxHeight the maximum altitude on the ground, optional default 1
 /// * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)
 /// * buffer the array holding the image color data
 /// * bufferWidth the width of image
 /// * bufferHeight the height of image
 external static VertexData CreateGroundFromHeightMap(dynamic/*{
            width: number;
            height: number;
            subdivisions: number;
            minHeight: number;
            maxHeight: number;
            colorFilter: Color3;
            buffer: Uint8Array;
            bufferWidth: number;
            bufferHeight: number;
        }*/ options);
 /// Creates the VertexData for a Plane
 /// * size sets the width and height of the plane to the value of size, optional default 1
 /// * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size
 /// * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size
 /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 external static VertexData CreatePlane(dynamic/*{
            size?: number;
            width?: number;
            height?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options);
 /// Creates the VertexData of the Disc or regular Polygon
 /// * radius the radius of the disc, optional default 0.5
 /// * tessellation the number of polygon sides, optional, default 64
 /// * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1
 /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 external static VertexData CreateDisc(dynamic/*{
            radius?: number;
            tessellation?: number;
            arc?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options);
 /// Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()
 /// All parameters are provided by MeshBuilder.CreatePolygon as needed
 external static VertexData CreatePolygon(Mesh polygon, num sideOrientation, [List<Vector4> fUV, List<Color4> fColors, Vector4 frontUVs, Vector4 backUVs]);
 /// Creates the VertexData of the IcoSphere
 /// * radius the radius of the IcoSphere, optional default 1
 /// * radiusX allows stretching in the x direction, optional, default radius
 /// * radiusY allows stretching in the y direction, optional, default radius
 /// * radiusZ allows stretching in the z direction, optional, default radius
 /// * flat when true creates a flat shaded mesh, optional, default true
 /// * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
 /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 external static VertexData CreateIcoSphere(dynamic/*{
            radius?: number;
            radiusX?: number;
            radiusY?: number;
            radiusZ?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options);
 /// Creates the VertexData for a Polyhedron
 /// * type provided types are:
 /// * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)
 /// * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)
 /// * size the size of the IcoSphere, optional default 1
 /// * sizeX allows stretching in the x direction, optional, default size
 /// * sizeY allows stretching in the y direction, optional, default size
 /// * sizeZ allows stretching in the z direction, optional, default size
 /// * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor
 /// * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
 /// * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
 /// * flat when true creates a flat shaded mesh, optional, default true
 /// * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
 /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 external static VertexData CreatePolyhedron(dynamic/*{
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            flat?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options);
 /// Creates the VertexData for a TorusKnot
 /// * radius the radius of the torus knot, optional, default 2
 /// * tube the thickness of the tube, optional, default 0.5
 /// * radialSegments the number of sides on each tube segments, optional, default 32
 /// * tubularSegments the number of tubes to decompose the knot into, optional, default 32
 /// * p the number of windings around the z axis, optional,  default 2
 /// * q the number of windings around the x axis, optional,  default 3
 /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
 /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
 external static VertexData CreateTorusKnot(dynamic/*{
            radius?: number;
            tube?: number;
            radialSegments?: number;
            tubularSegments?: number;
            p?: number;
            q?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options);
 /// Compute normals for given positions and indices
 /// * facetNormals : optional array of facet normals (vector3)
 /// * facetPositions : optional array of facet positions (vector3)
 /// * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation
 /// * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation
 /// * bInfo : optional bounding info, required for facetPartitioning computation
 /// * bbSize : optional bounding box size data, required for facetPartitioning computation
 /// * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation
 /// * useRightHandedSystem: optional boolean to for right handed system computation
 /// * depthSort : optional boolean to enable the facet depth sort computation
 /// * distanceTo : optional Vector3 to compute the facet depth from this location
 /// * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location
 external static void ComputeNormals(dynamic positions, dynamic indices, dynamic normals, [dynamic/*{
            facetNormals?: any;
            facetPositions?: any;
            facetPartitioning?: any;
            ratio?: number;
            bInfo?: any;
            bbSize?: Vector3;
            subDiv?: any;
            useRightHandedSystem?: boolean;
            depthSort?: boolean;
            distanceTo?: Vector3;
            depthSortedFacets?: any;
        }*/ options]); external static JS$_ComputeSides(sideOrientation, positions, indices, normals, uvs, [frontUVs, backUVs]);
 /// Applies VertexData created from the imported parameters to the geometry
 external static void ImportVertexData(dynamic parsedVertexData, Geometry geometry); }

 /// Class containing static functions to help procedurally build meshes
 @JS("BABYLON.MeshBuilder" ) class MeshBuilder { // @Ignore
 MeshBuilder .fakeConstructor$() ;
 external static updateSideOrientation([orientation]);
 /// Creates a box mesh
 /// * The parameter `size` sets the size (float) of each box side (default 1)
 /// * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value than `size`)
 /// * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
 /// * Please read this tutorial : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#box
 external static Mesh CreateBox(String name, dynamic/*{
            size?: number;
            width?: number;
            height?: number;
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }*/ options, [Scene/*Scene|Null*/ scene]);
 /// Creates a sphere mesh
 /// * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
 /// * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value than `diameter`)
 /// * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
 /// * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
 /// * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#sphere
 external static Mesh CreateSphere(String name, dynamic/*{
            segments?: number;
            diameter?: number;
            diameterX?: number;
            diameterY?: number;
            diameterZ?: number;
            arc?: number;
            slice?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }*/ options, dynamic scene);
 /// Creates a plane polygonal mesh.  By default, this is a disc
 /// * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
 /// * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
 /// * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon
 external static Mesh CreateDisc(String name, dynamic/*{
            radius?: number;
            tessellation?: number;
            arc?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options, [Scene/*Scene|Null*/ scene]);
 /// Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
 /// * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
 /// * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`)
 /// * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
 /// * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere
 external static Mesh CreateIcoSphere(String name, dynamic/*{
            radius?: number;
            radiusX?: number;
            radiusY?: number;
            radiusZ?: number;
            flat?: boolean;
            subdivisions?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
        }*/ options, Scene scene);
 /// Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
 /// * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
 /// * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
 /// * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
 /// * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
 /// * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
 /// * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#ribbon
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
 /// * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
 /// * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
 /// * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
 /// * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/tutorials/Ribbon_Tutorial
 /// @see http://doc.babylonjs.com/tutorials/Parametric_Shapes
 external static Mesh CreateRibbon(String name, dynamic/*{
            pathArray: Vector3[][];
            closeArray?: boolean;
            closePath?: boolean;
            offset?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
            uvs?: Vector2[];
            colors?: Color4[];
        }*/ options, [Scene/*Scene|Null*/ scene]);
 /// Creates a cylinder or a cone mesh
 /// * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
 /// * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
 /// * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
 /// * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
 /// * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
 /// * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
 /// * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
 /// * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
 /// * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
 /// * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
 /// * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
 /// * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
 /// * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
 /// * If `enclose` is false, a ring surface is one element.
 /// * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
 /// * Example how to set colors and textures on a sliced cylinder : http://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 /// @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#cylinder-or-cone
 external static Mesh CreateCylinder(String name, dynamic/*{
            height?: number;
            diameterTop?: number;
            diameterBottom?: number;
            diameter?: number;
            tessellation?: number;
            subdivisions?: number;
            arc?: number;
            faceColors?: Color4[];
            faceUV?: Vector4[];
            updatable?: boolean;
            hasRings?: boolean;
            enclose?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options, dynamic scene);
 /// Creates a torus mesh
 /// * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
 /// * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
 /// * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 /// @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#torus
 external static Mesh CreateTorus(String name, dynamic/*{
            diameter?: number;
            thickness?: number;
            tessellation?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options, dynamic scene);
 /// Creates a torus knot mesh
 /// * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
 /// * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
 /// * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
 /// * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 /// @see  http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#torus-knot
 external static Mesh CreateTorusKnot(String name, dynamic/*{
            radius?: number;
            tube?: number;
            radialSegments?: number;
            tubularSegments?: number;
            p?: number;
            q?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options, dynamic scene);
 /// Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
 /// * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
 /// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
 /// * The parameter `lines` is an array of lines, each line being an array of successive Vector3
 /// * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
 /// * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
 /// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
 /// * Updating a simple Line mesh, you just need to update every line in the `lines` array : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
 /// * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/how_to/parametric_shapes#line-system
 external static LinesMesh CreateLineSystem(String name, dynamic/*{
            lines: Vector3[][];
            updatable?: boolean;
            instance?: Nullable<LinesMesh>;
            colors?: Nullable<Color4[][]>;
            useVertexAlpha?: boolean;
        }*/ options, Scene/*Scene|Null*/ scene);
 /// Creates a line mesh
 /// A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
 /// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
 /// * The parameter `points` is an array successive Vector3
 /// * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
 /// * The optional parameter `colors` is an array of successive Color4, one per line point
 /// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
 /// * When updating an instance, remember that only point positions can change, not the number of points
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/how_to/parametric_shapes#lines
 external static LinesMesh CreateLines(String name, dynamic/*{
            points: Vector3[];
            updatable?: boolean;
            instance?: Nullable<LinesMesh>;
            colors?: Color4[];
            useVertexAlpha?: boolean;
        }*/ options, [Scene/*Scene|Null*/ scene]);
 /// Creates a dashed line mesh
 /// * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
 /// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
 /// * The parameter `points` is an array successive Vector3
 /// * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
 /// * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
 /// * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
 /// * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
 /// * When updating an instance, remember that only point positions can change, not the number of points
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines
 external static LinesMesh CreateDashedLines(String name, dynamic/*{
            points: Vector3[];
            dashSize?: number;
            gapSize?: number;
            dashNb?: number;
            updatable?: boolean;
            instance?: LinesMesh;
        }*/ options, [Scene/*Scene|Null*/ scene]);
 /// Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
 /// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
 /// * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
 /// * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
 /// * The parameter `scale` (float, default 1) is the value to scale the shape.
 /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 /// * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
 /// * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 /// @see http://doc.babylonjs.com/tutorials/Parametric_Shapes
 /// @see http://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
 /// @see http://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
 external static Mesh ExtrudeShape(String name, dynamic/*{
            shape: Vector3[];
            path: Vector3[];
            scale?: number;
            rotation?: number;
            cap?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }*/ options, [Scene/*Scene|Null*/ scene]);
 /// Creates an custom extruded shape mesh.
 /// The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
 /// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
 /// * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
 /// * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
 /// * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
 /// * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
 /// * It must returns a float value that will be the scale value applied to the shape on each path point
 /// * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`
 /// * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`
 /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 /// * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
 /// * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes
 /// @see http://doc.babylonjs.com/tutorials/Parametric_Shapes
 /// @see http://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes
 external static Mesh ExtrudeShapeCustom(String name, dynamic/*{
            shape: Vector3[];
            path: Vector3[];
            scaleFunction?: any;
            rotationFunction?: any;
            ribbonCloseArray?: boolean;
            ribbonClosePath?: boolean;
            cap?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }*/ options, Scene scene);
 /// Creates lathe mesh.
 /// The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe
 /// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
 /// * The parameter `radius` (positive float, default 1) is the radius value of the lathe
 /// * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
 /// * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
 /// * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
 /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/how_to/parametric_shapes#lathe
 external static Mesh CreateLathe(String name, dynamic/*{
            shape: Vector3[];
            radius?: number;
            tessellation?: number;
            arc?: number;
            closed?: boolean;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            cap?: number;
            invertUV?: boolean;
        }*/ options, Scene scene);
 /// Creates a plane mesh
 /// * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)
 /// * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value than `size`)
 /// * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#plane
 external static Mesh CreatePlane(String name, dynamic/*{
            size?: number;
            width?: number;
            height?: number;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            updatable?: boolean;
            sourcePlane?: Plane;
        }*/ options, Scene scene);
 /// Creates a ground mesh
 /// * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
 /// * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#plane
 external static Mesh CreateGround(String name, dynamic/*{
            width?: number;
            height?: number;
            subdivisions?: number;
            subdivisionsX?: number;
            subdivisionsY?: number;
            updatable?: boolean;
        }*/ options, dynamic scene);
 /// Creates a tiled ground mesh
 /// * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
 /// * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
 /// * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
 /// * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 /// @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#tiled-ground
 external static Mesh CreateTiledGround(String name, dynamic/*{
            xmin: number;
            zmin: number;
            xmax: number;
            zmax: number;
            subdivisions?: {
                w: number;
                h: number;
            };
            precision?: {
                w: number;
                h: number;
            };
            updatable?: boolean;
        }*/ options, Scene scene);
 /// Creates a ground mesh from a height map
 /// * The parameter `url` sets the URL of the height map image resource.
 /// * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
 /// * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
 /// * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
 /// * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
 /// * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
 /// * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
 /// @see http://doc.babylonjs.com/babylon101/height_map
 /// @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#ground-from-a-height-map
 external static GroundMesh CreateGroundFromHeightMap(String name, String url, dynamic/*{
            width?: number;
            height?: number;
            subdivisions?: number;
            minHeight?: number;
            maxHeight?: number;
            colorFilter?: Color3;
            updatable?: boolean;
            onReady?: (mesh: GroundMesh) => void;
        }*/ options, Scene scene);
 /// Creates a polygon mesh
 /// The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
 /// * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
 /// * You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
 /// * Remember you can only change the shape positions, not their number when updating a polygon
 external static Mesh CreatePolygon(String name, dynamic/*{
            shape: Vector3[];
            holes?: Vector3[][];
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options, Scene scene);
 /// Creates an extruded polygon mesh, with depth in the Y direction.
 /// * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)
 /// @see http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
 external static Mesh ExtrudePolygon(String name, dynamic/*{
            shape: Vector3[];
            holes?: Vector3[][];
            depth?: number;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options, Scene scene);
 /// Creates a tube mesh.
 /// The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
 /// * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
 /// * The parameter `radius` (positive float, default 1) sets the tube radius size
 /// * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
 /// * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`
 /// * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
 /// * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
 /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
 /// * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#tube
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/tutorials/Parametric_Shapes
 /// @see http://doc.babylonjs.com/tutorials/Mesh_CreateXXX_Methods_With_Options_Parameter#tube
 external static Mesh CreateTube(String name, dynamic/*{
            path: Vector3[];
            radius?: number;
            tessellation?: number;
            radiusFunction?: {
                (i: number, distance: number): number;
            };
            cap?: number;
            arc?: number;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
            instance?: Mesh;
            invertUV?: boolean;
        }*/ options, Scene scene);
 /// Creates a polyhedron mesh
 /// * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
 /// * The parameter `size` (positive float, default 1) sets the polygon size
 /// * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
 /// * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
 /// * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
 /// * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
 /// * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
 /// * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
 /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
 /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation
 /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
 /// @see http://doc.babylonjs.com/how_to/polyhedra_shapes
 external static Mesh CreatePolyhedron(String name, dynamic/*{
            type?: number;
            size?: number;
            sizeX?: number;
            sizeY?: number;
            sizeZ?: number;
            custom?: any;
            faceUV?: Vector4[];
            faceColors?: Color4[];
            flat?: boolean;
            updatable?: boolean;
            sideOrientation?: number;
            frontUVs?: Vector4;
            backUVs?: Vector4;
        }*/ options, Scene scene);
 /// Creates a decal mesh.
 /// A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
 /// * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
 /// * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
 /// * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
 /// * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal
 /// @see http://doc.babylonjs.com/how_to/decals
 external static Mesh CreateDecal(String name, AbstractMesh sourceMesh, dynamic/*{
            position?: Vector3;
            normal?: Vector3;
            size?: Vector3;
            angle?: number;
        }*/ options); external static JS$_ExtrudeShapeGeneric(name, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs); }

 @JS("BABYLON.MeshLODLevel" ) class MeshLODLevel { // @Ignore
 MeshLODLevel .fakeConstructor$() ;
 external num get distance; external set distance(num v); external Mesh get mesh; external set mesh(Mesh v); external factory MeshLODLevel(num distance, Mesh mesh); }

 /// A simplifier interface for future simplification implementations.
 @anonymous @JS() abstract class ISimplifier {
 /// Simplification of a given mesh according to the given settings.
 /// Since this requires computation, it is assumed that the function runs async.
 external void simplify(ISimplificationSettings settings, void successCallback(Mesh simplifiedMeshes), [void errorCallback()]); }

 /// Expected simplification settings.
 /// Quality should be between 0 and 1 (1 being 100%, 0 being 0%);
 @anonymous @JS() abstract class ISimplificationSettings { external num get quality; external set quality(num v); external num get distance; external set distance(num v); external bool get optimizeMesh; external set optimizeMesh(bool v); external factory ISimplificationSettings({ num quality, num distance, bool optimizeMesh}); }

 @JS("BABYLON.SimplificationSettings" ) class SimplificationSettings implements ISimplificationSettings { // @Ignore
 SimplificationSettings .fakeConstructor$() ;
 external num get quality; external set quality(num v); external num get distance; external set distance(num v); external dynamic/*bool|dynamic*/ get optimizeMesh; external set optimizeMesh(dynamic/*bool|dynamic*/ v); external factory SimplificationSettings(num quality, num distance, [dynamic/*bool|dynamic*/ optimizeMesh]); }

 @anonymous @JS() abstract class ISimplificationTask { external List<ISimplificationSettings> get settings; external set settings(List<ISimplificationSettings> v); external num/*enum SimplificationType*/ get simplificationType; external set simplificationType(num/*enum SimplificationType*/ v); external Mesh get mesh; external set mesh(Mesh v); external VoidFunc0 get successCallback; external set successCallback(VoidFunc0 v); external bool get parallelProcessing; external set parallelProcessing(bool v); external factory ISimplificationTask({ List<ISimplificationSettings> settings, num/*enum SimplificationType*/ simplificationType, Mesh mesh, VoidFunc0 successCallback, bool parallelProcessing}); }

 @JS("BABYLON.SimplificationQueue" ) class SimplificationQueue { // @Ignore
 SimplificationQueue .fakeConstructor$() ;
 external get JS$_simplificationArray; external set JS$_simplificationArray(v); external bool get running; external set running(bool v); external factory SimplificationQueue(); external void addTask(ISimplificationTask task); external void executeNext(); external void runSimplification(ISimplificationTask task); external getSimplifier(task); }

 /// The implemented types of simplification
 /// At the moment only Quadratic Error Decimation is implemented
 @JS("BABYLON.SimplificationType" ) class SimplificationType { external static num get
 /// Quadratic error decimation
 QUADRATIC; } @JS("BABYLON.DecimationTriangle" ) class DecimationTriangle { // @Ignore
 DecimationTriangle .fakeConstructor$() ;
 external List<DecimationVertex> get vertices; external set vertices(List<DecimationVertex> v); external Vector3 get normal; external set normal(Vector3 v); external List<num> get error; external set error(List<num> v); external bool get deleted; external set deleted(bool v); external bool get isDirty; external set isDirty(bool v); external num get borderFactor; external set borderFactor(num v); external bool get deletePending; external set deletePending(bool v); external num get originalOffset; external set originalOffset(num v); external factory DecimationTriangle(List<DecimationVertex> vertices); }

 @JS("BABYLON.DecimationVertex" ) class DecimationVertex { // @Ignore
 DecimationVertex .fakeConstructor$() ;
 external Vector3 get position; external set position(Vector3 v); external num get id; external set id(num v); external QuadraticMatrix get q; external set q(QuadraticMatrix v); external bool get isBorder; external set isBorder(bool v); external num get triangleStart; external set triangleStart(num v); external num get triangleCount; external set triangleCount(num v); external List<num> get originalOffsets; external set originalOffsets(List<num> v); external factory DecimationVertex(Vector3 position, num id); external void updatePosition(Vector3 newPosition); }

 @JS("BABYLON.QuadraticMatrix" ) class QuadraticMatrix { // @Ignore
 QuadraticMatrix .fakeConstructor$() ;
 external List<num> get data; external set data(List<num> v); external factory QuadraticMatrix([List<num> data]); external num det(num a11, num a12, num a13, num a21, num a22, num a23, num a31, num a32, num a33); external void addInPlace(QuadraticMatrix matrix); external void addArrayInPlace(List<num> data); external QuadraticMatrix add(QuadraticMatrix matrix); external static QuadraticMatrix FromData(num a, num b, num c, num d); external static List<num> DataFromNumbers(num a, num b, num c, num d); }

 @JS("BABYLON.Reference" ) class Reference { // @Ignore
 Reference .fakeConstructor$() ;
 external num get vertexId; external set vertexId(num v); external num get triangleId; external set triangleId(num v); external factory Reference(num vertexId, num triangleId); }

 /// An implementation of the Quadratic Error simplification algorithm.
 /// Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf
 /// Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS
 /// @author RaananW
 @JS("BABYLON.QuadraticErrorSimplification" ) class QuadraticErrorSimplification implements ISimplifier { // @Ignore
 QuadraticErrorSimplification .fakeConstructor$() ;
 external get JS$_mesh; external set JS$_mesh(v); external get triangles; external set triangles(v); external get vertices; external set vertices(v); external get references; external set references(v); external get JS$_reconstructedMesh; external set JS$_reconstructedMesh(v); external num get syncIterations; external set syncIterations(num v); external num get aggressiveness; external set aggressiveness(num v); external num get decimationIterations; external set decimationIterations(num v); external num get boundingBoxEpsilon; external set boundingBoxEpsilon(num v); external factory QuadraticErrorSimplification(Mesh JS$_mesh); external void simplify(ISimplificationSettings settings, void successCallback(Mesh simplifiedMesh)); external runDecimation(settings, submeshIndex, successCallback); external initWithMesh(submeshIndex, callback, [optimizeMesh]); external init(callback); external reconstructMesh(submeshIndex); external initDecimatedMesh(); external isFlipped(vertex1, vertex2, point, deletedArray, borderFactor, delTr); external updateTriangles(origVertex, vertex, deletedArray, deletedTriangles); external identifyBorder(); external updateMesh([identifyBorders]); external vertexError(q, point); external calculateError(vertex1, vertex2, [pointResult, normalResult, uvResult, colorResult]); }

 @JS("BABYLON.Polygon" ) class Polygon { // @Ignore
 Polygon .fakeConstructor$() ;
 external static List<Vector2> Rectangle(num xmin, num ymin, num xmax, num ymax); external static List<Vector2> Circle(num radius, [num cx, num cy, num numberOfSides]); external static List<Vector2> Parse(String input); external static Path2 StartingAt(num x, num y); }

 @JS("BABYLON.PolygonMeshBuilder" ) class PolygonMeshBuilder { // @Ignore
 PolygonMeshBuilder .fakeConstructor$() ;
 external get JS$_points; external set JS$_points(v); external get JS$_outlinepoints; external set JS$_outlinepoints(v); external get JS$_holes; external set JS$_holes(v); external get JS$_name; external set JS$_name(v); external get JS$_scene; external set JS$_scene(v); external get JS$_epoints; external set JS$_epoints(v); external get JS$_eholes; external set JS$_eholes(v); external JS$_addToepoint(points);
 /*external factory PolygonMeshBuilder(String name, Path2 contours, Scene scene);*/
 /*external factory PolygonMeshBuilder(String name, List<Vector2> contours, Scene scene);*/
 external factory PolygonMeshBuilder(String name, dynamic/*Path2|List<Vector2>*/ contours, Scene scene); external PolygonMeshBuilder addHole(List<Vector2> hole); external Mesh build([bool updatable, num depth]); external addSide(positions, normals, uvs, indices, bounds, points, depth, flip); }

 @JS("BABYLON.BaseSubMesh" ) class BaseSubMesh { // @Ignore
 BaseSubMesh .fakeConstructor$() ;
 external MaterialDefines/*MaterialDefines|Null*/ get JS$_materialDefines; external set JS$_materialDefines(MaterialDefines/*MaterialDefines|Null*/ v); external Effect/*Effect|Null*/ get JS$_materialEffect; external set JS$_materialEffect(Effect/*Effect|Null*/ v); external Effect/*Effect|Null*/ get effect; external set effect(Effect/*Effect|Null*/ v); external void setEffect(Effect/*Effect|Null*/ effect, [MaterialDefines/*MaterialDefines|Null*/ defines]); }

 @JS("BABYLON.SubMesh" ) class SubMesh extends BaseSubMesh implements ICullable { // @Ignore
 SubMesh .fakeConstructor$() : super.fakeConstructor$() ;
 external num get materialIndex; external set materialIndex(num v); external num get verticesStart; external set verticesStart(num v); external num get verticesCount; external set verticesCount(num v); external num get indexStart; external set indexStart(num v); external num get indexCount; external set indexCount(num v); external num get linesIndexCount; external set linesIndexCount(num v); external get JS$_mesh; external set JS$_mesh(v); external get JS$_renderingMesh; external set JS$_renderingMesh(v); external get JS$_boundingInfo; external set JS$_boundingInfo(v); external get JS$_linesIndexBuffer; external set JS$_linesIndexBuffer(v); external List<Vector3>/*List<Vector3>|Null*/ get JS$_lastColliderWorldVertices; external set JS$_lastColliderWorldVertices(List<Vector3>/*List<Vector3>|Null*/ v); external List<Plane> get JS$_trianglePlanes; external set JS$_trianglePlanes(List<Plane> v); external Matrix get JS$_lastColliderTransformMatrix; external set JS$_lastColliderTransformMatrix(Matrix v); external num get JS$_renderId; external set JS$_renderId(num v); external num get JS$_alphaIndex; external set JS$_alphaIndex(num v); external num get JS$_distanceToCamera; external set JS$_distanceToCamera(num v); external num get JS$_id; external set JS$_id(num v); external get JS$_currentMaterial; external set JS$_currentMaterial(v); external static SubMesh AddToMesh(num materialIndex, num verticesStart, num verticesCount, num indexStart, num indexCount, AbstractMesh mesh, [Mesh renderingMesh, bool createBoundingBox]); external factory SubMesh(num materialIndex, num verticesStart, num verticesCount, num indexStart, num indexCount, AbstractMesh mesh, [Mesh renderingMesh, bool createBoundingBox]); external bool get IsGlobal; external set IsGlobal(bool v);
 /// Returns the submesh BoudingInfo object.
 external BoundingInfo getBoundingInfo();
 /// Sets the submesh BoundingInfo.
 /// Return the SubMesh.
 external SubMesh setBoundingInfo(BoundingInfo boundingInfo);
 /// Returns the mesh of the current submesh.
 external AbstractMesh getMesh();
 /// Returns the rendering mesh of the submesh.
 external Mesh getRenderingMesh();
 /// Returns the submesh material.
 external Material/*Material|Null*/ getMaterial();
 /// Sets a new updated BoundingInfo object to the submesh.
 /// Returns the SubMesh.
 external SubMesh refreshBoundingInfo(); external bool JS$_checkCollision(Collider collider);
 /// Updates the submesh BoundingInfo.
 /// Returns the Submesh.
 external SubMesh updateBoundingInfo(Matrix world);
 /// True is the submesh bounding box intersects the frustum defined by the passed array of planes.
 /// Boolean returned.
 external bool isInFrustum(List<Plane> frustumPlanes);
 /// True is the submesh bounding box is completely inside the frustum defined by the passed array of planes.
 /// Boolean returned.
 external bool isCompletelyInFrustum(List<Plane> frustumPlanes);
 /// Renders the submesh.
 /// Returns it.
 external SubMesh render(bool enableAlphaMode);
 /// Returns a new Index Buffer.
 /// Type returned : WebGLBuffer.
 external Buffer getLinesIndexBuffer(dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, Engine engine);
 /// True is the passed Ray intersects the submesh bounding box.
 /// Boolean returned.
 external bool canIntersects(Ray ray);
 /// Returns an object IntersectionInfo.
 external IntersectionInfo/*IntersectionInfo|Null*/ intersects(Ray ray, List<Vector3> positions, dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, [bool fastCheck]); external void JS$_rebuild();
 /// Creates a new Submesh from the passed Mesh.
 external SubMesh clone(AbstractMesh newMesh, [Mesh newRenderingMesh]);
 /// Disposes the Submesh.
 /// Returns nothing.
 external void dispose();
 /// Creates a new Submesh from the passed parameters :
 /// - materialIndex (integer) : the index of the main mesh material.
 /// - startIndex (integer) : the index where to start the copy in the mesh indices array.
 /// - indexCount (integer) : the number of indices to copy then from the startIndex.
 /// - mesh (Mesh) : the main mesh to create the submesh from.
 /// - renderingMesh (optional Mesh) : rendering mesh.
 external static SubMesh CreateFromIndices(num materialIndex, num startIndex, num indexCount, AbstractMesh mesh, [Mesh renderingMesh]); }

 @JS("BABYLON.TransformNode" ) class TransformNode extends Node { // @Ignore
 TransformNode .fakeConstructor$() : super.fakeConstructor$() ;
 external static num get BILLBOARDMODE_NONE; external static set BILLBOARDMODE_NONE(num v); external static num get BILLBOARDMODE_X; external static set BILLBOARDMODE_X(num v); external static num get BILLBOARDMODE_Y; external static set BILLBOARDMODE_Y(num v); external static num get BILLBOARDMODE_Z; external static set BILLBOARDMODE_Z(num v); external static num get BILLBOARDMODE_ALL; external static set BILLBOARDMODE_ALL(num v); external get JS$_forward; external set JS$_forward(v); external get JS$_forwardInverted; external set JS$_forwardInverted(v); external get JS$_up; external set JS$_up(v); external get JS$_right; external set JS$_right(v); external get JS$_rightInverted; external set JS$_rightInverted(v); external get JS$_rotation; external set JS$_rotation(v); external get JS$_rotationQuaternion; external set JS$_rotationQuaternion(v); external Vector3 get JS$_scaling; external set JS$_scaling(Vector3 v); external bool get JS$_isDirty; external set JS$_isDirty(bool v); external get JS$_transformToBoneReferal; external set JS$_transformToBoneReferal(v); external num get billboardMode; external set billboardMode(num v); external num get scalingDeterminant; external set scalingDeterminant(num v); external bool get infiniteDistance; external set infiniteDistance(bool v); external Vector3 get position; external set position(Vector3 v); external Matrix get JS$_poseMatrix; external set JS$_poseMatrix(Matrix v); external get JS$_localWorld; external set JS$_localWorld(v); external Matrix get JS$_worldMatrix; external set JS$_worldMatrix(Matrix v); external num get JS$_worldMatrixDeterminant; external set JS$_worldMatrixDeterminant(num v); external get JS$_absolutePosition; external set JS$_absolutePosition(v); external get JS$_pivotMatrix; external set JS$_pivotMatrix(v); external get JS$_pivotMatrixInverse; external set JS$_pivotMatrixInverse(v); external get JS$_postMultiplyPivotMatrix; external set JS$_postMultiplyPivotMatrix(v); external bool get JS$_isWorldMatrixFrozen; external set JS$_isWorldMatrixFrozen(bool v);
 /// An event triggered after the world matrix is updated
 external Observable<TransformNode> get onAfterWorldMatrixUpdateObservable; external set onAfterWorldMatrixUpdateObservable(Observable<TransformNode> v); external factory TransformNode(String name, [Scene/*Scene|Null*/ scene, bool isPure]);
 /// Gets a string idenfifying the name of the class
 external String getClassName();
 /// Rotation property : a Vector3 depicting the rotation value in radians around each local axis X, Y, Z.
 /// If rotation quaternion is set, this Vector3 will (almost always) be the Zero vector!
 /// Default : (0.0, 0.0, 0.0)
 external Vector3 get rotation; external set rotation(Vector3 v);
 /// Scaling property : a Vector3 depicting the mesh scaling along each local axis X, Y, Z.
 /// Default : (1.0, 1.0, 1.0)
 /// Scaling property : a Vector3 depicting the mesh scaling along each local axis X, Y, Z.
 /// Default : (1.0, 1.0, 1.0)
 external Vector3 get scaling; external set scaling(Vector3 v);
 /// Rotation Quaternion property : this a Quaternion object depicting the mesh rotation by using a unit quaternion.
 /// It's null by default.
 /// If set, only the rotationQuaternion is then used to compute the mesh rotation and its property `.rotation\ is then ignored and set to (0.0, 0.0, 0.0)
 external Quaternion/*Quaternion|Null*/ get rotationQuaternion; external set rotationQuaternion(Quaternion/*Quaternion|Null*/ v);
 /// The forward direction of that transform in world space.
 external Vector3 get forward; external set forward(Vector3 v);
 /// The up direction of that transform in world space.
 external Vector3 get up; external set up(Vector3 v);
 /// The right direction of that transform in world space.
 external Vector3 get right; external set right(Vector3 v);
 /// Returns the latest update of the World matrix
 /// Returns a Matrix.
 external Matrix getWorldMatrix();
 /// @hidden
 external num JS$_getWorldMatrixDeterminant();
 /// Returns directly the latest state of the mesh World matrix.
 /// A Matrix is returned.
 external Matrix get worldMatrixFromCache; external set worldMatrixFromCache(Matrix v);
 /// Copies the paramater passed Matrix into the mesh Pose matrix.
 /// Returns the TransformNode.
 external TransformNode updatePoseMatrix(Matrix matrix);
 /// Returns the mesh Pose matrix.
 /// Returned object : Matrix
 external Matrix getPoseMatrix(); external bool JS$_isSynchronized(); external void JS$_initCache(); external TransformNode markAsDirty(String property);
 /// Returns the current mesh absolute position.
 /// Retuns a Vector3.
 external Vector3 get absolutePosition; external set absolutePosition(Vector3 v);
 /// Sets a new matrix to apply before all other transformation
 external TransformNode setPreTransformMatrix(Matrix matrix);
 /// Sets a new pivot matrix to the current node
 external TransformNode setPivotMatrix(Matrix matrix, [bool postMultiplyPivotMatrix]);
 /// Returns the mesh pivot matrix.
 /// Default : Identity.
 /// A Matrix is returned.
 external Matrix getPivotMatrix();
 /// Prevents the World matrix to be computed any longer.
 /// Returns the TransformNode.
 external TransformNode freezeWorldMatrix();
 /// Allows back the World matrix computation.
 /// Returns the TransformNode.
 external TransformNode unfreezeWorldMatrix();
 /// True if the World matrix has been frozen.
 /// Returns a boolean.
 external bool get isWorldMatrixFrozen; external set isWorldMatrixFrozen(bool v);
 /// Retuns the mesh absolute position in the World.
 /// Returns a Vector3.
 external Vector3 getAbsolutePosition();
 /// Sets the mesh absolute position in the World from a Vector3 or an Array(3).
 /// Returns the TransformNode.
 external TransformNode setAbsolutePosition(Vector3 absolutePosition);
 /// Sets the mesh position in its local space.
 /// Returns the TransformNode.
 external TransformNode setPositionWithLocalVector(Vector3 vector3);
 /// Returns the mesh position in the local space from the current World matrix values.
 /// Returns a new Vector3.
 external Vector3 getPositionExpressedInLocalSpace();
 /// Translates the mesh along the passed Vector3 in its local space.
 /// Returns the TransformNode.
 external TransformNode locallyTranslate(Vector3 vector3); external static get JS$_lookAtVectorCache; external static set JS$_lookAtVectorCache(v);
 /// Orients a mesh towards a target point. Mesh must be drawn facing user.
 external TransformNode lookAt(Vector3 targetPoint, [num yawCor, num pitchCor, num rollCor, num/*enum Space*/ space]);
 /// Returns a new Vector3 what is the localAxis, expressed in the mesh local space, rotated like the mesh.
 /// This Vector3 is expressed in the World space.
 external Vector3 getDirection(Vector3 localAxis);
 /// Sets the Vector3 "result" as the rotated Vector3 "localAxis" in the same rotation than the mesh.
 /// localAxis is expressed in the mesh local space.
 /// result is computed in the Wordl space from the mesh World matrix.
 /// Returns the TransformNode.
 external TransformNode getDirectionToRef(Vector3 localAxis, Vector3 result);
 /// Sets a new pivot point to the current node
 external TransformNode setPivotPoint(Vector3 point, [num/*enum Space*/ space]);
 /// Returns a new Vector3 set with the mesh pivot point coordinates in the local space.
 external Vector3 getPivotPoint();
 /// Sets the passed Vector3 "result" with the coordinates of the mesh pivot point in the local space.
 /// Returns the TransformNode.
 external TransformNode getPivotPointToRef(Vector3 result);
 /// Returns a new Vector3 set with the mesh pivot point World coordinates.
 external Vector3 getAbsolutePivotPoint();
 /// Sets the Vector3 "result" coordinates with the mesh pivot point World coordinates.
 /// Returns the TransformNode.
 external TransformNode getAbsolutePivotPointToRef(Vector3 result);
 /// Defines the passed node as the parent of the current node.
 /// The node will remain exactly where it is and its position / rotation will be updated accordingly
 /// Returns the TransformNode.
 external TransformNode setParent(Node/*Node|Null*/ node); external get JS$_nonUniformScaling; external set JS$_nonUniformScaling(v); external bool get nonUniformScaling; external set nonUniformScaling(bool v); external bool JS$_updateNonUniformScalingState(bool value);
 /// Attach the current TransformNode to another TransformNode associated with a bone
 external TransformNode attachToBone(Bone bone, TransformNode affectedTransformNode); external TransformNode detachFromBone(); external static get JS$_rotationAxisCache; external static set JS$_rotationAxisCache(v);
 /// Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.
 /// space (default LOCAL) can be either BABYLON.Space.LOCAL, either BABYLON.Space.WORLD.
 /// Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
 /// The passed axis is also normalized.
 /// Returns the TransformNode.
 external TransformNode rotate(Vector3 axis, num amount, [num/*enum Space*/ space]);
 /// Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.
 /// Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
 /// The passed axis is also normalized.
 /// Returns the TransformNode.
 /// Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm
 external TransformNode rotateAround(Vector3 point, Vector3 axis, num amount);
 /// Translates the mesh along the axis vector for the passed distance in the given space.
 /// space (default LOCAL) can be either BABYLON.Space.LOCAL, either BABYLON.Space.WORLD.
 /// Returns the TransformNode.
 external TransformNode translate(Vector3 axis, num distance, [num/*enum Space*/ space]);
 /// Adds a rotation step to the mesh current rotation.
 /// x, y, z are Euler angles expressed in radians.
 /// This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.
 /// This means this rotation is made in the mesh local space only.
 /// It's useful to set a custom rotation order different from the BJS standard one YXZ.
 /// Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.
 /// ```javascript
 /// mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);
 /// ```
 /// Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.
 /// Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.
 /// Returns the TransformNode.
 external TransformNode addRotation(num x, num y, num z);
 /// Computes the mesh World matrix and returns it.
 /// If the mesh world matrix is frozen, this computation does nothing more than returning the last frozen values.
 /// If the parameter `force` is let to `false` (default), the current cached World matrix is returned.
 /// If the parameter `force`is set to `true`, the actual computation is done.
 /// Returns the mesh World Matrix.
 external Matrix computeWorldMatrix([bool force]); external void JS$_afterComputeWorldMatrix();
 /// If you'd like to be called back after the mesh position, rotation or scaling has been updated.
 /// Returns the TransformNode.
 external TransformNode registerAfterWorldMatrixUpdate(void func(TransformNode mesh));
 /// Removes a registered callback function.
 /// Returns the TransformNode.
 external TransformNode unregisterAfterWorldMatrixUpdate(void func(TransformNode mesh));
 /// Clone the current transform node
 /// Returns the new transform node
 external TransformNode/*TransformNode|Null*/ clone(String name, Node newParent, [bool doNotCloneChildren]); external dynamic serialize([dynamic currentSerializationObject]);
 /// Returns a new TransformNode object parsed from the source provided.
 /// The parameter `parsedMesh` is the source.
 /// The parameter `rootUrl` is a string, it's the root URL to prefix the `delayLoadingFile` property with
 external static TransformNode Parse(dynamic parsedTransformNode, Scene scene, String rootUrl);
 /// Releases resources associated with this transform node.
 external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]); }

 @JS("BABYLON.VertexBuffer" ) class VertexBuffer { // @Ignore
 VertexBuffer .fakeConstructor$() ;
 external get JS$_buffer; external set JS$_buffer(v); external get JS$_kind; external set JS$_kind(v); external get JS$_size; external set JS$_size(v); external get JS$_ownsBuffer; external set JS$_ownsBuffer(v); external get JS$_instanced; external set JS$_instanced(v); external get JS$_instanceDivisor; external set JS$_instanceDivisor(v);
 /// The byte type.
 external static num get BYTE; external static set BYTE(num v);
 /// The unsigned byte type.
 external static num get UNSIGNED_BYTE; external static set UNSIGNED_BYTE(num v);
 /// The short type.
 external static num get SHORT; external static set SHORT(num v);
 /// The unsigned short type.
 external static num get UNSIGNED_SHORT; external static set UNSIGNED_SHORT(num v);
 /// The integer type.
 external static num get INT; external static set INT(num v);
 /// The unsigned integer type.
 external static num get UNSIGNED_INT; external static set UNSIGNED_INT(num v);
 /// The float type.
 external static num get FLOAT; external static set FLOAT(num v);
 /// Gets or sets the instance divisor when in instanced mode
 external num get instanceDivisor; external set instanceDivisor(num v);
 /// Gets the byte stride.
 external num get byteStride; external set byteStride(num v);
 /// Gets the byte offset.
 external num get byteOffset; external set byteOffset(num v);
 /// Gets whether integer data values should be normalized into a certain range when being casted to a float.
 external bool get normalized; external set normalized(bool v);
 /// Gets the data type of each component in the array.
 external num get type; external set type(num v);
 /// Constructor
 external factory VertexBuffer(dynamic engine, dynamic/*List<num>|ByteBuffer|TypedData|Buffer*/ data, String kind, bool updatable, [bool postponeInternalCreation, num stride, bool instanced, num offset, num size, num type, bool normalized, bool useBytes]); external void JS$_rebuild();
 /// Returns the kind of the VertexBuffer (string).
 external String getKind();
 /// Boolean : is the VertexBuffer updatable ?
 external bool isUpdatable();
 /// Returns an array of numbers or a typed array containing the VertexBuffer data.
 external dynamic/*List<num>|ByteBuffer|TypedData|Null*/ getData();
 /// Returns the WebGLBuffer associated to the VertexBuffer.
 external Buffer/*Buffer|Null*/ getBuffer();
 /// Returns the stride as a multiple of the type byte length.
 /// DEPRECATED. Use byteStride instead.
 external num getStrideSize();
 /// Returns the offset as a multiple of the type byte length.
 /// DEPRECATED. Use byteOffset instead.
 external num getOffset();
 /// Returns the number of components per vertex attribute (integer).
 external num getSize();
 /// Boolean : is the WebGLBuffer of the VertexBuffer instanced now ?
 external bool getIsInstanced();
 /// Returns the instancing divisor, zero for non-instanced (integer).
 external num getInstanceDivisor();
 /// Creates the underlying WebGLBuffer from the passed numeric array or Float32Array.
 /// Returns the created WebGLBuffer.
 external void create([dynamic/*List<num>|ByteBuffer|TypedData*/ data]);
 /// Updates the underlying WebGLBuffer according to the passed numeric array or Float32Array.
 /// This function will create a new buffer if the current one is not updatable
 /// Returns the updated WebGLBuffer.
 external void update(dynamic/*List<num>|ByteBuffer|TypedData*/ data);
 /// Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.
 /// Returns the directly updated WebGLBuffer.
 external void updateDirectly(dynamic/*List<num>|ByteBuffer|TypedData*/ data, num offset, [bool useBytes]);
 /// Disposes the VertexBuffer and the underlying WebGLBuffer.
 external void dispose();
 /// Enumerates each value of this vertex buffer as numbers.
 external void forEach(num count, void callback(num value, num index)); external static get JS$_PositionKind; external static set JS$_PositionKind(v); external static get JS$_NormalKind; external static set JS$_NormalKind(v); external static get JS$_TangentKind; external static set JS$_TangentKind(v); external static get JS$_UVKind; external static set JS$_UVKind(v); external static get JS$_UV2Kind; external static set JS$_UV2Kind(v); external static get JS$_UV3Kind; external static set JS$_UV3Kind(v); external static get JS$_UV4Kind; external static set JS$_UV4Kind(v); external static get JS$_UV5Kind; external static set JS$_UV5Kind(v); external static get JS$_UV6Kind; external static set JS$_UV6Kind(v); external static get JS$_ColorKind; external static set JS$_ColorKind(v); external static get JS$_MatricesIndicesKind; external static set JS$_MatricesIndicesKind(v); external static get JS$_MatricesWeightsKind; external static set JS$_MatricesWeightsKind(v); external static get JS$_MatricesIndicesExtraKind; external static set JS$_MatricesIndicesExtraKind(v); external static get JS$_MatricesWeightsExtraKind; external static set JS$_MatricesWeightsExtraKind(v); external static String get PositionKind; external static set PositionKind(String v); external static String get NormalKind; external static set NormalKind(String v); external static String get TangentKind; external static set TangentKind(String v); external static String get UVKind; external static set UVKind(String v); external static String get UV2Kind; external static set UV2Kind(String v); external static String get UV3Kind; external static set UV3Kind(String v); external static String get UV4Kind; external static set UV4Kind(String v); external static String get UV5Kind; external static set UV5Kind(String v); external static String get UV6Kind; external static set UV6Kind(String v); external static String get ColorKind; external static set ColorKind(String v); external static String get MatricesIndicesKind; external static set MatricesIndicesKind(String v); external static String get MatricesWeightsKind; external static set MatricesWeightsKind(String v); external static String get MatricesIndicesExtraKind; external static set MatricesIndicesExtraKind(String v); external static String get MatricesWeightsExtraKind; external static set MatricesWeightsExtraKind(String v);
 /// Deduces the stride given a kind.
 external static num DeduceStride(String kind);
 /// Gets the byte length of the given type.
 external static num GetTypeByteLength(num type);
 /// Enumerates each value of the given parameters as numbers.
 external static void ForEach(dynamic/*List<num>|ByteBuffer|TypedData*/ data, num byteOffset, num byteStride, num componentCount, num componentType, num count, bool normalized, void callback(num value, num index)); external static JS$_GetFloatValue(dataView, type, byteOffset, normalized); }

 /// This represents a GPU particle system in Babylon
 /// This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data
 /// @see https://www.babylonjs-playground.com/#PU4WYI#4
 @JS("BABYLON.GPUParticleSystem" ) class GPUParticleSystem implements IDisposable, IParticleSystem, IAnimatable { // @Ignore
 GPUParticleSystem .fakeConstructor$() ;
 /// The id of the Particle system.
 external String get id; external set id(String v);
 /// The friendly name of the Particle system.
 external String get name; external set name(String v);
 /// The emitter represents the Mesh or position we are attaching the particle system to.
 external dynamic/*AbstractMesh|Vector3|Null*/ get emitter; external set emitter(dynamic/*AbstractMesh|Vector3|Null*/ v);
 /// The rendering group used by the Particle system to chose when to render.
 external num get renderingGroupId; external set renderingGroupId(num v);
 /// The layer mask we are rendering the particles through.
 external num get layerMask; external set layerMask(num v); external get JS$_capacity; external set JS$_capacity(v); external get JS$_activeCount; external set JS$_activeCount(v); external get JS$_currentActiveCount; external set JS$_currentActiveCount(v); external get JS$_renderEffect; external set JS$_renderEffect(v); external get JS$_updateEffect; external set JS$_updateEffect(v); external get JS$_buffer0; external set JS$_buffer0(v); external get JS$_buffer1; external set JS$_buffer1(v); external get JS$_spriteBuffer; external set JS$_spriteBuffer(v); external get JS$_updateVAO; external set JS$_updateVAO(v); external get JS$_renderVAO; external set JS$_renderVAO(v); external get JS$_targetIndex; external set JS$_targetIndex(v); external get JS$_sourceBuffer; external set JS$_sourceBuffer(v); external get JS$_targetBuffer; external set JS$_targetBuffer(v); external get JS$_scene; external set JS$_scene(v); external get JS$_engine; external set JS$_engine(v); external get JS$_currentRenderId; external set JS$_currentRenderId(v); external get JS$_started; external set JS$_started(v); external get JS$_stopped; external set JS$_stopped(v); external get JS$_timeDelta; external set JS$_timeDelta(v); external get JS$_randomTexture; external set JS$_randomTexture(v); external get JS$_attributesStrideSize; external set JS$_attributesStrideSize(v); external get JS$_updateEffectOptions; external set JS$_updateEffectOptions(v); external get JS$_randomTextureSize; external set JS$_randomTextureSize(v); external get JS$_actualFrame; external set JS$_actualFrame(v);
 /// List of animations used by the particle system.
 external List<Animation> get animations; external set animations(List<Animation> v);
 /// Gets a boolean indicating if the GPU particles can be rendered on current browser
 external static bool get IsSupported; external static set IsSupported(bool v);
 /// An event triggered when the system is disposed.
 external Observable<GPUParticleSystem> get onDisposeObservable; external set onDisposeObservable(Observable<GPUParticleSystem> v);
 /// The overall motion speed (0.01 is default update speed, faster updates = faster animation)
 external num get updateSpeed; external set updateSpeed(num v);
 /// The amount of time the particle system is running (depends of the overall update speed).
 external num get targetStopDuration; external set targetStopDuration(num v);
 /// The texture used to render each particle. (this can be a spritesheet)
 external Texture/*Texture|Null*/ get particleTexture; external set particleTexture(Texture/*Texture|Null*/ v);
 /// Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
 external num get blendMode; external set blendMode(num v);
 /// Minimum life time of emitting particles.
 external num get minLifeTime; external set minLifeTime(num v);
 /// Maximum life time of emitting particles.
 external num get maxLifeTime; external set maxLifeTime(num v);
 /// Minimum Size of emitting particles.
 external num get minSize; external set minSize(num v);
 /// Maximum Size of emitting particles.
 external num get maxSize; external set maxSize(num v);
 /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
 external Color4 get color1; external set color1(Color4 v);
 /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
 external Color4 get color2; external set color2(Color4 v);
 /// Color the particle will have at the end of its lifetime.
 external Color4 get colorDead; external set colorDead(Color4 v);
 /// The maximum number of particles to emit per frame until we reach the activeParticleCount value
 external num get emitRate; external set emitRate(num v);
 /// You can use gravity if you want to give an orientation to your particles.
 external Vector3 get gravity; external set gravity(Vector3 v);
 /// Minimum power of emitting particles.
 external num get minEmitPower; external set minEmitPower(num v);
 /// Maximum power of emitting particles.
 external num get maxEmitPower; external set maxEmitPower(num v);
 /// The particle emitter type defines the emitter used by the particle system.
 /// It can be for example box, sphere, or cone...
 external IParticleEmitterType/*IParticleEmitterType|Null*/ get particleEmitterType; external set particleEmitterType(IParticleEmitterType/*IParticleEmitterType|Null*/ v);
 /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
 /// This only works when particleEmitterTyps is a BoxParticleEmitter
 external Vector3 get direction1; external set direction1(Vector3 v);
 /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
 /// This only works when particleEmitterTyps is a BoxParticleEmitter
 external Vector3 get direction2; external set direction2(Vector3 v);
 /// Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
 /// This only works when particleEmitterTyps is a BoxParticleEmitter
 external Vector3 get minEmitBox; external set minEmitBox(Vector3 v);
 /// Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
 /// This only works when particleEmitterTyps is a BoxParticleEmitter
 external Vector3 get maxEmitBox; external set maxEmitBox(Vector3 v);
 /// Gets the maximum number of particles active at the same time.
 external num getCapacity();
 /// Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
 /// to override the particles.
 external bool get forceDepthWrite; external set forceDepthWrite(bool v);
 /// Gets or set the number of active particles
 external num get activeParticleCount; external set activeParticleCount(num v);
 /// Is this system ready to be used/rendered
 external bool isReady();
 /// Gets Wether the system has been started.
 external bool isStarted();
 /// Starts the particle system and begins to emit.
 external void start();
 /// Stops the particle system.
 external void stop();
 /// Remove all active particles
 external void reset();
 /// Returns the string "GPUParticleSystem"
 external String getClassName();
 /// Instantiates a GPU particle system.
 /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
 external factory GPUParticleSystem(String name, Partial<dynamic/*{
            capacity: number;
            randomTextureSize: number;
        }*/> options, Scene scene); external JS$_createUpdateVAO(source); external JS$_createRenderVAO(source, spriteSource); external JS$_initialize([force]);
 /// @hidden
 external void JS$_recreateUpdateEffect();
 /// @hidden
 external void JS$_recreateRenderEffect();
 /// Animates the particle system for the current frame by emitting new particles and or animating the living ones.
 external void animate();
 /// Renders the particle system in its current state.
 external num render();
 /// Rebuilds the particle system
 external void rebuild(); external JS$_releaseBuffers(); external JS$_releaseVAOs();
 /// Disposes the particle system and free the associated resources
 external void dispose([bool disposeTexture]);
 /// Clones the particle system.
 external GPUParticleSystem/*GPUParticleSystem|Null*/ clone(String name, dynamic newEmitter);
 /// Serializes the particle system to a JSON object.
 external dynamic serialize();
 /// Parses a JSON object to create a GPU particle system.
 external static GPUParticleSystem Parse(dynamic parsedParticleSystem, Scene scene, String rootUrl); }

 /// Interface representing a particle system in Babylon.
 /// This groups the common functionalities that needs to be implemented in order to create a particle system.
 /// A particle system represents a way to manage particles from their emission to their animation and rendering.
 @anonymous @JS() abstract class IParticleSystem {
 /// The id of the Particle system.
 external String get id; external set id(String v);
 /// The name of the Particle system.
 external String get name; external set name(String v);
 /// The emitter represents the Mesh or position we are attaching the particle system to.
 external dynamic/*AbstractMesh|Vector3|Null*/ get emitter; external set emitter(dynamic/*AbstractMesh|Vector3|Null*/ v);
 /// The rendering group used by the Particle system to chose when to render.
 external num get renderingGroupId; external set renderingGroupId(num v);
 /// The layer mask we are rendering the particles through.
 external num get layerMask; external set layerMask(num v);
 /// The overall motion speed (0.01 is default update speed, faster updates = faster animation)
 external num get updateSpeed; external set updateSpeed(num v);
 /// The amount of time the particle system is running (depends of the overall update speed).
 external num get targetStopDuration; external set targetStopDuration(num v);
 /// The texture used to render each particle. (this can be a spritesheet)
 external Texture/*Texture|Null*/ get particleTexture; external set particleTexture(Texture/*Texture|Null*/ v);
 /// Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
 external num get blendMode; external set blendMode(num v);
 /// Minimum life time of emitting particles.
 external num get minLifeTime; external set minLifeTime(num v);
 /// Maximum life time of emitting particles.
 external num get maxLifeTime; external set maxLifeTime(num v);
 /// Minimum Size of emitting particles.
 external num get minSize; external set minSize(num v);
 /// Maximum Size of emitting particles.
 external num get maxSize; external set maxSize(num v);
 /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
 external Color4 get color1; external set color1(Color4 v);
 /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
 external Color4 get color2; external set color2(Color4 v);
 /// Color the particle will have at the end of its lifetime.
 external Color4 get colorDead; external set colorDead(Color4 v);
 /// The maximum number of particles to emit per frame until we reach the activeParticleCount value
 external num get emitRate; external set emitRate(num v);
 /// You can use gravity if you want to give an orientation to your particles.
 external Vector3 get gravity; external set gravity(Vector3 v);
 /// Minimum power of emitting particles.
 external num get minEmitPower; external set minEmitPower(num v);
 /// Maximum power of emitting particles.
 external num get maxEmitPower; external set maxEmitPower(num v);
 /// The particle emitter type defines the emitter used by the particle system.
 /// It can be for example box, sphere, or cone...
 external IParticleEmitterType/*IParticleEmitterType|Null*/ get particleEmitterType; external set particleEmitterType(IParticleEmitterType/*IParticleEmitterType|Null*/ v);
 /// Gets the maximum number of particles active at the same time.
 external num getCapacity();
 /// Gets Wether the system has been started.
 /*external bool isStarted();*/
 /// Gets if the particle system has been started.
 /*external bool isStarted();*/
 external bool isStarted();
 /// Animates the particle system for this frame.
 external void animate();
 /// Renders the particle system in its current state.
 external num render();
 /// Dispose the particle system and frees its associated resources.
 external void dispose([bool disposeTexture]);
 /// Clones the particle system.
 external IParticleSystem/*IParticleSystem|Null*/ clone(String name, dynamic newEmitter);
 /// Serializes the particle system to a JSON object.
 external dynamic serialize();
 /// Rebuild the particle system
 external void rebuild();
 /// Starts the particle system and begins to emit.
 external void start();
 /// Stops the particle system.
 external void stop();
 /// Remove all active particles
 external void reset();
 /// Is this system ready to be used/rendered
 external bool isReady(); }

 /// A particle represents one of the element emitted by a particle system.
 /// This is mainly define by its coordinates, direction, velocity and age.
 @JS("BABYLON.Particle" ) class Particle { // @Ignore
 Particle .fakeConstructor$() ;
 /// particleSystem the particle system the particle belongs to.
 external ParticleSystem get particleSystem; external set particleSystem(ParticleSystem v);
 /// The world position of the particle in the scene.
 external Vector3 get position; external set position(Vector3 v);
 /// The world direction of the particle in the scene.
 external Vector3 get direction; external set direction(Vector3 v);
 /// The color of the particle.
 external Color4 get color; external set color(Color4 v);
 /// The color change of the particle per step.
 external Color4 get colorStep; external set colorStep(Color4 v);
 /// Defines how long will the life of the particle be.
 external num get lifeTime; external set lifeTime(num v);
 /// The current age of the particle.
 external num get age; external set age(num v);
 /// The current size of the particle.
 external num get size; external set size(num v);
 /// The current angle of the particle.
 external num get angle; external set angle(num v);
 /// Defines how fast is the angle changing.
 external num get angularSpeed; external set angularSpeed(num v);
 /// Defines the cell index used by the particle to be rendered from a sprite.
 external num get cellIndex; external set cellIndex(num v); external get JS$_currentFrameCounter; external set JS$_currentFrameCounter(v);
 /// Creates a new instance Particle
 external factory Particle(
 /// particleSystem the particle system the particle belongs to.
 ParticleSystem particleSystem); external updateCellInfoFromSystem();
 /// Defines how the sprite cell index is updated for the particle. This is
 /// defined as a callback.
 external VoidFunc1<num> get updateCellIndex; external set updateCellIndex(VoidFunc1<num> v); external JS$_updateCellIndexWithSpeedCalculated(scaledUpdateSpeed); external JS$_updateCellIndexWithCustomSpeed();
 /// Copy the properties of particle to another one.
 external void copyTo(Particle other); }

 /// This represents a particle system in Babylon.
 /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
 /// Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
 /// @example https://doc.babylonjs.com/babylon101/particles
 @JS("BABYLON.ParticleSystem" ) class ParticleSystem implements IDisposable, IAnimatable, IParticleSystem { // @Ignore
 ParticleSystem .fakeConstructor$() ;
 /// Source color is added to the destination color without alpha affecting the result.
 external static num get BLENDMODE_ONEONE; external static set BLENDMODE_ONEONE(num v);
 /// Blend current color and particle color using particle’s alpha.
 external static num get BLENDMODE_STANDARD; external static set BLENDMODE_STANDARD(num v);
 /// List of animations used by the particle system.
 external List<Animation> get animations; external set animations(List<Animation> v);
 /// The id of the Particle system.
 external String get id; external set id(String v);
 /// The friendly name of the Particle system.
 external String get name; external set name(String v);
 /// The rendering group used by the Particle system to chose when to render.
 external num get renderingGroupId; external set renderingGroupId(num v);
 /// The emitter represents the Mesh or position we are attaching the particle system to.
 external dynamic/*AbstractMesh|Vector3|Null*/ get emitter; external set emitter(dynamic/*AbstractMesh|Vector3|Null*/ v);
 /// The maximum number of particles to emit per frame
 external num get emitRate; external set emitRate(num v);
 /// If you want to launch only a few particles at once, that can be done, as well.
 external num get manualEmitCount; external set manualEmitCount(num v);
 /// The overall motion speed (0.01 is default update speed, faster updates = faster animation)
 external num get updateSpeed; external set updateSpeed(num v);
 /// The amount of time the particle system is running (depends of the overall update speed).
 external num get targetStopDuration; external set targetStopDuration(num v);
 /// Specifies whether the particle system will be disposed once it reaches the end of the animation.
 external bool get disposeOnStop; external set disposeOnStop(bool v);
 /// Minimum power of emitting particles.
 external num get minEmitPower; external set minEmitPower(num v);
 /// Maximum power of emitting particles.
 external num get maxEmitPower; external set maxEmitPower(num v);
 /// Minimum life time of emitting particles.
 external num get minLifeTime; external set minLifeTime(num v);
 /// Maximum life time of emitting particles.
 external num get maxLifeTime; external set maxLifeTime(num v);
 /// Minimum Size of emitting particles.
 external num get minSize; external set minSize(num v);
 /// Maximum Size of emitting particles.
 external num get maxSize; external set maxSize(num v);
 /// Minimum angular speed of emitting particles (Z-axis rotation for each particle).
 external num get minAngularSpeed; external set minAngularSpeed(num v);
 /// Maximum angular speed of emitting particles (Z-axis rotation for each particle).
 external num get maxAngularSpeed; external set maxAngularSpeed(num v);
 /// The texture used to render each particle. (this can be a spritesheet)
 external Texture/*Texture|Null*/ get particleTexture; external set particleTexture(Texture/*Texture|Null*/ v);
 /// The layer mask we are rendering the particles through.
 external num get layerMask; external set layerMask(num v);
 /// This can help using your own shader to render the particle system.
 /// The according effect will be created
 external dynamic get customShader; external set customShader(dynamic v);
 /// By default particle system starts as soon as they are created. This prevents the
 /// automatic start to happen and let you decide when to start emitting particles.
 external bool get preventAutoStart; external set preventAutoStart(bool v);
 /// This function can be defined to provide custom update for active particles.
 /// This function will be called instead of regular update (age, position, color, etc.).
 /// Do not forget that this function will be called on every frame so try to keep it simple and fast :)
 external VoidFunc1<List<Particle>> get updateFunction; external set updateFunction(VoidFunc1<List<Particle>> v);
 /// Callback triggered when the particle animation is ending.
 external VoidFunc0/*VoidFunc0|Null*/ get onAnimationEnd; external set onAnimationEnd(VoidFunc0/*VoidFunc0|Null*/ v);
 /// Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
 external num get blendMode; external set blendMode(num v);
 /// Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
 /// to override the particles.
 external bool get forceDepthWrite; external set forceDepthWrite(bool v);
 /// You can use gravity if you want to give an orientation to your particles.
 external Vector3 get gravity; external set gravity(Vector3 v);
 /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
 /// This only works when particleEmitterTyps is a BoxParticleEmitter
 external Vector3 get direction1; external set direction1(Vector3 v);
 /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
 /// This only works when particleEmitterTyps is a BoxParticleEmitter
 external Vector3 get direction2; external set direction2(Vector3 v);
 /// Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
 /// This only works when particleEmitterTyps is a BoxParticleEmitter
 external Vector3 get minEmitBox; external set minEmitBox(Vector3 v);
 /// Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
 /// This only works when particleEmitterTyps is a BoxParticleEmitter
 external Vector3 get maxEmitBox; external set maxEmitBox(Vector3 v);
 /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
 external Color4 get color1; external set color1(Color4 v);
 /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
 external Color4 get color2; external set color2(Color4 v);
 /// Color the particle will have at the end of its lifetime.
 external Color4 get colorDead; external set colorDead(Color4 v);
 /// An optional mask to filter some colors out of the texture, or filter a part of the alpha channel.
 external Color4 get textureMask; external set textureMask(Color4 v);
 /// The particle emitter type defines the emitter used by the particle system.
 /// It can be for example box, sphere, or cone...
 external IParticleEmitterType get particleEmitterType; external set particleEmitterType(IParticleEmitterType v);
 /// This function can be defined to specify initial direction for every new particle.
 /// It by default use the emitterType defined function.
 external VoidFunc4<num, Matrix, Vector3, Particle> get startDirectionFunction; external set startDirectionFunction(VoidFunc4<num, Matrix, Vector3, Particle> v);
 /// This function can be defined to specify initial position for every new particle.
 /// It by default use the emitterType defined function.
 external VoidFunc3<Matrix, Vector3, Particle> get startPositionFunction; external set startPositionFunction(VoidFunc3<Matrix, Vector3, Particle> v);
 /// If using a spritesheet (isAnimationSheetEnabled), defines if the sprite animation should loop between startSpriteCellID and endSpriteCellID or not.
 external bool get spriteCellLoop; external set spriteCellLoop(bool v);
 /// If using a spritesheet (isAnimationSheetEnabled) and spriteCellLoop defines the speed of the sprite loop.
 external num get spriteCellChangeSpeed; external set spriteCellChangeSpeed(num v);
 /// If using a spritesheet (isAnimationSheetEnabled) and spriteCellLoop defines the first sprite cell to display.
 external num get startSpriteCellID; external set startSpriteCellID(num v);
 /// If using a spritesheet (isAnimationSheetEnabled) and spriteCellLoop defines the last sprite cell to display.
 external num get endSpriteCellID; external set endSpriteCellID(num v);
 /// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use.
 external num get spriteCellWidth; external set spriteCellWidth(num v);
 /// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use.
 external num get spriteCellHeight; external set spriteCellHeight(num v);
 /// An event triggered when the system is disposed.
 external Observable<ParticleSystem> get onDisposeObservable; external set onDisposeObservable(Observable<ParticleSystem> v); external get JS$_onDisposeObserver; external set JS$_onDisposeObserver(v);
 /// Sets a callback that will be triggered when the system is disposed.
 external VoidFunc0 get onDispose; external set onDispose(VoidFunc0 v);
 /// Gets wether an animation sprite sheet is enabled or not on the particle system.
 external bool get isAnimationSheetEnabled; external set isAnimationSheetEnabled(bool v); external get JS$_particles; external set JS$_particles(v); external get JS$_epsilon; external set JS$_epsilon(v); external get JS$_capacity; external set JS$_capacity(v); external get JS$_scene; external set JS$_scene(v); external get JS$_stockParticles; external set JS$_stockParticles(v); external get JS$_newPartsExcess; external set JS$_newPartsExcess(v); external get JS$_vertexData; external set JS$_vertexData(v); external get JS$_vertexBuffer; external set JS$_vertexBuffer(v); external get JS$_vertexBuffers; external set JS$_vertexBuffers(v); external get JS$_indexBuffer; external set JS$_indexBuffer(v); external get JS$_effect; external set JS$_effect(v); external get JS$_customEffect; external set JS$_customEffect(v); external get JS$_cachedDefines; external set JS$_cachedDefines(v); external get JS$_scaledColorStep; external set JS$_scaledColorStep(v); external get JS$_colorDiff; external set JS$_colorDiff(v); external get JS$_scaledDirection; external set JS$_scaledDirection(v); external get JS$_scaledGravity; external set JS$_scaledGravity(v); external get JS$_currentRenderId; external set JS$_currentRenderId(v); external get JS$_alive; external set JS$_alive(v); external get JS$_started; external set JS$_started(v); external get JS$_stopped; external set JS$_stopped(v); external get JS$_actualFrame; external set JS$_actualFrame(v); external get JS$_scaledUpdateSpeed; external set JS$_scaledUpdateSpeed(v); external get JS$_vertexBufferSize; external set JS$_vertexBufferSize(v); external get JS$_isAnimationSheetEnabled; external set JS$_isAnimationSheetEnabled(v);
 /// this is the Sub-emitters templates that will be used to generate particle system when the particle dies, this property is used by the root particle system only.
 external List<ParticleSystem> get subEmitters; external set subEmitters(List<ParticleSystem> v);
 /// The current active Sub-systems, this property is used by the root particle system only.
 external List<ParticleSystem> get activeSubSystems; external set activeSubSystems(List<ParticleSystem> v); external get JS$_rootParticleSystem; external set JS$_rootParticleSystem(v);
 /// Gets the current list of active particles
 external List<Particle> get particles; external set particles(List<Particle> v);
 /// Returns the string "ParticleSystem"
 external String getClassName();
 /// Instantiates a particle system.
 /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
 external factory ParticleSystem(String name, num capacity, Scene scene, [Effect/*Effect|Null*/ customEffect, bool isAnimationSheetEnabled, num epsilon]); external JS$_createIndexBuffer();
 /// Gets the maximum number of particles active at the same time.
 external num getCapacity();
 /// Gets Wether there are still active particles in the system.
 external bool isAlive();
 /// Gets Wether the system has been started.
 external bool isStarted();
 /// Starts the particle system and begins to emit.
 external void start();
 /// Stops the particle system.
 external void stop([bool stopSubEmitters]);
 /// Remove all active particles
 external void reset();
 /// @hidden (for internal use only)
 external void JS$_appendParticleVertex(num index, Particle particle, num offsetX, num offsetY);
 /// @hidden (for internal use only)
 external void JS$_appendParticleVertexWithAnimation(num index, Particle particle, num offsetX, num offsetY);
 /// "Recycles" one of the particle by copying it back to the "stock" of particles and removing it from the active list.
 /// Its lifetime will start back at 0.
 external VoidFunc1<Particle> get recycleParticle; external set recycleParticle(VoidFunc1<Particle> v); external JS$_stopSubEmitters(); external get JS$_createParticle; external set JS$_createParticle(v); external JS$_removeFromRoot(); external get JS$_emitFromParticle; external set JS$_emitFromParticle(v); external JS$_update(newParticles); external JS$_getEffect();
 /// Animates the particle system for the current frame by emitting new particles and or animating the living ones.
 external void animate(); external get JS$_appendParticleVertexes; external set JS$_appendParticleVertexes(v); external JS$_appenedParticleVertexesWithSheet(offset, particle); external JS$_appenedParticleVertexesNoSheet(offset, particle);
 /// Rebuilds the particle system.
 external void rebuild();
 /// Is this system ready to be used/rendered
 external bool isReady();
 /// Renders the particle system in its current state.
 external num render();
 /// Disposes the particle system and free the associated resources
 external void dispose([bool disposeTexture]);
 /// Creates a Sphere Emitter for the particle system. (emits along the sphere radius)
 external SphereParticleEmitter createSphereEmitter([num radius]);
 /// Creates a Directed Sphere Emitter for the particle system. (emits between direction1 and direction2)
 external SphereDirectedParticleEmitter createDirectedSphereEmitter([num radius, Vector3 direction1, Vector3 direction2]);
 /// Creates a Cone Emitter for the particle system. (emits from the cone to the particle position)
 external ConeParticleEmitter createConeEmitter([num radius, num angle]);
 /// Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)
 external BoxParticleEmitter createBoxEmitter(Vector3 direction1, Vector3 direction2, Vector3 minEmitBox, Vector3 maxEmitBox);
 /// Clones the particle system.
 external ParticleSystem clone(String name, dynamic newEmitter);
 /// Serializes the particle system to a JSON object.
 external dynamic serialize();
 /// Parses a JSON object to create a particle system.
 external static ParticleSystem Parse(dynamic parsedParticleSystem, Scene scene, String rootUrl); }

 /// Represents one particle of a solid particle system.
 @JS("BABYLON.SolidParticle" ) class SolidParticle { // @Ignore
 SolidParticle .fakeConstructor$() ;
 /// particle global index
 external num get idx; external set idx(num v);
 /// The color of the particle
 external Color4/*Color4|Null*/ get color; external set color(Color4/*Color4|Null*/ v);
 /// The world space position of the particle.
 external Vector3 get position; external set position(Vector3 v);
 /// The world space rotation of the particle. (Not use if rotationQuaternion is set)
 external Vector3 get rotation; external set rotation(Vector3 v);
 /// The world space rotation quaternion of the particle.
 external Quaternion/*Quaternion|Null*/ get rotationQuaternion; external set rotationQuaternion(Quaternion/*Quaternion|Null*/ v);
 /// The scaling of the particle.
 external Vector3 get scaling; external set scaling(Vector3 v);
 /// The uvs of the particle.
 external Vector4 get uvs; external set uvs(Vector4 v);
 /// The current speed of the particle.
 external Vector3 get velocity; external set velocity(Vector3 v);
 /// The pivot point in the particle local space.
 external Vector3 get pivot; external set pivot(Vector3 v);
 /// Must the particle be translated from its pivot point in its local space ?
 /// In this case, the pivot point is set at the origin of the particle local space and the particle is translated.
 /// Default : false
 external bool get translateFromPivot; external set translateFromPivot(bool v);
 /// Is the particle active or not ?
 external bool get alive; external set alive(bool v);
 /// Is the particle visible or not ?
 external bool get isVisible; external set isVisible(bool v);
 /// Index of this particle in the global "positions" array (Internal use)
 external num get JS$_pos; external set JS$_pos(num v);
 /// Index of this particle in the global "indices" array (Internal use)
 external num get JS$_ind; external set JS$_ind(num v);
 /// ModelShape of this particle (Internal use)
 external ModelShape get JS$_model; external set JS$_model(ModelShape v);
 /// ModelShape id of this particle
 external num get shapeId; external set shapeId(num v);
 /// Index of the particle in its shape id (Internal use)
 external num get idxInShape; external set idxInShape(num v);
 /// Reference to the shape model BoundingInfo object (Internal use)
 external BoundingInfo get JS$_modelBoundingInfo; external set JS$_modelBoundingInfo(BoundingInfo v);
 /// Particle BoundingInfo object (Internal use)
 external BoundingInfo get JS$_boundingInfo; external set JS$_boundingInfo(BoundingInfo v);
 /// Reference to the SPS what the particle belongs to (Internal use)
 external SolidParticleSystem get JS$_sps; external set JS$_sps(SolidParticleSystem v);
 /// Still set as invisible in order to skip useless computations (Internal use)
 external bool get JS$_stillInvisible; external set JS$_stillInvisible(bool v);
 /// Last computed particle rotation matrix
 external List<num> get JS$_rotationMatrix; external set JS$_rotationMatrix(List<num> v);
 /// Parent particle Id, if any.
 /// Default null.
 external num/*num|Null*/ get parentId; external set parentId(num/*num|Null*/ v);
 /// Internal global position in the SPS.
 external Vector3 get JS$_globalPosition; external set JS$_globalPosition(Vector3 v);
 /// Creates a Solid Particle object.
 /// Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()
 external factory SolidParticle(num particleIndex, num positionIndex, num indiceIndex, ModelShape/*ModelShape|Null*/ model, num shapeId, num idxInShape, SolidParticleSystem sps, [BoundingInfo/*BoundingInfo|Null*/ modelBoundingInfo]);
 /// Legacy support, changed scale to scaling
 /// Legacy support, changed scale to scaling
 external Vector3 get scale; external set scale(Vector3 v);
 /// Legacy support, changed quaternion to rotationQuaternion
 /// Legacy support, changed quaternion to rotationQuaternion
 external Quaternion/*Quaternion|Null*/ get quaternion; external set quaternion(Quaternion/*Quaternion|Null*/ v);
 /// Returns a boolean. True if the particle intersects another particle or another mesh, else false.
 /// The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)
 external bool intersectsMesh(dynamic/*Mesh|SolidParticle*/ target); }

 /// Represents the shape of the model used by one particle of a solid particle system.
 /// SPS internal tool, don't use it manually.
 @JS("BABYLON.ModelShape" ) class ModelShape { // @Ignore
 ModelShape .fakeConstructor$() ;
 /// The shape id.
 external num get shapeID; external set shapeID(num v);
 /// flat array of model positions (internal use)
 external List<Vector3> get JS$_shape; external set JS$_shape(List<Vector3> v);
 /// flat array of model UVs (internal use)
 external List<num> get JS$_shapeUV; external set JS$_shapeUV(List<num> v);
 /// length of the shape in the model indices array (internal use)
 external num get JS$_indicesLength; external set JS$_indicesLength(num v);
 /// Custom position function (internal use)
 external VoidFunc3<SolidParticle, num, num>/*VoidFunc3<SolidParticle, num, num>|Null*/ get JS$_positionFunction; external set JS$_positionFunction(VoidFunc3<SolidParticle, num, num>/*VoidFunc3<SolidParticle, num, num>|Null*/ v);
 /// Custom vertex function (internal use)
 external VoidFunc3<SolidParticle, Vector3, num>/*VoidFunc3<SolidParticle, Vector3, num>|Null*/ get JS$_vertexFunction; external set JS$_vertexFunction(VoidFunc3<SolidParticle, Vector3, num>/*VoidFunc3<SolidParticle, Vector3, num>|Null*/ v);
 /// Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.
 /// SPS internal tool, don't use it manually.
 /// @hidden
 external factory ModelShape(num id, List<Vector3> shape, num indicesLength, List<num> shapeUV, VoidFunc3<SolidParticle, num, num>/*VoidFunc3<SolidParticle, num, num>|Null*/ posFunction, VoidFunc3<SolidParticle, Vector3, num>/*VoidFunc3<SolidParticle, Vector3, num>|Null*/ vtxFunction); }

 /// Represents a Depth Sorted Particle in the solid particle system.
 @JS("BABYLON.DepthSortedParticle" ) class DepthSortedParticle { // @Ignore
 DepthSortedParticle .fakeConstructor$() ;
 /// Index of the particle in the "indices" array
 external num get ind; external set ind(num v);
 /// Length of the particle shape in the "indices" array
 external num get indicesLength; external set indicesLength(num v);
 /// Squared distance from the particle to the camera
 external num get sqDistance; external set sqDistance(num v); }

 /// The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.
 /// As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
 /// The SPS is also a particle system. It provides some methods to manage the particles.
 /// However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
 /// Full documentation here : http://doc.babylonjs.com/overviews/Solid_Particle_System
 @JS("BABYLON.SolidParticleSystem" ) class SolidParticleSystem implements IDisposable { // @Ignore
 SolidParticleSystem .fakeConstructor$() ;
 /// The SPS array of Solid Particle objects. Just access each particle as with any classic array.
 /// Example : var p = SPS.particles[i];
 external List<SolidParticle> get particles; external set particles(List<SolidParticle> v);
 /// The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.
 external num get nbParticles; external set nbParticles(num v);
 /// If the particles must ever face the camera (default false). Useful for planar particles.
 external bool get billboard; external set billboard(bool v);
 /// Recompute normals when adding a shape
 external bool get recomputeNormals; external set recomputeNormals(bool v);
 /// This a counter ofr your own usage. It's not set by any SPS functions.
 external num get counter; external set counter(num v);
 /// The SPS name. This name is also given to the underlying mesh.
 external String get name; external set name(String v);
 /// The SPS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.
 external Mesh get mesh; external set mesh(Mesh v);
 /// This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.
 /// Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#garbage-collector-concerns
 external dynamic get vars; external set vars(dynamic v);
 /// This array is populated when the SPS is set as 'pickable'.
 /// Each key of this array is a `faceId` value that you can get from a pickResult object.
 /// Each element of this array is an object `{idx: int, faceId: int}`.
 /// `idx` is the picked particle index in the `SPS.particles` array
 /// `faceId` is the picked face index counted within this particle.
 /// Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#pickable-particles
 external List<dynamic/*{
            idx: number;
            faceId: number;
        }*/> get pickedParticles; external set pickedParticles(List<dynamic/*{
            idx: number;
            faceId: number;
        }*/> v);
 /// This array is populated when `enableDepthSort` is set to true.
 /// Each element of this array is an instance of the class DepthSortedParticle.
 external List<DepthSortedParticle> get depthSortedParticles; external set depthSortedParticles(List<DepthSortedParticle> v);
 /// If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)
 external bool get JS$_bSphereOnly; external set JS$_bSphereOnly(bool v);
 /// A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)
 external num get JS$_bSphereRadiusFactor; external set JS$_bSphereRadiusFactor(num v); external get JS$_scene; external set JS$_scene(v); external get JS$_positions; external set JS$_positions(v); external get JS$_indices; external set JS$_indices(v); external get JS$_normals; external set JS$_normals(v); external get JS$_colors; external set JS$_colors(v); external get JS$_uvs; external set JS$_uvs(v); external get JS$_indices32; external set JS$_indices32(v); external get JS$_positions32; external set JS$_positions32(v); external get JS$_normals32; external set JS$_normals32(v); external get JS$_fixedNormal32; external set JS$_fixedNormal32(v); external get JS$_colors32; external set JS$_colors32(v); external get JS$_uvs32; external set JS$_uvs32(v); external get JS$_index; external set JS$_index(v); external get JS$_updatable; external set JS$_updatable(v); external get JS$_pickable; external set JS$_pickable(v); external get JS$_isVisibilityBoxLocked; external set JS$_isVisibilityBoxLocked(v); external get JS$_alwaysVisible; external set JS$_alwaysVisible(v); external get JS$_depthSort; external set JS$_depthSort(v); external get JS$_shapeCounter; external set JS$_shapeCounter(v); external get JS$_copy; external set JS$_copy(v); external get JS$_shape; external set JS$_shape(v); external get JS$_shapeUV; external set JS$_shapeUV(v); external get JS$_color; external set JS$_color(v); external get JS$_computeParticleColor; external set JS$_computeParticleColor(v); external get JS$_computeParticleTexture; external set JS$_computeParticleTexture(v); external get JS$_computeParticleRotation; external set JS$_computeParticleRotation(v); external get JS$_computeParticleVertex; external set JS$_computeParticleVertex(v); external get JS$_computeBoundingBox; external set JS$_computeBoundingBox(v); external get JS$_depthSortParticles; external set JS$_depthSortParticles(v); external get JS$_cam_axisZ; external set JS$_cam_axisZ(v); external get JS$_cam_axisY; external set JS$_cam_axisY(v); external get JS$_cam_axisX; external set JS$_cam_axisX(v); external get JS$_axisZ; external set JS$_axisZ(v); external get JS$_camera; external set JS$_camera(v); external get JS$_particle; external set JS$_particle(v); external get JS$_camDir; external set JS$_camDir(v); external get JS$_camInvertedPosition; external set JS$_camInvertedPosition(v); external get JS$_rotMatrix; external set JS$_rotMatrix(v); external get JS$_invertMatrix; external set JS$_invertMatrix(v); external get JS$_rotated; external set JS$_rotated(v); external get JS$_quaternion; external set JS$_quaternion(v); external get JS$_vertex; external set JS$_vertex(v); external get JS$_normal; external set JS$_normal(v); external get JS$_yaw; external set JS$_yaw(v); external get JS$_pitch; external set JS$_pitch(v); external get JS$_roll; external set JS$_roll(v); external get JS$_halfroll; external set JS$_halfroll(v); external get JS$_halfpitch; external set JS$_halfpitch(v); external get JS$_halfyaw; external set JS$_halfyaw(v); external get JS$_sinRoll; external set JS$_sinRoll(v); external get JS$_cosRoll; external set JS$_cosRoll(v); external get JS$_sinPitch; external set JS$_sinPitch(v); external get JS$_cosPitch; external set JS$_cosPitch(v); external get JS$_sinYaw; external set JS$_sinYaw(v); external get JS$_cosYaw; external set JS$_cosYaw(v); external get JS$_mustUnrotateFixedNormals; external set JS$_mustUnrotateFixedNormals(v); external get JS$_minimum; external set JS$_minimum(v); external get JS$_maximum; external set JS$_maximum(v); external get JS$_minBbox; external set JS$_minBbox(v); external get JS$_maxBbox; external set JS$_maxBbox(v); external get JS$_particlesIntersect; external set JS$_particlesIntersect(v); external get JS$_depthSortFunction; external set JS$_depthSortFunction(v); external get JS$_needs32Bits; external set JS$_needs32Bits(v); external get JS$_pivotBackTranslation; external set JS$_pivotBackTranslation(v); external get JS$_scaledPivot; external set JS$_scaledPivot(v); external get JS$_particleHasParent; external set JS$_particleHasParent(v); external get JS$_parent; external set JS$_parent(v);
 /// Creates a SPS (Solid Particle System) object.
 /// @example bSphereRadiusFactor = 1.0 / Math.sqrt(3.0) => the bounding sphere exactly matches a spherical mesh.
 external factory SolidParticleSystem(String name, Scene scene, [dynamic/*{
            updatable?: boolean;
            isPickable?: boolean;
            enableDepthSort?: boolean;
            particleIntersection?: boolean;
            boundingSphereOnly?: boolean;
            bSphereRadiusFactor?: number;
        }*/ options]);
 /// Builds the SPS underlying mesh. Returns a standard Mesh.
 /// If no model shape was added to the SPS, the returned mesh is just a single triangular plane.
 external Mesh buildMesh();
 /// Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.
 /// These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.
 /// Thus the particles generated from `digest()` have their property `position` set yet.
 /// {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets
 /// {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets
 external SolidParticleSystem digest(Mesh mesh, [dynamic/*{
            facetNb?: number;
            number?: number;
            delta?: number;
        }*/ options]); external JS$_unrotateFixedNormals(); external JS$_resetCopy(); external JS$_meshBuilder(p, shape, positions, meshInd, indices, meshUV, uvs, meshCol, colors, meshNor, normals, idx, idxInShape, options); external JS$_posToShape(positions); external JS$_uvsToShapeUV(uvs); external JS$_addParticle(idx, idxpos, idxind, model, shapeId, idxInShape, [bInfo]);
 /// Adds some particles to the SPS from the model shape. Returns the shape id.
 /// Please read the doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#create-an-immutable-sps
 /// {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation
 external num addShape(Mesh mesh, num nb, [dynamic/*{
            positionFunction?: any;
            vertexFunction?: any;
        }*/ options]); external JS$_rebuildParticle(particle);
 /// Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.
 external SolidParticleSystem rebuildMesh();
 /// Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.
 /// This method calls `updateParticle()` for each particle of the SPS.
 /// For an animated SPS, it is usually called within the render loop.
 external SolidParticleSystem setParticles([num start, num end, bool update]); external JS$_quaternionRotationYPR(); external JS$_quaternionToRotationMatrix();
 /// Disposes the SPS.
 external void dispose();
 /// Visibilty helper : Recomputes the visible size according to the mesh bounding box
 /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
 external SolidParticleSystem refreshVisibleSize();
 /// Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.
 /// note : this doesn't lock the SPS mesh bounding box.
 /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
 external void setVisibilityBox(num size);
 /// Gets whether the SPS as always visible or not
 /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
 /// Sets the SPS as always visible or not
 /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
 external bool get isAlwaysVisible; external set isAlwaysVisible(bool v);
 /// Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
 /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
 /// Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
 /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
 external bool get isVisibilityBoxLocked; external set isVisibilityBoxLocked(bool v);
 /// Gets if `setParticles()` computes the particle rotations or not.
 /// Default value : true. The SPS is faster when it's set to false.
 /// Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
 /// Tells to `setParticles()` to compute the particle rotations or not.
 /// Default value : true. The SPS is faster when it's set to false.
 /// Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
 external bool get computeParticleRotation; external set computeParticleRotation(bool v);
 /// Gets if `setParticles()` computes the particle colors or not.
 /// Default value : true. The SPS is faster when it's set to false.
 /// Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
 /// Tells to `setParticles()` to compute the particle colors or not.
 /// Default value : true. The SPS is faster when it's set to false.
 /// Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
 external bool get computeParticleColor; external set computeParticleColor(bool v);
 /// Gets if `setParticles()` computes the particle textures or not.
 /// Default value : true. The SPS is faster when it's set to false.
 /// Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.
 external bool get computeParticleTexture; external set computeParticleTexture(bool v);
 /// Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.
 /// Default value : false. The SPS is faster when it's set to false.
 /// Note : the particle custom vertex positions aren't stored values.
 /// Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.
 /// Default value : false. The SPS is faster when it's set to false.
 /// Note : the particle custom vertex positions aren't stored values.
 external bool get computeParticleVertex; external set computeParticleVertex(bool v);
 /// Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.
 /// Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.
 external bool get computeBoundingBox; external set computeBoundingBox(bool v);
 /// Gets if `setParticles()` sorts or not the distance between each particle and the camera.
 /// Skipped when `enableDepthSort` is set to `false` (default) at construction time.
 /// Default : `true`
 /// Tells to `setParticles()` to sort or not the distance between each particle and the camera.
 /// Skipped when `enableDepthSort` is set to `false` (default) at construction time.
 /// Default : `true`
 external bool get depthSortParticles; external set depthSortParticles(bool v);
 /// This function does nothing. It may be overwritten to set all the particle first values.
 /// The SPS doesn't call this function, you may have to call it by your own.
 /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
 external void initParticles();
 /// This function does nothing. It may be overwritten to recycle a particle.
 /// The SPS doesn't call this function, you may have to call it by your own.
 /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
 external SolidParticle recycleParticle(SolidParticle particle);
 /// Updates a particle : this function should  be overwritten by the user.
 /// It is called on each particle by `setParticles()`. This is the place to code each particle behavior.
 /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
 /// @example : just set a particle position or velocity and recycle conditions
 external SolidParticle updateParticle(SolidParticle particle);
 /// Updates a vertex of a particle : it can be overwritten by the user.
 /// This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.
 /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#update-each-particle-shape
 /// @example : just set a vertex particle position
 external Vector3 updateParticleVertex(SolidParticle particle, Vector3 vertex, num pt);
 /// This will be called before any other treatment by `setParticles()` and will be passed three parameters.
 /// This does nothing and may be overwritten by the user.
 external void beforeUpdateParticles([num start, num stop, bool update]);
 /// This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.
 /// This will be passed three parameters.
 /// This does nothing and may be overwritten by the user.
 external void afterUpdateParticles([num start, num stop, bool update]); }

 @anonymous @JS() abstract class PhysicsImpostorJoint { external PhysicsImpostor get mainImpostor; external set mainImpostor(PhysicsImpostor v); external PhysicsImpostor get connectedImpostor; external set connectedImpostor(PhysicsImpostor v); external PhysicsJoint get joint; external set joint(PhysicsJoint v); external factory PhysicsImpostorJoint({ PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint}); }

 @JS("BABYLON.PhysicsEngine" ) class PhysicsEngine { // @Ignore
 PhysicsEngine .fakeConstructor$() ;
 external get JS$_physicsPlugin; external set JS$_physicsPlugin(v); external Vector3 get gravity; external set gravity(Vector3 v); external factory PhysicsEngine(Vector3/*Vector3|Null*/ gravity, [IPhysicsEnginePlugin JS$_physicsPlugin]); external void setGravity(Vector3 gravity);
 /// Set the time step of the physics engine.
 /// default is 1/60.
 /// To slow it down, enter 1/600 for example.
 /// To speed it up, 1/30
 external void setTimeStep([num newTimeStep]);
 /// Get the time step of the physics engine.
 external num getTimeStep(); external void dispose(); external String getPhysicsPluginName(); external static num get Epsilon; external static set Epsilon(num v); external get JS$_impostors; external set JS$_impostors(v); external get JS$_joints; external set JS$_joints(v);
 /// Adding a new impostor for the impostor tracking.
 /// This will be done by the impostor itself.
 external void addImpostor(PhysicsImpostor impostor);
 /// Remove an impostor from the engine.
 /// This impostor and its mesh will not longer be updated by the physics engine.
 external void removeImpostor(PhysicsImpostor impostor);
 /// Add a joint to the physics engine
 external void addJoint(PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint); external void removeJoint(PhysicsImpostor mainImpostor, PhysicsImpostor connectedImpostor, PhysicsJoint joint);
 /// Called by the scene. no need to call it.
 external void JS$_step(num delta); external IPhysicsEnginePlugin getPhysicsPlugin(); external List<PhysicsImpostor> getImpostors(); external PhysicsImpostor/*PhysicsImpostor|Null*/ getImpostorForPhysicsObject(IPhysicsEnabledObject object); external PhysicsImpostor/*PhysicsImpostor|Null*/ getImpostorWithPhysicsBody(dynamic body); }

 @anonymous @JS() abstract class IPhysicsEnginePlugin { external dynamic get world; external set world(dynamic v); external String get name; external set name(String v); external void setGravity(Vector3 gravity); external void setTimeStep(num timeStep); external num getTimeStep(); external void executeStep(num delta, List<PhysicsImpostor> impostors); external void applyImpulse(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint); external void applyForce(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint); external void generatePhysicsBody(PhysicsImpostor impostor); external void removePhysicsBody(PhysicsImpostor impostor); external void generateJoint(PhysicsImpostorJoint joint); external void removeJoint(PhysicsImpostorJoint joint); external bool isSupported(); external void setTransformationFromPhysicsBody(PhysicsImpostor impostor); external void setPhysicsBodyTransformation(PhysicsImpostor impostor, Vector3 newPosition, Quaternion newRotation); external void setLinearVelocity(PhysicsImpostor impostor, Vector3/*Vector3|Null*/ velocity); external void setAngularVelocity(PhysicsImpostor impostor, Vector3/*Vector3|Null*/ velocity); external Vector3/*Vector3|Null*/ getLinearVelocity(PhysicsImpostor impostor); external Vector3/*Vector3|Null*/ getAngularVelocity(PhysicsImpostor impostor); external void setBodyMass(PhysicsImpostor impostor, num mass); external num getBodyMass(PhysicsImpostor impostor); external num getBodyFriction(PhysicsImpostor impostor); external void setBodyFriction(PhysicsImpostor impostor, num friction); external num getBodyRestitution(PhysicsImpostor impostor); external void setBodyRestitution(PhysicsImpostor impostor, num restitution); external void sleepBody(PhysicsImpostor impostor); external void wakeUpBody(PhysicsImpostor impostor); external void updateDistanceJoint(PhysicsJoint joint, num maxDistance, [num minDistance]); external void setMotor(IMotorEnabledJoint joint, num speed, [num maxForce, num motorIndex]); external void setLimit(IMotorEnabledJoint joint, num upperLimit, [num lowerLimit, num motorIndex]); external num getRadius(PhysicsImpostor impostor); external void getBoxSizeToRef(PhysicsImpostor impostor, Vector3 result); external void syncMeshWithImpostor(AbstractMesh mesh, PhysicsImpostor impostor); external void dispose(); }

 @JS("BABYLON.PhysicsHelper" ) class PhysicsHelper { // @Ignore
 PhysicsHelper .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_physicsEngine; external set JS$_physicsEngine(v); external factory PhysicsHelper(Scene scene);
 external PhysicsRadialExplosionEvent/*PhysicsRadialExplosionEvent|Null*/ applyRadialExplosionImpulse(Vector3 origin, num radius, num strength, [num/*enum PhysicsRadialImpulseFalloff*/ falloff]);
 external PhysicsRadialExplosionEvent/*PhysicsRadialExplosionEvent|Null*/ applyRadialExplosionForce(Vector3 origin, num radius, num strength, [num/*enum PhysicsRadialImpulseFalloff*/ falloff]);
 external PhysicsGravitationalFieldEvent/*PhysicsGravitationalFieldEvent|Null*/ gravitationalField(Vector3 origin, num radius, num strength, [num/*enum PhysicsRadialImpulseFalloff*/ falloff]);
 external PhysicsUpdraftEvent/*PhysicsUpdraftEvent|Null*/ updraft(Vector3 origin, num radius, num strength, num height, [num/*enum PhysicsUpdraftMode*/ updraftMode]);
 external PhysicsVortexEvent/*PhysicsVortexEvent|Null*/ vortex(Vector3 origin, num radius, num strength, num height); }

 /// ** Radial explosion ****
 @JS("BABYLON.PhysicsRadialExplosionEvent" ) class PhysicsRadialExplosionEvent { // @Ignore
 PhysicsRadialExplosionEvent .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_sphere; external set JS$_sphere(v); external get JS$_sphereOptions; external set JS$_sphereOptions(v); external get JS$_rays; external set JS$_rays(v); external get JS$_dataFetched; external set JS$_dataFetched(v); external factory PhysicsRadialExplosionEvent(Scene scene);
 /// Returns the data related to the radial explosion event (sphere & rays).
 external PhysicsRadialExplosionEventData getData();
 /// Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.
 external PhysicsForceAndContactPoint/*PhysicsForceAndContactPoint|Null*/ getImpostorForceAndContactPoint(PhysicsImpostor impostor, Vector3 origin, num radius, num strength, num/*enum PhysicsRadialImpulseFalloff*/ falloff);
 /// Disposes the sphere.
 external void dispose([bool force]);
 /// Helpers **
 external JS$_prepareSphere(); external JS$_intersectsWithSphere(impostor, origin, radius); }

 /// ** Gravitational Field ****
 @JS("BABYLON.PhysicsGravitationalFieldEvent" ) class PhysicsGravitationalFieldEvent { // @Ignore
 PhysicsGravitationalFieldEvent .fakeConstructor$() ;
 external get JS$_physicsHelper; external set JS$_physicsHelper(v); external get JS$_scene; external set JS$_scene(v); external get JS$_origin; external set JS$_origin(v); external get JS$_radius; external set JS$_radius(v); external get JS$_strength; external set JS$_strength(v); external get JS$_falloff; external set JS$_falloff(v); external get JS$_tickCallback; external set JS$_tickCallback(v); external get JS$_sphere; external set JS$_sphere(v); external get JS$_dataFetched; external set JS$_dataFetched(v); external factory PhysicsGravitationalFieldEvent(PhysicsHelper physicsHelper, Scene scene, Vector3 origin, num radius, num strength, [num/*enum PhysicsRadialImpulseFalloff*/ falloff]);
 /// Returns the data related to the gravitational field event (sphere).
 external PhysicsGravitationalFieldEventData getData();
 /// Enables the gravitational field.
 external void enable();
 /// Disables the gravitational field.
 external void disable();
 /// Disposes the sphere.
 external void dispose([bool force]); external JS$_tick(); }

 /// ** Updraft ****
 @JS("BABYLON.PhysicsUpdraftEvent" ) class PhysicsUpdraftEvent { // @Ignore
 PhysicsUpdraftEvent .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_origin; external set JS$_origin(v); external get JS$_radius; external set JS$_radius(v); external get JS$_strength; external set JS$_strength(v); external get JS$_height; external set JS$_height(v); external get JS$_updraftMode; external set JS$_updraftMode(v); external get JS$_physicsEngine; external set JS$_physicsEngine(v); external get JS$_originTop; external set JS$_originTop(v); external get JS$_originDirection; external set JS$_originDirection(v); external get JS$_tickCallback; external set JS$_tickCallback(v); external get JS$_cylinder; external set JS$_cylinder(v); external get JS$_cylinderPosition; external set JS$_cylinderPosition(v); external get JS$_dataFetched; external set JS$_dataFetched(v); external factory PhysicsUpdraftEvent(Scene JS$_scene, Vector3 JS$_origin, num JS$_radius, num JS$_strength, num JS$_height, num/*enum PhysicsUpdraftMode*/ JS$_updraftMode);
 /// Returns the data related to the updraft event (cylinder).
 external PhysicsUpdraftEventData getData();
 /// Enables the updraft.
 external void enable();
 /// Disables the cortex.
 external void disable();
 /// Disposes the sphere.
 external void dispose([bool force]); external getImpostorForceAndContactPoint(impostor); external JS$_tick();
 /// Helpers **
 external JS$_prepareCylinder(); external JS$_intersectsWithCylinder(impostor); }

 /// ** Vortex ****
 @JS("BABYLON.PhysicsVortexEvent" ) class PhysicsVortexEvent { // @Ignore
 PhysicsVortexEvent .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_origin; external set JS$_origin(v); external get JS$_radius; external set JS$_radius(v); external get JS$_strength; external set JS$_strength(v); external get JS$_height; external set JS$_height(v); external get JS$_physicsEngine; external set JS$_physicsEngine(v); external get JS$_originTop; external set JS$_originTop(v); external get JS$_centripetalForceThreshold; external set JS$_centripetalForceThreshold(v); external get JS$_updraftMultiplier; external set JS$_updraftMultiplier(v); external get JS$_tickCallback; external set JS$_tickCallback(v); external get JS$_cylinder; external set JS$_cylinder(v); external get JS$_cylinderPosition; external set JS$_cylinderPosition(v); external get JS$_dataFetched; external set JS$_dataFetched(v); external factory PhysicsVortexEvent(Scene JS$_scene, Vector3 JS$_origin, num JS$_radius, num JS$_strength, num JS$_height);
 /// Returns the data related to the vortex event (cylinder).
 external PhysicsVortexEventData getData();
 /// Enables the vortex.
 external void enable();
 /// Disables the cortex.
 external void disable();
 /// Disposes the sphere.
 external void dispose([bool force]); external getImpostorForceAndContactPoint(impostor); external JS$_tick();
 /// Helpers **
 external JS$_prepareCylinder(); external JS$_intersectsWithCylinder(impostor); }

 /// ** Enums ****
 /// The strenght of the force in correspondence to the distance of the affected object
 @JS("BABYLON.PhysicsRadialImpulseFalloff" ) class PhysicsRadialImpulseFalloff { external static num get
 /// Defines that impulse is constant in strength across it's whole radius
 Constant; external static num get
 /// DEfines that impulse gets weaker if it's further from the origin
 Linear; }
 /// The strenght of the force in correspondence to the distance of the affected object
 @JS("BABYLON.PhysicsUpdraftMode" ) class PhysicsUpdraftMode { external static num get
 /// Defines that the upstream forces will pull towards the top center of the cylinder
 Center; external static num get
 /// Defines that once a impostor is inside the cylinder, it will shoot out perpendicular from the ground of the cylinder
 Perpendicular; }
 /// ** Data interfaces ****
 @anonymous @JS() abstract class PhysicsForceAndContactPoint { external Vector3 get force; external set force(Vector3 v); external Vector3 get contactPoint; external set contactPoint(Vector3 v); external factory PhysicsForceAndContactPoint({ Vector3 force, Vector3 contactPoint}); }

 @anonymous @JS() abstract class PhysicsRadialExplosionEventData { external Mesh get sphere; external set sphere(Mesh v); external List<Ray> get rays; external set rays(List<Ray> v); external factory PhysicsRadialExplosionEventData({ Mesh sphere, List<Ray> rays}); }

 @anonymous @JS() abstract class PhysicsGravitationalFieldEventData { external Mesh get sphere; external set sphere(Mesh v); external factory PhysicsGravitationalFieldEventData({ Mesh sphere}); }

 @anonymous @JS() abstract class PhysicsUpdraftEventData { external Mesh get cylinder; external set cylinder(Mesh v); external factory PhysicsUpdraftEventData({ Mesh cylinder}); }

 @anonymous @JS() abstract class PhysicsVortexEventData { external Mesh get cylinder; external set cylinder(Mesh v); external factory PhysicsVortexEventData({ Mesh cylinder}); }

 @anonymous @JS() abstract class PhysicsImpostorParameters { external num get mass; external set mass(num v); external num get friction; external set friction(num v); external num get restitution; external set restitution(num v); external dynamic get nativeOptions; external set nativeOptions(dynamic v); external bool get ignoreParent; external set ignoreParent(bool v); external bool get disableBidirectionalTransformation; external set disableBidirectionalTransformation(bool v); external factory PhysicsImpostorParameters({ num mass, num friction, num restitution, dynamic nativeOptions, bool ignoreParent, bool disableBidirectionalTransformation}); }

 @anonymous @JS() abstract class IPhysicsEnabledObject { external Vector3 get position; external set position(Vector3 v); external Quaternion/*Quaternion|Null*/ get rotationQuaternion; external set rotationQuaternion(Quaternion/*Quaternion|Null*/ v); external Vector3 get scaling; external set scaling(Vector3 v); external Vector3 get rotation; external set rotation(Vector3 v); external dynamic get parent; external set parent(dynamic v); external BoundingInfo getBoundingInfo(); external Matrix computeWorldMatrix(bool force); external Matrix getWorldMatrix(); external List<AbstractMesh> getChildMeshes([bool directDescendantsOnly]); external dynamic/*List<num>|Float32List|Null*/ getVerticesData(String kind); external dynamic/*List<num>|Int32List|Uint32List|Uint16List|Null*/ getIndices(); external Scene getScene(); external Vector3 getAbsolutePosition(); external Vector3 getAbsolutePivotPoint(); external TransformNode rotate(Vector3 axis, num amount, [num/*enum Space*/ space]); external TransformNode translate(Vector3 axis, num distance, [num/*enum Space*/ space]); external TransformNode setAbsolutePosition(Vector3 absolutePosition); external String getClassName(); }

 @JS("BABYLON.PhysicsImpostor" ) class PhysicsImpostor { // @Ignore
 PhysicsImpostor .fakeConstructor$() ;
 external IPhysicsEnabledObject get object; external set object(IPhysicsEnabledObject v); external num get type; external set type(num v); external get JS$_options; external set JS$_options(v); external get JS$_scene; external set JS$_scene(v); external static Vector3 get DEFAULT_OBJECT_SIZE; external static set DEFAULT_OBJECT_SIZE(Vector3 v); external static Quaternion get IDENTITY_QUATERNION; external static set IDENTITY_QUATERNION(Quaternion v); external get JS$_physicsEngine; external set JS$_physicsEngine(v); external get JS$_physicsBody; external set JS$_physicsBody(v); external get JS$_bodyUpdateRequired; external set JS$_bodyUpdateRequired(v); external get JS$_onBeforePhysicsStepCallbacks; external set JS$_onBeforePhysicsStepCallbacks(v); external get JS$_onAfterPhysicsStepCallbacks; external set JS$_onAfterPhysicsStepCallbacks(v); external get JS$_onPhysicsCollideCallbacks; external set JS$_onPhysicsCollideCallbacks(v); external get JS$_deltaPosition; external set JS$_deltaPosition(v); external get JS$_deltaRotation; external set JS$_deltaRotation(v); external get JS$_deltaRotationConjugated; external set JS$_deltaRotationConjugated(v); external get JS$_parent; external set JS$_parent(v); external get JS$_isDisposed; external set JS$_isDisposed(v); external static get JS$_tmpVecs; external static set JS$_tmpVecs(v); external static get JS$_tmpQuat; external static set JS$_tmpQuat(v); external bool get isDisposed; external set isDisposed(bool v); external num get mass; external set mass(num v); external num get friction; external set friction(num v); external num get restitution; external set restitution(num v); external num get uniqueId; external set uniqueId(num v); external get JS$_joints; external set JS$_joints(v); external factory PhysicsImpostor(IPhysicsEnabledObject object, num type, [PhysicsImpostorParameters JS$_options, dynamic/*Scene|dynamic*/ JS$_scene]);
 /// This function will completly initialize this impostor.
 /// It will create a new body - but only if this mesh has no parent.
 /// If it has, this impostor will not be used other than to define the impostor
 /// of the child mesh.
 external void JS$_init(); external JS$_getPhysicsParent();
 /// Should a new body be generated.
 external bool isBodyInitRequired(); external void setScalingUpdated(bool updated);
 /// Force a regeneration of this or the parent's impostor's body.
 /// Use under cautious - This will remove all joints already implemented.
 external void forceUpdate();
 /// Gets the body that holds this impostor. Either its own, or its parent.
 /// Set the physics body. Used mainly by the physics engine/plugin
 external dynamic get physicsBody; external set physicsBody(dynamic v); external PhysicsImpostor/*PhysicsImpostor|Null*/ get parent; external set parent(PhysicsImpostor/*PhysicsImpostor|Null*/ v); external void resetUpdateFlags(); external Vector3 getObjectExtendSize(); external Vector3 getObjectCenter();
 /// Get a specific parametes from the options parameter.
 external dynamic getParam(String paramName);
 /// Sets a specific parameter in the options given to the physics plugin
 external void setParam(String paramName, num value);
 /// Specifically change the body's mass option. Won't recreate the physics body object
 external void setMass(num mass); external Vector3/*Vector3|Null*/ getLinearVelocity(); external void setLinearVelocity(Vector3/*Vector3|Null*/ velocity); external Vector3/*Vector3|Null*/ getAngularVelocity(); external void setAngularVelocity(Vector3/*Vector3|Null*/ velocity);
 /// Execute a function with the physics plugin native code.
 /// Provide a function the will have two variables - the world object and the physics body object.
 external void executeNativeFunction(void func(dynamic world, dynamic physicsBody));
 /// Register a function that will be executed before the physics world is stepping forward.
 external void registerBeforePhysicsStep(void func(PhysicsImpostor impostor)); external void unregisterBeforePhysicsStep(void func(PhysicsImpostor impostor));
 /// Register a function that will be executed after the physics step
 external void registerAfterPhysicsStep(void func(PhysicsImpostor impostor)); external void unregisterAfterPhysicsStep(void func(PhysicsImpostor impostor));
 /// register a function that will be executed when this impostor collides against a different body.
 external void registerOnPhysicsCollide(dynamic/*PhysicsImpostor|List<PhysicsImpostor>*/ collideAgainst, void func(PhysicsImpostor collider, PhysicsImpostor collidedAgainst)); external void unregisterOnPhysicsCollide(dynamic/*PhysicsImpostor|List<PhysicsImpostor>*/ collideAgainst, void func(PhysicsImpostor collider, dynamic/*PhysicsImpostor|List<PhysicsImpostor>*/ collidedAgainst)); external get JS$_tmpQuat; external set JS$_tmpQuat(v); external get JS$_tmpQuat2; external set JS$_tmpQuat2(v); external Quaternion getParentsRotation();
 /// this function is executed by the physics engine.
 external VoidFunc0 get beforeStep; external set beforeStep(VoidFunc0 v);
 /// this function is executed by the physics engine.
 external VoidFunc0 get afterStep; external set afterStep(VoidFunc0 v);
 /// Legacy collision detection event support
 external VoidFunc2<PhysicsImpostor, PhysicsImpostor>/*VoidFunc2<PhysicsImpostor, PhysicsImpostor>|Null*/ get onCollideEvent; external set onCollideEvent(VoidFunc2<PhysicsImpostor, PhysicsImpostor>/*VoidFunc2<PhysicsImpostor, PhysicsImpostor>|Null*/ v); external VoidFunc1<dynamic/*{
            body: any;
        }*/> get onCollide; external set onCollide(VoidFunc1<dynamic/*{
            body: any;
        }*/> v);
 /// Apply a force
 external PhysicsImpostor applyForce(Vector3 force, Vector3 contactPoint);
 /// Apply an impulse
 external PhysicsImpostor applyImpulse(Vector3 force, Vector3 contactPoint);
 /// A help function to create a joint.
 external PhysicsImpostor createJoint(PhysicsImpostor otherImpostor, num jointType, PhysicsJointData jointData);
 /// Add a joint to this impostor with a different impostor.
 external PhysicsImpostor addJoint(PhysicsImpostor otherImpostor, PhysicsJoint joint);
 /// Will keep this body still, in a sleep mode.
 external PhysicsImpostor sleep();
 /// Wake the body up.
 external PhysicsImpostor wakeUp(); external PhysicsImpostor/*PhysicsImpostor|Null*/ clone(IPhysicsEnabledObject newObject); external void dispose(); external void setDeltaPosition(Vector3 position); external void setDeltaRotation(Quaternion rotation); external PhysicsImpostor getBoxSizeToRef(Vector3 result); external num getRadius();
 /// Sync a bone with this impostor
 external void syncBoneWithImpostor(Bone bone, AbstractMesh boneMesh, Vector3 jointPivot, [num distToJoint, Quaternion adjustRotation]);
 /// Sync impostor to a bone
 external void syncImpostorWithBone(Bone bone, AbstractMesh boneMesh, Vector3 jointPivot, [num distToJoint, Quaternion adjustRotation, Vector3 boneAxis]); external static num get NoImpostor; external static set NoImpostor(num v); external static num get SphereImpostor; external static set SphereImpostor(num v); external static num get BoxImpostor; external static set BoxImpostor(num v); external static num get PlaneImpostor; external static set PlaneImpostor(num v); external static num get MeshImpostor; external static set MeshImpostor(num v); external static num get CylinderImpostor; external static set CylinderImpostor(num v); external static num get ParticleImpostor; external static set ParticleImpostor(num v); external static num get HeightmapImpostor; external static set HeightmapImpostor(num v); }

 @anonymous @JS() abstract class PhysicsJointData { external Vector3 get mainPivot; external set mainPivot(Vector3 v); external Vector3 get connectedPivot; external set connectedPivot(Vector3 v); external Vector3 get mainAxis; external set mainAxis(Vector3 v); external Vector3 get connectedAxis; external set connectedAxis(Vector3 v); external bool get collision; external set collision(bool v); external dynamic get nativeParams; external set nativeParams(dynamic v); external factory PhysicsJointData({ Vector3 mainPivot, Vector3 connectedPivot, Vector3 mainAxis, Vector3 connectedAxis, bool collision, dynamic nativeParams}); }

 /// This is a holder class for the physics joint created by the physics plugin.
 /// It holds a set of functions to control the underlying joint.
 @JS("BABYLON.PhysicsJoint" ) class PhysicsJoint { // @Ignore
 PhysicsJoint .fakeConstructor$() ;
 external num get type; external set type(num v); external PhysicsJointData get jointData; external set jointData(PhysicsJointData v); external get JS$_physicsJoint; external set JS$_physicsJoint(v); external IPhysicsEnginePlugin get JS$_physicsPlugin; external set JS$_physicsPlugin(IPhysicsEnginePlugin v); external factory PhysicsJoint(num type, PhysicsJointData jointData); external dynamic get physicsJoint; external set physicsJoint(dynamic v); external IPhysicsEnginePlugin get physicsPlugin; external set physicsPlugin(IPhysicsEnginePlugin v);
 /// Execute a function that is physics-plugin specific.
 /// It accepts two parameters: the physics world and the physics joint.
 external void executeNativeFunction(void func(dynamic world, dynamic physicsJoint)); external static num get DistanceJoint; external static set DistanceJoint(num v); external static num get HingeJoint; external static set HingeJoint(num v); external static num get BallAndSocketJoint; external static set BallAndSocketJoint(num v); external static num get WheelJoint; external static set WheelJoint(num v); external static num get SliderJoint; external static set SliderJoint(num v); external static num get PrismaticJoint; external static set PrismaticJoint(num v); external static num get UniversalJoint; external static set UniversalJoint(num v); external static num get Hinge2Joint; external static set Hinge2Joint(num v); external static num get PointToPointJoint; external static set PointToPointJoint(num v); external static num get SpringJoint; external static set SpringJoint(num v); external static num get LockJoint; external static set LockJoint(num v); }

 /// A class representing a physics distance joint.
 @JS("BABYLON.DistanceJoint" ) class DistanceJoint extends PhysicsJoint { // @Ignore
 DistanceJoint .fakeConstructor$() : super.fakeConstructor$() ;
 external factory DistanceJoint(DistanceJointData jointData);
 /// Update the predefined distance.
 external void updateDistance(num maxDistance, [num minDistance]); }

 @JS("BABYLON.MotorEnabledJoint" ) class MotorEnabledJoint extends PhysicsJoint implements IMotorEnabledJoint { // @Ignore
 MotorEnabledJoint .fakeConstructor$() : super.fakeConstructor$() ;
 external factory MotorEnabledJoint(num type, PhysicsJointData jointData);
 /// Set the motor values.
 /// Attention, this function is plugin specific. Engines won't react 100% the same.
 external void setMotor([num force, num maxForce]);
 /// Set the motor's limits.
 /// Attention, this function is plugin specific. Engines won't react 100% the same.
 external void setLimit(num upperLimit, [num lowerLimit]); }

 /// This class represents a single hinge physics joint
 @JS("BABYLON.HingeJoint" ) class HingeJoint extends MotorEnabledJoint { // @Ignore
 HingeJoint .fakeConstructor$() : super.fakeConstructor$() ;
 external factory HingeJoint(PhysicsJointData jointData);
 /// Set the motor values.
 /// Attention, this function is plugin specific. Engines won't react 100% the same.
 external void setMotor([num force, num maxForce]);
 /// Set the motor's limits.
 /// Attention, this function is plugin specific. Engines won't react 100% the same.
 external void setLimit(num upperLimit, [num lowerLimit]); }

 /// This class represents a dual hinge physics joint (same as wheel joint)
 @JS("BABYLON.Hinge2Joint" ) class Hinge2Joint extends MotorEnabledJoint { // @Ignore
 Hinge2Joint .fakeConstructor$() : super.fakeConstructor$() ;
 external factory Hinge2Joint(PhysicsJointData jointData);
 /// Set the motor values.
 /// Attention, this function is plugin specific. Engines won't react 100% the same.
 external void setMotor([num force, num maxForce, num motorIndex]);
 /// Set the motor limits.
 /// Attention, this function is plugin specific. Engines won't react 100% the same.
 external void setLimit(num upperLimit, [num lowerLimit, num motorIndex]); }

 @anonymous @JS() abstract class IMotorEnabledJoint { external dynamic get physicsJoint; external set physicsJoint(dynamic v); external void setMotor([num force, num maxForce, num motorIndex]); external void setLimit(num upperLimit, [num lowerLimit, num motorIndex]); }

 @anonymous @JS() abstract class DistanceJointData implements PhysicsJointData { external num get maxDistance; external set maxDistance(num v); external factory DistanceJointData({ num maxDistance, Vector3 mainPivot, Vector3 connectedPivot, Vector3 mainAxis, Vector3 connectedAxis, bool collision, dynamic nativeParams}); }

 @anonymous @JS() abstract class SpringJointData implements PhysicsJointData { external num get length; external set length(num v); external num get stiffness; external set stiffness(num v); external num get damping; external set damping(num v); external factory SpringJointData({ num length, num stiffness, num damping, Vector3 mainPivot, Vector3 connectedPivot, Vector3 mainAxis, Vector3 connectedAxis, bool collision, dynamic nativeParams}); }

 @JS("BABYLON.ReflectionProbe" ) class ReflectionProbe { // @Ignore
 ReflectionProbe .fakeConstructor$() ;
 external String get name; external set name(String v); external get JS$_scene; external set JS$_scene(v); external get JS$_renderTargetTexture; external set JS$_renderTargetTexture(v); external get JS$_projectionMatrix; external set JS$_projectionMatrix(v); external get JS$_viewMatrix; external set JS$_viewMatrix(v); external get JS$_target; external set JS$_target(v); external get JS$_add; external set JS$_add(v); external get JS$_attachedMesh; external set JS$_attachedMesh(v); external get JS$_invertYAxis; external set JS$_invertYAxis(v); external Vector3 get position; external set position(Vector3 v); external factory ReflectionProbe(String name, num size, Scene scene, [bool generateMipMaps]); external num get samples; external set samples(num v); external num get refreshRate; external set refreshRate(num v); external Scene getScene(); external RenderTargetTexture get cubeTexture; external set cubeTexture(RenderTargetTexture v); external List<AbstractMesh>/*List<AbstractMesh>|Null*/ get renderList; external set renderList(List<AbstractMesh>/*List<AbstractMesh>|Null*/ v); external void attachToMesh(AbstractMesh mesh);
 /// Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
 external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil); external void dispose(); }

 @JS("BABYLON.BoundingBoxRenderer" ) class BoundingBoxRenderer { // @Ignore
 BoundingBoxRenderer .fakeConstructor$() ;
 external Color3 get frontColor; external set frontColor(Color3 v); external Color3 get backColor; external set backColor(Color3 v); external bool get showBackLines; external set showBackLines(bool v); external SmartArray<BoundingBox> get renderList; external set renderList(SmartArray<BoundingBox> v); external get JS$_scene; external set JS$_scene(v); external get JS$_colorShader; external set JS$_colorShader(v); external get JS$_vertexBuffers; external set JS$_vertexBuffers(v); external get JS$_indexBuffer; external set JS$_indexBuffer(v); external factory BoundingBoxRenderer(Scene scene); external JS$_prepareRessources(); external JS$_createIndexBuffer(); external void JS$_rebuild(); external void reset(); external void render(); external void renderOcclusionBoundingBox(AbstractMesh mesh); external void dispose(); }

 /// This represents a depth renderer in Babylon.
 /// A depth renderer will render to it's depth map every frame which can be displayed or used in post processing
 @JS("BABYLON.DepthRenderer" ) class DepthRenderer { // @Ignore
 DepthRenderer .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_depthMap; external set JS$_depthMap(v); external get JS$_effect; external set JS$_effect(v); external get JS$_cachedDefines; external set JS$_cachedDefines(v); external get JS$_camera; external set JS$_camera(v);
 /// Instantiates a depth renderer
 external factory DepthRenderer(Scene scene, [num type, Camera/*Camera|Null*/ camera]);
 /// Creates the depth rendering effect and checks if the effect is ready.
 external bool isReady(SubMesh subMesh, bool useInstances);
 /// Gets the texture which the depth map will be written to.
 external RenderTargetTexture getDepthMap();
 /// Disposes of the depth renderer.
 external void dispose(); }

 @JS("BABYLON.EdgesRenderer" ) class EdgesRenderer { // @Ignore
 EdgesRenderer .fakeConstructor$() ;
 external num get edgesWidthScalerForOrthographic; external set edgesWidthScalerForOrthographic(num v); external num get edgesWidthScalerForPerspective; external set edgesWidthScalerForPerspective(num v); external get JS$_source; external set JS$_source(v); external get JS$_linesPositions; external set JS$_linesPositions(v); external get JS$_linesNormals; external set JS$_linesNormals(v); external get JS$_linesIndices; external set JS$_linesIndices(v); external get JS$_epsilon; external set JS$_epsilon(v); external get JS$_indicesCount; external set JS$_indicesCount(v); external get JS$_lineShader; external set JS$_lineShader(v); external get JS$_ib; external set JS$_ib(v); external get JS$_buffers; external set JS$_buffers(v); external get JS$_checkVerticesInsteadOfIndices; external set JS$_checkVerticesInsteadOfIndices(v); external factory EdgesRenderer(AbstractMesh source, [num epsilon, bool checkVerticesInsteadOfIndices]); external JS$_prepareRessources(); external void JS$_rebuild(); external void dispose(); external JS$_processEdgeForAdjacencies(pa, pb, p0, p1, p2); external JS$_processEdgeForAdjacenciesWithVertices(pa, pb, p0, p1, p2); external JS$_checkEdge(faceIndex, edge, faceNormals, p0, p1); external void JS$_generateEdgesLines(); external void render(); }

 /// This renderer is helpfull to fill one of the render target with a geometry buffer.
 @JS("BABYLON.GeometryBufferRenderer" ) class GeometryBufferRenderer { // @Ignore
 GeometryBufferRenderer .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_multiRenderTarget; external set JS$_multiRenderTarget(v); external get JS$_ratio; external set JS$_ratio(v); external get JS$_enablePosition; external set JS$_enablePosition(v); external Effect get JS$_effect; external set JS$_effect(Effect v); external String get JS$_cachedDefines; external set JS$_cachedDefines(String v);
 /// Set the render list (meshes to be rendered) used in the G buffer.
 external List<Mesh> get renderList; external set renderList(List<Mesh> v);
 /// Gets wether or not G buffer are supported by the running hardware.
 /// This requires draw buffer supports
 external bool get isSupported; external set isSupported(bool v);
 /// Gets wether or not position are enabled for the G buffer.
 /// Sets wether or not position are enabled for the G buffer.
 external bool get enablePosition; external set enablePosition(bool v);
 /// Gets the scene associated with the buffer.
 external Scene get scene; external set scene(Scene v);
 /// Gets the ratio used by the buffer during its creation.
 /// How big is the buffer related to the main canvas.
 external num get ratio; external set ratio(num v);
 /// Creates a new G Buffer for the scene
 external factory GeometryBufferRenderer(Scene scene, [num ratio]);
 /// Checks wether everything is ready to render a submesh to the G buffer.
 external bool isReady(SubMesh subMesh, bool useInstances);
 /// Gets the current underlying G Buffer.
 external MultiRenderTarget getGBuffer();
 /// Gets the number of samples used to render the buffer (anti aliasing).
 /// Sets the number of samples used to render the buffer (anti aliasing).
 external num get samples; external set samples(num v);
 /// Disposes the renderer and frees up associated resources.
 external void dispose(); external void JS$_createRenderTargets(); }

 @JS("BABYLON.OutlineRenderer" ) class OutlineRenderer { // @Ignore
 OutlineRenderer .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_effect; external set JS$_effect(v); external get JS$_cachedDefines; external set JS$_cachedDefines(v); external num get zOffset; external set zOffset(num v); external factory OutlineRenderer(Scene scene); external void render(SubMesh subMesh, JS$_InstancesBatch batch, [bool useOverlay]); external bool isReady(SubMesh subMesh, bool useInstances); }

 @JS("BABYLON.RenderingGroup" ) class RenderingGroup { // @Ignore
 RenderingGroup .fakeConstructor$() ;
 external num get index; external set index(num v); external get JS$_scene; external set JS$_scene(v); external get JS$_opaqueSubMeshes; external set JS$_opaqueSubMeshes(v); external get JS$_transparentSubMeshes; external set JS$_transparentSubMeshes(v); external get JS$_alphaTestSubMeshes; external set JS$_alphaTestSubMeshes(v); external get JS$_depthOnlySubMeshes; external set JS$_depthOnlySubMeshes(v); external get JS$_particleSystems; external set JS$_particleSystems(v); external get JS$_spriteManagers; external set JS$_spriteManagers(v); external get JS$_opaqueSortCompareFn; external set JS$_opaqueSortCompareFn(v); external get JS$_alphaTestSortCompareFn; external set JS$_alphaTestSortCompareFn(v); external get JS$_transparentSortCompareFn; external set JS$_transparentSortCompareFn(v); external get JS$_renderOpaque; external set JS$_renderOpaque(v); external get JS$_renderAlphaTest; external set JS$_renderAlphaTest(v); external get JS$_renderTransparent; external set JS$_renderTransparent(v); external get JS$_edgesRenderers; external set JS$_edgesRenderers(v); external VoidFunc0 get onBeforeTransparentRendering; external set onBeforeTransparentRendering(VoidFunc0 v);
 /// Set the opaque sort comparison function.
 /// If null the sub meshes will be render in the order they were created
 external Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ get opaqueSortCompareFn; external set opaqueSortCompareFn(Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ v);
 /// Set the alpha test sort comparison function.
 /// If null the sub meshes will be render in the order they were created
 external Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ get alphaTestSortCompareFn; external set alphaTestSortCompareFn(Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ v);
 /// Set the transparent sort comparison function.
 /// If null the sub meshes will be render in the order they were created
 external Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ get transparentSortCompareFn; external set transparentSortCompareFn(Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ v);
 /// Creates a new rendering group.
 external factory RenderingGroup(num index, Scene scene, [Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ opaqueSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ alphaTestSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ transparentSortCompareFn]);
 /// Render all the sub meshes contained in the group.
 external void render(VoidFunc4<SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>>/*VoidFunc4<SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>>|Null*/ customRenderFunction, bool renderSprites, bool renderParticles, List<AbstractMesh>/*List<AbstractMesh>|Null*/ activeMeshes);
 /// Renders the opaque submeshes in the order from the opaqueSortCompareFn.
 external renderOpaqueSorted(subMeshes);
 /// Renders the opaque submeshes in the order from the alphatestSortCompareFn.
 external renderAlphaTestSorted(subMeshes);
 /// Renders the opaque submeshes in the order from the transparentSortCompareFn.
 external renderTransparentSorted(subMeshes);
 /// Renders the submeshes in a specified order.
 external static renderSorted(subMeshes, sortCompareFn, camera, transparent);
 /// Renders the submeshes in the order they were dispatched (no sort applied).
 external static renderUnsorted(subMeshes);
 /// Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
 /// are rendered back to front if in the same alpha index.
 external static num defaultTransparentSortCompare(SubMesh a, SubMesh b);
 /// Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
 /// are rendered back to front.
 external static num backToFrontSortCompare(SubMesh a, SubMesh b);
 /// Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
 /// are rendered front to back (prevent overdraw).
 external static num frontToBackSortCompare(SubMesh a, SubMesh b);
 /// Resets the different lists of submeshes to prepare a new frame.
 external void prepare(); external void dispose();
 /// Inserts the submesh in its correct queue depending on its material.
 external void dispatch(SubMesh subMesh, [AbstractMesh mesh, Material/*Material|Null*/ material]); external void dispatchSprites(SpriteManager spriteManager); external void dispatchParticles(IParticleSystem particleSystem); external JS$_renderParticles(activeMeshes); external JS$_renderSprites(); }

 @JS("BABYLON.RenderingManager" ) class RenderingManager { // @Ignore
 RenderingManager .fakeConstructor$() ;
 /// The max id used for rendering groups (not included)
 external static num get MAX_RENDERINGGROUPS; external static set MAX_RENDERINGGROUPS(num v);
 /// The min id used for rendering groups (included)
 external static num get MIN_RENDERINGGROUPS; external static set MIN_RENDERINGGROUPS(num v);
 /// Used to globally prevent autoclearing scenes.
 external static bool get AUTOCLEAR; external static set AUTOCLEAR(bool v); external get JS$_scene; external set JS$_scene(v); external get JS$_renderingGroups; external set JS$_renderingGroups(v); external get JS$_depthStencilBufferAlreadyCleaned; external set JS$_depthStencilBufferAlreadyCleaned(v); external get JS$_autoClearDepthStencil; external set JS$_autoClearDepthStencil(v); external get JS$_customOpaqueSortCompareFn; external set JS$_customOpaqueSortCompareFn(v); external get JS$_customAlphaTestSortCompareFn; external set JS$_customAlphaTestSortCompareFn(v); external get JS$_customTransparentSortCompareFn; external set JS$_customTransparentSortCompareFn(v); external get JS$_renderinGroupInfo; external set JS$_renderinGroupInfo(v); external factory RenderingManager(Scene scene); external JS$_clearDepthStencilBuffer([depth, stencil]); external void render(VoidFunc4<SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>>/*VoidFunc4<SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>, SmartArray<SubMesh>>|Null*/ customRenderFunction, List<AbstractMesh>/*List<AbstractMesh>|Null*/ activeMeshes, bool renderParticles, bool renderSprites); external void reset(); external void dispose();
 /// Clear the info related to rendering groups preventing retention points during dispose.
 external void freeRenderingGroups(); external JS$_prepareRenderingGroup(renderingGroupId); external void dispatchSprites(SpriteManager spriteManager); external void dispatchParticles(IParticleSystem particleSystem);
 external void dispatch(SubMesh subMesh, [AbstractMesh mesh, Material/*Material|Null*/ material]);
 /// Overrides the default sort function applied in the renderging group to prepare the meshes.
 /// This allowed control for front to back rendering or reversly depending of the special needs.
 external void setRenderingOrder(num renderingGroupId, [Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ opaqueSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ alphaTestSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ transparentSortCompareFn]);
 /// Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
 external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil, [bool depth, bool stencil]); }

 /// Postprocess used to generate anaglyphic rendering
 @JS("BABYLON.AnaglyphPostProcess" ) class AnaglyphPostProcess extends PostProcess { // @Ignore
 AnaglyphPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_passedProcess; external set JS$_passedProcess(v);
 /// Creates a new AnaglyphPostProcess
 external factory AnaglyphPostProcess(String name, num/*num|PostProcessOptions*/ options, List<Camera> rigCameras, [num samplingMode, Engine engine, bool reusable]); }

 @JS("BABYLON.BlackAndWhitePostProcess" ) class BlackAndWhitePostProcess extends PostProcess { // @Ignore
 BlackAndWhitePostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external num get degree; external set degree(num v); external factory BlackAndWhitePostProcess(String name, num/*num|PostProcessOptions*/ options, Camera camera, [num samplingMode, Engine engine, bool reusable]); }

 /// The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras
 @JS("BABYLON.BloomEffect" ) class BloomEffect extends PostProcessRenderEffect { // @Ignore
 BloomEffect .fakeConstructor$() : super.fakeConstructor$() ;
 external get bloomScale; external set bloomScale(v);
 /// Internal
 external List<PostProcess> get JS$_effects; external set JS$_effects(List<PostProcess> v);
 /// Internal
 external ExtractHighlightsPostProcess get JS$_downscale; external set JS$_downscale(ExtractHighlightsPostProcess v); external get JS$_blurX; external set JS$_blurX(v); external get JS$_blurY; external set JS$_blurY(v); external get JS$_merge; external set JS$_merge(v);
 /// The luminance threshold to find bright areas of the image to bloom.
 external num get threshold; external set threshold(num v);
 /// The strength of the bloom.
 external num get weight; external set weight(num v);
 /// Specifies the size of the bloom blur kernel, relative to the final output size
 external num get kernel; external set kernel(num v);
 /// Creates a new instance of @see BloomEffect
 external factory BloomEffect(Scene scene, num bloomScale, num bloomWeight, num bloomKernel, [num pipelineTextureType, bool blockCompilation]);
 /// Disposes each of the internal effects for a given camera.
 external void disposeEffects(Camera camera);
 /// Internal
 external void JS$_updateEffects();
 /// Internal
 external bool JS$_isReady(); }

 /// The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
 @JS("BABYLON.BloomMergePostProcess" ) class BloomMergePostProcess extends PostProcess { // @Ignore
 BloomMergePostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 /// Weight of the bloom to be added to the original input.
 external num get weight; external set weight(num v);
 /// Creates a new instance of @see BloomMergePostProcess
 external factory BloomMergePostProcess(String name, PostProcess originalFromInput, PostProcess blurred, num weight, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]); }

 /// The Blur Post Process which blurs an image based on a kernel and direction.
 /// Can be used twice in x and y directions to perform a guassian blur in two passes.
 @JS("BABYLON.BlurPostProcess" ) class BlurPostProcess extends PostProcess { // @Ignore
 BlurPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 /// The direction in which to blur the image.
 external Vector2 get direction; external set direction(Vector2 v); external get blockCompilation; external set blockCompilation(v); external num get JS$_kernel; external set JS$_kernel(num v); external num get JS$_idealKernel; external set JS$_idealKernel(num v); external bool get JS$_packedFloat; external set JS$_packedFloat(bool v); external get JS$_staticDefines; external set JS$_staticDefines(v);
 /// Gets the length in pixels of the blur sample region
 /// Sets the length in pixels of the blur sample region
 external num get kernel; external set kernel(num v);
 /// Gets wether or not the blur is unpacking/repacking floats
 /// Sets wether or not the blur needs to unpack/repack floats
 external bool get packedFloat; external set packedFloat(bool v);
 /// Creates a new instance BlurPostProcess
 external factory BlurPostProcess(String name, Vector2 direction, num kernel, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, String defines, bool blockCompilation]);
 /// Updates the effect with the current post process compile time values and recompiles the shader.
 external void updateEffect([String/*String|Null*/ defines, List<String>/*List<String>|Null*/ uniforms, List<String>/*List<String>|Null*/ samplers, dynamic indexParameters, void onCompiled(Effect effect), void onError(Effect effect, String errors)]); external void JS$_updateParameters([void onCompiled(Effect effect), void onError(Effect effect, String errors)]);
 /// Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.
 /// Other odd kernels optimize correctly but require proportionally more samples, even kernels are
 /// possible but will produce minor visual artifacts. Since each new kernel requires a new shader we
 /// want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.
 /// The gaps between physical kernels are compensated for in the weighting of the samples
 external num JS$_nearestBestKernel(num idealKernel);
 /// Calculates the value of a Gaussian distribution with sigma 3 at a given point.
 external num JS$_gaussianWeight(num x);
 /// Generates a string that can be used as a floating point number in GLSL.
 external String JS$_glslFloat(num x, [num decimalFigures]); }

 /// The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen
 @JS("BABYLON.ChromaticAberrationPostProcess" ) class ChromaticAberrationPostProcess extends PostProcess { // @Ignore
 ChromaticAberrationPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 /// The amount of seperation of rgb channels (default: 30)
 external num get aberrationAmount; external set aberrationAmount(num v);
 /// The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)
 external num get radialIntensity; external set radialIntensity(num v);
 /// The normilized direction in which the rgb channels should be seperated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))
 external Vector2 get direction; external set direction(Vector2 v);
 /// The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corder] (default: Vector2(0.5 ,0.5))
 external Vector2 get centerPosition; external set centerPosition(Vector2 v);
 /// Creates a new instance ChromaticAberrationPostProcess
 external factory ChromaticAberrationPostProcess(String name, num screenWidth, num screenHeight, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]); }

 /// The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion
 @JS("BABYLON.CircleOfConfusionPostProcess" ) class CircleOfConfusionPostProcess extends PostProcess { // @Ignore
 CircleOfConfusionPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 /// Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
 external num get lensSize; external set lensSize(num v);
 /// F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
 external num get fStop; external set fStop(num v);
 /// Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
 external num get focusDistance; external set focusDistance(num v);
 /// Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)
 external num get focalLength; external set focalLength(num v); external get JS$_depthTexture; external set JS$_depthTexture(v);
 /// Creates a new instance CircleOfConfusionPostProcess
 external factory CircleOfConfusionPostProcess(String name, RenderTargetTexture/*RenderTargetTexture|Null*/ depthTexture, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);
 /// Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
 external RenderTargetTexture get depthTexture; external set depthTexture(RenderTargetTexture v); }

 @JS("BABYLON.ColorCorrectionPostProcess" ) class ColorCorrectionPostProcess extends PostProcess { // @Ignore
 ColorCorrectionPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_colorTableTexture; external set JS$_colorTableTexture(v); external factory ColorCorrectionPostProcess(String name, String colorTableUrl, num/*num|PostProcessOptions*/ options, Camera camera, [num samplingMode, Engine engine, bool reusable]); }

 /// The ConvolutionPostProcess applies a 3x3 kernel to every pixel of the
 /// input texture to perform effects such as edge detection or sharpening
 /// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
 @JS("BABYLON.ConvolutionPostProcess" ) class ConvolutionPostProcess extends PostProcess { // @Ignore
 ConvolutionPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 /// Array of 9 values corrisponding to the 3x3 kernel to be applied
 external List<num> get kernel; external set kernel(List<num> v);
 /// Creates a new instance ConvolutionPostProcess
 external factory ConvolutionPostProcess(String name, List<num> kernel, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType]);
 /// Edge detection 0 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
 external static List<num> get EdgeDetect0Kernel; external static set EdgeDetect0Kernel(List<num> v);
 /// Edge detection 1 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
 external static List<num> get EdgeDetect1Kernel; external static set EdgeDetect1Kernel(List<num> v);
 /// Edge detection 2 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
 external static List<num> get EdgeDetect2Kernel; external static set EdgeDetect2Kernel(List<num> v);
 /// Kernel to sharpen an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
 external static List<num> get SharpenKernel; external static set SharpenKernel(List<num> v);
 /// Kernel to emboss an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
 external static List<num> get EmbossKernel; external static set EmbossKernel(List<num> v);
 /// Kernel to blur an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
 external static List<num> get GaussianKernel; external static set GaussianKernel(List<num> v); }

 /// The DepthOfFieldBlurPostProcess applied a blur in a give direction.
 /// This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels
 /// based on samples that have a large difference in distance than the center pixel.
 /// See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
 @JS("BABYLON.DepthOfFieldBlurPostProcess" ) class DepthOfFieldBlurPostProcess extends BlurPostProcess { // @Ignore
 DepthOfFieldBlurPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external Vector2 get direction; external set direction(Vector2 v);
 /// Creates a new instance CircleOfConfusionPostProcess
 external factory DepthOfFieldBlurPostProcess(String name, Scene scene, Vector2 direction, num kernel, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, PostProcess circleOfConfusion, [PostProcess/*PostProcess|Null*/ imageToBlur, num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]); }

 /// Specifies the level of max blur that should be applied when using the depth of field effect
 @JS("BABYLON.DepthOfFieldEffectBlurLevel" ) class DepthOfFieldEffectBlurLevel { external static num get
 /// Subtle blur
 Low; external static num get
 /// Medium blur
 Medium; external static num get
 /// Large blur
 High; }
 /// The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.
 @JS("BABYLON.DepthOfFieldEffect" ) class DepthOfFieldEffect extends PostProcessRenderEffect { // @Ignore
 DepthOfFieldEffect .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_circleOfConfusion; external set JS$_circleOfConfusion(v);
 /// Internal, blurs from high to low
 external List<DepthOfFieldBlurPostProcess> get JS$_depthOfFieldBlurX; external set JS$_depthOfFieldBlurX(List<DepthOfFieldBlurPostProcess> v); external get JS$_depthOfFieldBlurY; external set JS$_depthOfFieldBlurY(v); external get JS$_dofMerge; external set JS$_dofMerge(v);
 /// Internal post processes in depth of field effect
 external List<PostProcess> get JS$_effects; external set JS$_effects(List<PostProcess> v);
 /// The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)
 external num get focalLength; external set focalLength(num v);
 /// F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
 external num get fStop; external set fStop(num v);
 /// Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
 external num get focusDistance; external set focusDistance(num v);
 /// Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
 external num get lensSize; external set lensSize(num v);
 /// Creates a new instance DepthOfFieldEffect
 external factory DepthOfFieldEffect(Scene scene, RenderTargetTexture/*RenderTargetTexture|Null*/ depthTexture, [num/*enum DepthOfFieldEffectBlurLevel*/ blurLevel, num pipelineTextureType, bool blockCompilation]);
 /// Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
 external RenderTargetTexture get depthTexture; external set depthTexture(RenderTargetTexture v);
 /// Disposes each of the internal effects for a given camera.
 external void disposeEffects(Camera camera);
 /// Internal
 external void JS$_updateEffects();
 /// Internal
 external bool JS$_isReady(); }

 /// Options to be set when merging outputs from the default pipeline.
 @JS("BABYLON.DepthOfFieldMergePostProcessOptions" ) class DepthOfFieldMergePostProcessOptions { // @Ignore
 DepthOfFieldMergePostProcessOptions .fakeConstructor$() ;
 /// The original image to merge on top of
 external PostProcess get originalFromInput; external set originalFromInput(PostProcess v);
 /// Parameters to perform the merge of the depth of field effect
 external dynamic/*{
            circleOfConfusion: PostProcess;
            blurSteps: Array<PostProcess>;
        }*/ get depthOfField; external set depthOfField(dynamic/*{
            circleOfConfusion: PostProcess;
            blurSteps: Array<PostProcess>;
        }*/ v);
 /// Parameters to perform the merge of bloom effect
 external dynamic/*{
            blurred: PostProcess;
            weight: number;
        }*/ get bloom; external set bloom(dynamic/*{
            blurred: PostProcess;
            weight: number;
        }*/ v); }

 /// The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
 @JS("BABYLON.DepthOfFieldMergePostProcess" ) class DepthOfFieldMergePostProcess extends PostProcess { // @Ignore
 DepthOfFieldMergePostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external get blurSteps; external set blurSteps(v);
 /// Creates a new instance of DepthOfFieldMergePostProcess
 external factory DepthOfFieldMergePostProcess(String name, PostProcess originalFromInput, PostProcess circleOfConfusion, List<PostProcess> blurSteps, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]);
 /// Updates the effect with the current post process compile time values and recompiles the shader.
 external void updateEffect([String/*String|Null*/ defines, List<String>/*List<String>|Null*/ uniforms, List<String>/*List<String>|Null*/ samplers, dynamic indexParameters, void onCompiled(Effect effect), void onError(Effect effect, String errors)]); }

 @JS("BABYLON.DisplayPassPostProcess" ) class DisplayPassPostProcess extends PostProcess { // @Ignore
 DisplayPassPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external factory DisplayPassPostProcess(String name, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable]); }

 /// The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.
 @JS("BABYLON.ExtractHighlightsPostProcess" ) class ExtractHighlightsPostProcess extends PostProcess { // @Ignore
 ExtractHighlightsPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 /// The luminance threshold, pixels below this value will be set to black.
 external num get threshold; external set threshold(num v);
 /// Internal
 external num get JS$_exposure; external set JS$_exposure(num v);
 /// Post process which has the input texture to be used when performing highlight extraction
 external PostProcess/*PostProcess|Null*/ get JS$_inputPostProcess; external set JS$_inputPostProcess(PostProcess/*PostProcess|Null*/ v); external factory ExtractHighlightsPostProcess(String name, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]); }

 @JS("BABYLON.FilterPostProcess" ) class FilterPostProcess extends PostProcess { // @Ignore
 FilterPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external Matrix get kernelMatrix; external set kernelMatrix(Matrix v); external factory FilterPostProcess(String name, Matrix kernelMatrix, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable]); }

 @JS("BABYLON.FxaaPostProcess" ) class FxaaPostProcess extends PostProcess { // @Ignore
 FxaaPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external num get texelWidth; external set texelWidth(num v); external num get texelHeight; external set texelHeight(num v); external factory FxaaPostProcess(String name, num/*num|PostProcessOptions*/ options, [Camera/*Camera|Null*/ camera, num samplingMode, Engine engine, bool reusable, num textureType]); external JS$_getDefines(); }

 /// The GrainPostProcess adds noise to the image at mid luminance levels
 @JS("BABYLON.GrainPostProcess" ) class GrainPostProcess extends PostProcess { // @Ignore
 GrainPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 /// The intensity of the grain added (default: 30)
 external num get intensity; external set intensity(num v);
 /// If the grain should be randomized on every frame
 external bool get animated; external set animated(bool v);
 /// Creates a new instance of @see GrainPostProcess
 external factory GrainPostProcess(String name, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]); }

 @JS("BABYLON.HighlightsPostProcess" ) class HighlightsPostProcess extends PostProcess { // @Ignore
 HighlightsPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external factory HighlightsPostProcess(String name, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType]); }

 @JS("BABYLON.ImageProcessingPostProcess" ) class ImageProcessingPostProcess extends PostProcess { // @Ignore
 ImageProcessingPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 /// Default configuration related to image processing available in the PBR Material.
 external ImageProcessingConfiguration get JS$_imageProcessingConfiguration; external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);
 /// Gets the image processing configuration used either in this material.
 /// Sets the Default image processing configuration used either in the this material.
 /// If sets to null, the scene one is in use.
 external ImageProcessingConfiguration get imageProcessingConfiguration; external set imageProcessingConfiguration(ImageProcessingConfiguration v);
 /// Keep track of the image processing observer to allow dispose and replace.
 external get JS$_imageProcessingObserver; external set JS$_imageProcessingObserver(v);
 /// Attaches a new image processing configuration to the PBR Material.
 external void JS$_attachImageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ configuration, [bool doNotBuild]);
 /// Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .
 /// Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .
 external ColorCurves/*ColorCurves|Null*/ get colorCurves; external set colorCurves(ColorCurves/*ColorCurves|Null*/ v);
 /// Gets wether the color curves effect is enabled.
 /// Sets wether the color curves effect is enabled.
 external bool get colorCurvesEnabled; external set colorCurvesEnabled(bool v);
 /// Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
 /// Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
 external BaseTexture/*BaseTexture|Null*/ get colorGradingTexture; external set colorGradingTexture(BaseTexture/*BaseTexture|Null*/ v);
 /// Gets wether the color grading effect is enabled.
 /// Gets wether the color grading effect is enabled.
 external bool get colorGradingEnabled; external set colorGradingEnabled(bool v);
 /// Gets exposure used in the effect.
 /// Sets exposure used in the effect.
 external num get exposure; external set exposure(num v);
 /// Gets wether tonemapping is enabled or not.
 /// Sets wether tonemapping is enabled or not
 external bool get toneMappingEnabled; external set toneMappingEnabled(bool v);
 /// Gets contrast used in the effect.
 /// Sets contrast used in the effect.
 external num get contrast; external set contrast(num v);
 /// Gets Vignette stretch size.
 /// Sets Vignette stretch size.
 external num get vignetteStretch; external set vignetteStretch(num v);
 /// Gets Vignette centre X Offset.
 /// Sets Vignette centre X Offset.
 external num get vignetteCentreX; external set vignetteCentreX(num v);
 /// Gets Vignette centre Y Offset.
 /// Sets Vignette centre Y Offset.
 external num get vignetteCentreY; external set vignetteCentreY(num v);
 /// Gets Vignette weight or intensity of the vignette effect.
 /// Sets Vignette weight or intensity of the vignette effect.
 external num get vignetteWeight; external set vignetteWeight(num v);
 /// Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
 /// if vignetteEnabled is set to true.
 /// Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
 /// if vignetteEnabled is set to true.
 external Color4 get vignetteColor; external set vignetteColor(Color4 v);
 /// Gets Camera field of view used by the Vignette effect.
 /// Sets Camera field of view used by the Vignette effect.
 external num get vignetteCameraFov; external set vignetteCameraFov(num v);
 /// Gets the vignette blend mode allowing different kind of effect.
 /// Sets the vignette blend mode allowing different kind of effect.
 external num get vignetteBlendMode; external set vignetteBlendMode(num v);
 /// Gets wether the vignette effect is enabled.
 /// Sets wether the vignette effect is enabled.
 external bool get vignetteEnabled; external set vignetteEnabled(bool v); external get JS$_fromLinearSpace; external set JS$_fromLinearSpace(v);
 /// Gets wether the input of the processing is in Gamma or Linear Space.
 /// Sets wether the input of the processing is in Gamma or Linear Space.
 external bool get fromLinearSpace; external set fromLinearSpace(bool v);
 /// Defines cache preventing GC.
 external get JS$_defines; external set JS$_defines(v); external factory ImageProcessingPostProcess(String name, num/*num|PostProcessOptions*/ options, [Camera/*Camera|Null*/ camera, num samplingMode, Engine engine, bool reusable, num textureType, ImageProcessingConfiguration imageProcessingConfiguration]); external String getClassName(); external void JS$_updateParameters(); external void dispose([Camera camera]); }

 @JS("BABYLON.PassPostProcess" ) class PassPostProcess extends PostProcess { // @Ignore
 PassPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external factory PassPostProcess(String name, num/*num|PostProcessOptions*/ options, [Camera/*Camera|Null*/ camera, num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]); }

 @anonymous
@JS()
 abstract class PostProcessOptions { external num get width; external set width(num v); external num get height; external set height(num v); external factory PostProcessOptions({ num width, num height}); }

 /// PostProcess can be used to apply a shader to a texture after it has been rendered
 /// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
 @JS("BABYLON.PostProcess" ) class PostProcess { // @Ignore
 PostProcess .fakeConstructor$() ;
 /// Name of the PostProcess.
 external String get name; external set name(String v);
 /// Width of the texture to apply the post process on
 external num get width; external set width(num v);
 /// Height of the texture to apply the post process on
 external num get height; external set height(num v);
 /// Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)
 external InternalTexture/*InternalTexture|Null*/ get JS$_outputTexture; external set JS$_outputTexture(InternalTexture/*InternalTexture|Null*/ v);
 /// Sampling mode used by the shader
 /// See https://doc.babylonjs.com/classes/3.1/texture
 external num get renderTargetSamplingMode; external set renderTargetSamplingMode(num v);
 /// Clear color to use when screen clearing
 external Color4 get clearColor; external set clearColor(Color4 v);
 /// If the buffer needs to be cleared before applying the post process. (default: true)
 /// Should be set to false if shader will overwrite all previous pixels.
 external bool get autoClear; external set autoClear(bool v);
 /// Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)
 external num get alphaMode; external set alphaMode(num v);
 /// Sets the setAlphaBlendConstants of the babylon engine
 external Color4 get alphaConstants; external set alphaConstants(Color4 v);
 /// Animations to be used for the post processing
 external List<Animation> get animations; external set animations(List<Animation> v);
 /// Enable Pixel Perfect mode where texture is not scaled to be power of 2.
 /// Can only be used on a single postprocess or on the last one of a chain. (default: false)
 external bool get enablePixelPerfectMode; external set enablePixelPerfectMode(bool v);
 /// Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)
 external num get scaleMode; external set scaleMode(num v);
 /// Force textures to be a power of two (default: false)
 external bool get alwaysForcePOT; external set alwaysForcePOT(bool v);
 /// Number of sample textures (default: 1)
 external num get samples; external set samples(num v);
 /// Modify the scale of the post process to be the same as the viewport (default: false)
 external bool get adaptScaleToCurrentViewport; external set adaptScaleToCurrentViewport(bool v); external get JS$_camera; external set JS$_camera(v); external get JS$_scene; external set JS$_scene(v); external get JS$_engine; external set JS$_engine(v); external get JS$_options; external set JS$_options(v); external get JS$_reusable; external set JS$_reusable(v); external get JS$_textureType; external set JS$_textureType(v);
 /// Smart array of input and output textures for the post process.
 external SmartArray<InternalTexture> get JS$_textures; external set JS$_textures(SmartArray<InternalTexture> v);
 /// The index in _textures that corresponds to the output texture.
 external num get JS$_currentRenderTextureInd; external set JS$_currentRenderTextureInd(num v); external get JS$_effect; external set JS$_effect(v); external get JS$_samplers; external set JS$_samplers(v); external get JS$_fragmentUrl; external set JS$_fragmentUrl(v); external get JS$_vertexUrl; external set JS$_vertexUrl(v); external get JS$_parameters; external set JS$_parameters(v); external get JS$_scaleRatio; external set JS$_scaleRatio(v); external dynamic get JS$_indexParameters; external set JS$_indexParameters(dynamic v); external get JS$_shareOutputWithPostProcess; external set JS$_shareOutputWithPostProcess(v); external get JS$_texelSize; external set JS$_texelSize(v); external get JS$_forcedOutputTexture; external set JS$_forcedOutputTexture(v);
 /// An event triggered when the postprocess is activated.
 external Observable<Camera> get onActivateObservable; external set onActivateObservable(Observable<Camera> v); external get JS$_onActivateObserver; external set JS$_onActivateObserver(v);
 /// A function that is added to the onActivateObservable
 external VoidFunc1<Camera>/*VoidFunc1<Camera>|Null*/ get onActivate; external set onActivate(VoidFunc1<Camera>/*VoidFunc1<Camera>|Null*/ v);
 /// An event triggered when the postprocess changes its size.
 external Observable<PostProcess> get onSizeChangedObservable; external set onSizeChangedObservable(Observable<PostProcess> v); external get JS$_onSizeChangedObserver; external set JS$_onSizeChangedObserver(v);
 /// A function that is added to the onSizeChangedObservable
 external VoidFunc1<PostProcess> get onSizeChanged; external set onSizeChanged(VoidFunc1<PostProcess> v);
 /// An event triggered when the postprocess applies its effect.
 external Observable<Effect> get onApplyObservable; external set onApplyObservable(Observable<Effect> v); external get JS$_onApplyObserver; external set JS$_onApplyObserver(v);
 /// A function that is added to the onApplyObservable
 external VoidFunc1<Effect> get onApply; external set onApply(VoidFunc1<Effect> v);
 /// An event triggered before rendering the postprocess
 external Observable<Effect> get onBeforeRenderObservable; external set onBeforeRenderObservable(Observable<Effect> v); external get JS$_onBeforeRenderObserver; external set JS$_onBeforeRenderObserver(v);
 /// A function that is added to the onBeforeRenderObservable
 external VoidFunc1<Effect> get onBeforeRender; external set onBeforeRender(VoidFunc1<Effect> v);
 /// An event triggered after rendering the postprocess
 external Observable<Effect> get onAfterRenderObservable; external set onAfterRenderObservable(Observable<Effect> v); external get JS$_onAfterRenderObserver; external set JS$_onAfterRenderObserver(v);
 /// A function that is added to the onAfterRenderObservable
 external VoidFunc1<Effect> get onAfterRender; external set onAfterRender(VoidFunc1<Effect> v);
 /// The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will
 /// render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.
 external InternalTexture get inputTexture; external set inputTexture(InternalTexture v);
 /// Gets the camera which post process is applied to.
 external Camera getCamera();
 /// Gets the texel size of the postprocess.
 /// See https://en.wikipedia.org/wiki/Texel_(graphics)
 external Vector2 get texelSize; external set texelSize(Vector2 v);
 /// Creates a new instance PostProcess
 external factory PostProcess(String name, String fragmentUrl, List<String>/*List<String>|Null*/ parameters, List<String>/*List<String>|Null*/ samplers, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, String/*String|Null*/ defines, num textureType, String vertexUrl, dynamic indexParameters, bool blockCompilation]);
 /// Gets the engine which this post process belongs to.
 external Engine getEngine();
 /// The effect that is created when initializing the post process.
 external Effect getEffect();
 /// To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.
 external PostProcess shareOutputWith(PostProcess postProcess);
 /// Reverses the effect of calling shareOutputWith and returns the post process back to its original state.
 /// This should be called if the post process that shares output with this post process is disabled/disposed.
 external void useOwnOutput();
 /// Updates the effect with the current post process compile time values and recompiles the shader.
 external void updateEffect([String/*String|Null*/ defines, List<String>/*List<String>|Null*/ uniforms, List<String>/*List<String>|Null*/ samplers, dynamic indexParameters, void onCompiled(Effect effect), void onError(Effect effect, String errors)]);
 /// The post process is reusable if it can be used multiple times within one frame.
 external bool isReusable();
 /// invalidate frameBuffer to hint the postprocess to create a depth buffer
 external void markTextureDirty();
 /// Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.
 /// When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.
 external InternalTexture activate(Camera/*Camera|Null*/ camera, [InternalTexture/*InternalTexture|Null*/ sourceTexture, bool forceDepthStencil]);
 /// If the post process is supported.
 external bool get isSupported; external set isSupported(bool v);
 /// The aspect ratio of the output texture.
 external num get aspectRatio; external set aspectRatio(num v);
 /// Get a value indicating if the post-process is ready to be used
 external bool isReady();
 /// Binds all textures and uniforms to the shader, this will be run on every pass.
 external Effect/*Effect|Null*/ apply(); external JS$_disposeTextures();
 /// Disposes the post process.
 external void dispose([Camera camera]); }

 /// PostProcessManager is used to manage one or more post processes or post process pipelines
 /// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
 @JS("BABYLON.PostProcessManager" ) class PostProcessManager { // @Ignore
 PostProcessManager .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_indexBuffer; external set JS$_indexBuffer(v); external get JS$_vertexBuffers; external set JS$_vertexBuffers(v);
 /// Creates a new instance PostProcess
 external factory PostProcessManager(Scene scene); external JS$_prepareBuffers(); external JS$_buildIndexBuffer();
 /// Rebuilds the vertex buffers of the manager.
 external void JS$_rebuild();
 /// Prepares a frame to be run through a post process.
 external bool JS$_prepareFrame([InternalTexture/*InternalTexture|Null*/ sourceTexture, List<PostProcess>/*List<PostProcess>|Null*/ postProcesses]);
 /// Manually render a set of post processes to a texture.
 external void directRender(List<PostProcess> postProcesses, [InternalTexture/*InternalTexture|Null*/ targetTexture, bool forceFullscreenViewport]);
 /// Finalize the result of the output of the postprocesses.
 external void JS$_finalizeFrame([bool doNotPresent, InternalTexture targetTexture, num faceIndex, List<PostProcess> postProcesses, bool forceFullscreenViewport]);
 /// Disposes of the post process manager.
 external void dispose(); }

 @JS("BABYLON.RefractionPostProcess" ) class RefractionPostProcess extends PostProcess { // @Ignore
 RefractionPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external Color3 get color; external set color(Color3 v); external num get depth; external set depth(num v); external num get colorLevel; external set colorLevel(num v); external get JS$_refTexture; external set JS$_refTexture(v); external get JS$_ownRefractionTexture; external set JS$_ownRefractionTexture(v);
 /// Gets or sets the refraction texture
 /// Please note that you are responsible for disposing the texture if you set it manually
 external Texture get refractionTexture; external set refractionTexture(Texture v); external factory RefractionPostProcess(String name, String refractionTextureUrl, Color3 color, num depth, num colorLevel, num/*num|PostProcessOptions*/ options, Camera camera, [num samplingMode, Engine engine, bool reusable]); external void dispose(Camera camera); }

 /// The SharpenPostProcess applies a sharpen kernel to every pixel
 /// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
 @JS("BABYLON.SharpenPostProcess" ) class SharpenPostProcess extends PostProcess { // @Ignore
 SharpenPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 /// How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)
 external num get colorAmount; external set colorAmount(num v);
 /// How much sharpness should be applied (default: 0.3)
 external num get edgeAmount; external set edgeAmount(num v);
 /// Creates a new instance ConvolutionPostProcess
 external factory SharpenPostProcess(String name, num/*num|PostProcessOptions*/ options, Camera/*Camera|Null*/ camera, [num samplingMode, Engine engine, bool reusable, num textureType, bool blockCompilation]); }

 @JS("BABYLON.StereoscopicInterlacePostProcess" ) class StereoscopicInterlacePostProcess extends PostProcess { // @Ignore
 StereoscopicInterlacePostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_stepSize; external set JS$_stepSize(v); external get JS$_passedProcess; external set JS$_passedProcess(v); external factory StereoscopicInterlacePostProcess(String name, List<Camera> rigCameras, bool isStereoscopicHoriz, [num samplingMode, Engine engine, bool reusable]); }

 /// Defines operator used for tonemapping
 @JS("BABYLON.TonemappingOperator" ) class TonemappingOperator { external static num get
 /// Hable
 Hable; external static num get
 /// Reinhard
 Reinhard; external static num get
 /// HejiDawson
 HejiDawson; external static num get
 /// Photographic
 Photographic; }
 /// Defines a post process to apply tone mapping
 @JS("BABYLON.TonemapPostProcess" ) class TonemapPostProcess extends PostProcess { // @Ignore
 TonemapPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_operator; external set JS$_operator(v);
 /// Defines the required exposure adjustement
 external num get exposureAdjustment; external set exposureAdjustment(num v);
 /// Creates a new TonemapPostProcess
 external factory TonemapPostProcess(String name, num/*enum TonemappingOperator*/ JS$_operator,
 /// Defines the required exposure adjustement
 num exposureAdjustment, Camera camera, [num samplingMode, Engine engine, num textureFormat]); }

 @JS("BABYLON.VolumetricLightScatteringPostProcess" ) class VolumetricLightScatteringPostProcess extends PostProcess { // @Ignore
 VolumetricLightScatteringPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_volumetricLightScatteringPass; external set JS$_volumetricLightScatteringPass(v); external get JS$_volumetricLightScatteringRTT; external set JS$_volumetricLightScatteringRTT(v); external get JS$_viewPort; external set JS$_viewPort(v); external get JS$_screenCoordinates; external set JS$_screenCoordinates(v); external get JS$_cachedDefines; external set JS$_cachedDefines(v);
 /// If not undefined, the mesh position is computed from the attached node position
 external dynamic/*{
            position: Vector3;
        }*/ get attachedNode; external set attachedNode(dynamic/*{
            position: Vector3;
        }*/ v);
 /// Custom position of the mesh. Used if "useCustomMeshPosition" is set to "true"
 external Vector3 get customMeshPosition; external set customMeshPosition(Vector3 v);
 /// Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)
 external bool get useCustomMeshPosition; external set useCustomMeshPosition(bool v);
 /// If the post-process should inverse the light scattering direction
 external bool get invert; external set invert(bool v);
 /// The internal mesh used by the post-process
 external Mesh get mesh; external set mesh(Mesh v); external bool get useDiffuseColor; external set useDiffuseColor(bool v);
 /// Array containing the excluded meshes not rendered in the internal pass
 external List<AbstractMesh> get excludedMeshes; external set excludedMeshes(List<AbstractMesh> v);
 /// Controls the overall intensity of the post-process
 external num get exposure; external set exposure(num v);
 /// Dissipates each sample's contribution in range [0, 1]
 external num get decay; external set decay(num v);
 /// Controls the overall intensity of each sample
 external num get weight; external set weight(num v);
 /// Controls the density of each sample
 external num get density; external set density(num v);
 /// @constructor
 external factory VolumetricLightScatteringPostProcess(String name, dynamic ratio, Camera camera, [Mesh mesh, num samples, num samplingMode, Engine engine, bool reusable, Scene scene]); external String getClassName(); external JS$_isReady(subMesh, useInstances);
 /// Sets the new light position for light scattering effect
 external void setCustomMeshPosition(Vector3 position);
 /// Returns the light position for light scattering effect
 external Vector3 getCustomMeshPosition();
 /// Disposes the internal assets and detaches the post-process from the camera
 external void dispose(Camera camera);
 /// Returns the render target texture used by the post-process
 external RenderTargetTexture getPass(); external JS$_meshExcluded(mesh); external JS$_createPass(scene, ratio); external JS$_updateMeshScreenCoordinates(scene);
 /// Creates a default mesh for the Volumeric Light Scattering post-process
 external static Mesh CreateDefaultMesh(String name, Scene scene); }

 @JS("BABYLON.VRDistortionCorrectionPostProcess" ) class VRDistortionCorrectionPostProcess extends PostProcess { // @Ignore
 VRDistortionCorrectionPostProcess .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_isRightEye; external set JS$_isRightEye(v); external get JS$_distortionFactors; external set JS$_distortionFactors(v); external get JS$_postProcessScaleFactor; external set JS$_postProcessScaleFactor(v); external get JS$_lensCenterOffset; external set JS$_lensCenterOffset(v); external get JS$_scaleIn; external set JS$_scaleIn(v); external get JS$_scaleFactor; external set JS$_scaleFactor(v); external get JS$_lensCenter; external set JS$_lensCenter(v); external factory VRDistortionCorrectionPostProcess(String name, Camera camera, bool isRightEye, VRCameraMetrics vrMetrics); }

 @JS("BABYLON.Sprite" ) class Sprite { // @Ignore
 Sprite .fakeConstructor$() ;
 external String get name; external set name(String v); external Vector3 get position; external set position(Vector3 v); external Color4 get color; external set color(Color4 v); external num get width; external set width(num v); external num get height; external set height(num v); external num get angle; external set angle(num v); external num get cellIndex; external set cellIndex(num v); external num get invertU; external set invertU(num v); external num get invertV; external set invertV(num v); external bool get disposeWhenFinishedAnimating; external set disposeWhenFinishedAnimating(bool v); external List<Animation> get animations; external set animations(List<Animation> v); external bool get isPickable; external set isPickable(bool v); external ActionManager get actionManager; external set actionManager(ActionManager v); external get JS$_animationStarted; external set JS$_animationStarted(v); external get JS$_loopAnimation; external set JS$_loopAnimation(v); external get JS$_fromIndex; external set JS$_fromIndex(v); external get JS$_toIndex; external set JS$_toIndex(v); external get JS$_delay; external set JS$_delay(v); external get JS$_direction; external set JS$_direction(v); external get JS$_manager; external set JS$_manager(v); external get JS$_time; external set JS$_time(v); external get JS$_onAnimationEnd; external set JS$_onAnimationEnd(v); external num get size; external set size(num v); external factory Sprite(String name, SpriteManager manager); external void playAnimation(num from, num to, bool loop, num delay, void onAnimationEnd()); external void stopAnimation(); external void JS$_animate(num deltaTime); external void dispose(); }

 @JS("BABYLON.SpriteManager" ) class SpriteManager { // @Ignore
 SpriteManager .fakeConstructor$() ;
 external String get name; external set name(String v); external List<Sprite> get sprites; external set sprites(List<Sprite> v); external num get renderingGroupId; external set renderingGroupId(num v); external num get layerMask; external set layerMask(num v); external bool get fogEnabled; external set fogEnabled(bool v); external bool get isPickable; external set isPickable(bool v); external num get cellWidth; external set cellWidth(num v); external num get cellHeight; external set cellHeight(num v);
 /// An event triggered when the manager is disposed.
 external Observable<SpriteManager> get onDisposeObservable; external set onDisposeObservable(Observable<SpriteManager> v); external get JS$_onDisposeObserver; external set JS$_onDisposeObserver(v); external VoidFunc0 get onDispose; external set onDispose(VoidFunc0 v); external get JS$_capacity; external set JS$_capacity(v); external get JS$_spriteTexture; external set JS$_spriteTexture(v); external get JS$_epsilon; external set JS$_epsilon(v); external get JS$_scene; external set JS$_scene(v); external get JS$_vertexData; external set JS$_vertexData(v); external get JS$_buffer; external set JS$_buffer(v); external get JS$_vertexBuffers; external set JS$_vertexBuffers(v); external get JS$_indexBuffer; external set JS$_indexBuffer(v); external get JS$_effectBase; external set JS$_effectBase(v); external get JS$_effectFog; external set JS$_effectFog(v); external Texture get texture; external set texture(Texture v); external factory SpriteManager(String name, String imgUrl, num capacity, dynamic cellSize, Scene scene, [num epsilon, num samplingMode]); external JS$_appendSpriteVertex(index, sprite, offsetX, offsetY, rowSize); external PickingInfo/*PickingInfo|Null*/ intersects(Ray ray, Camera camera, [bool predicate(Sprite sprite), bool fastCheck]); external void render(); external void dispose(); }

 /// @hidden
 @JS("BABYLON._AlphaState" ) class JS$_AlphaState { // @Ignore
 JS$_AlphaState .fakeConstructor$() ;
 external get JS$_isAlphaBlendDirty; external set JS$_isAlphaBlendDirty(v); external get JS$_isBlendFunctionParametersDirty; external set JS$_isBlendFunctionParametersDirty(v); external get JS$_isBlendEquationParametersDirty; external set JS$_isBlendEquationParametersDirty(v); external get JS$_isBlendConstantsDirty; external set JS$_isBlendConstantsDirty(v); external get JS$_alphaBlend; external set JS$_alphaBlend(v); external get JS$_blendFunctionParameters; external set JS$_blendFunctionParameters(v); external get JS$_blendEquationParameters; external set JS$_blendEquationParameters(v); external get JS$_blendConstants; external set JS$_blendConstants(v);
 /// Initializes the state.
 external factory JS$_AlphaState(); external bool get isDirty; external set isDirty(bool v); external bool get alphaBlend; external set alphaBlend(bool v); external void setAlphaBlendConstants(num r, num g, num b, num a); external void setAlphaBlendFunctionParameters(num value0, num value1, num value2, num value3); external void setAlphaEquationParameters(num rgb, num alpha); external void reset(); external void apply(RenderingContext gl); }

 /// @hidden
 @JS("BABYLON._DepthCullingState" ) class JS$_DepthCullingState { // @Ignore
 JS$_DepthCullingState .fakeConstructor$() ;
 external get JS$_isDepthTestDirty; external set JS$_isDepthTestDirty(v); external get JS$_isDepthMaskDirty; external set JS$_isDepthMaskDirty(v); external get JS$_isDepthFuncDirty; external set JS$_isDepthFuncDirty(v); external get JS$_isCullFaceDirty; external set JS$_isCullFaceDirty(v); external get JS$_isCullDirty; external set JS$_isCullDirty(v); external get JS$_isZOffsetDirty; external set JS$_isZOffsetDirty(v); external get JS$_isFrontFaceDirty; external set JS$_isFrontFaceDirty(v); external get JS$_depthTest; external set JS$_depthTest(v); external get JS$_depthMask; external set JS$_depthMask(v); external get JS$_depthFunc; external set JS$_depthFunc(v); external get JS$_cull; external set JS$_cull(v); external get JS$_cullFace; external set JS$_cullFace(v); external get JS$_zOffset; external set JS$_zOffset(v); external get JS$_frontFace; external set JS$_frontFace(v);
 /// Initializes the state.
 external factory JS$_DepthCullingState(); external bool get isDirty; external set isDirty(bool v); external num get zOffset; external set zOffset(num v); external num/*num|Null*/ get cullFace; external set cullFace(num/*num|Null*/ v); external bool/*bool|Null*/ get cull; external set cull(bool/*bool|Null*/ v); external num/*num|Null*/ get depthFunc; external set depthFunc(num/*num|Null*/ v); external bool get depthMask; external set depthMask(bool v); external bool get depthTest; external set depthTest(bool v); external num/*num|Null*/ get frontFace; external set frontFace(num/*num|Null*/ v); external void reset(); external void apply(RenderingContext gl); }

 /// @hidden
 @JS("BABYLON._StencilState" ) class JS$_StencilState { // @Ignore
 JS$_StencilState .fakeConstructor$() ;
 external get JS$_isStencilTestDirty; external set JS$_isStencilTestDirty(v); external get JS$_isStencilMaskDirty; external set JS$_isStencilMaskDirty(v); external get JS$_isStencilFuncDirty; external set JS$_isStencilFuncDirty(v); external get JS$_isStencilOpDirty; external set JS$_isStencilOpDirty(v); external get JS$_stencilTest; external set JS$_stencilTest(v); external get JS$_stencilMask; external set JS$_stencilMask(v); external get JS$_stencilFunc; external set JS$_stencilFunc(v); external get JS$_stencilFuncRef; external set JS$_stencilFuncRef(v); external get JS$_stencilFuncMask; external set JS$_stencilFuncMask(v); external get JS$_stencilOpStencilFail; external set JS$_stencilOpStencilFail(v); external get JS$_stencilOpDepthFail; external set JS$_stencilOpDepthFail(v); external get JS$_stencilOpStencilDepthPass; external set JS$_stencilOpStencilDepthPass(v); external bool get isDirty; external set isDirty(bool v); external num get stencilFunc; external set stencilFunc(num v); external num get stencilFuncRef; external set stencilFuncRef(num v); external num get stencilFuncMask; external set stencilFuncMask(num v); external num get stencilOpStencilFail; external set stencilOpStencilFail(num v); external num get stencilOpDepthFail; external set stencilOpDepthFail(num v); external num get stencilOpStencilDepthPass; external set stencilOpStencilDepthPass(num v); external num get stencilMask; external set stencilMask(num v); external bool get stencilTest; external set stencilTest(bool v); external factory JS$_StencilState(); external void reset(); external void apply(RenderingContext gl); }

 /// Class used to evalaute queries containing `and` and `or` operators
 @JS("BABYLON.AndOrNotEvaluator" ) class AndOrNotEvaluator { // @Ignore
 AndOrNotEvaluator .fakeConstructor$() ;
 /// Evaluate a query
 external static bool Eval(String query, bool evaluateCallback(dynamic val)); external static JS$_HandleParenthesisContent(parenthesisContent, evaluateCallback); external static JS$_SimplifyNegation(booleanString); }

 /// Defines the list of states available for a task inside a {BABYLON.AssetsManager}
 @JS("BABYLON.AssetTaskState" ) class AssetTaskState { external static num get
 /// Initialization
 INIT; external static num get
 /// Running
 RUNNING; external static num get
 /// Done
 DONE; external static num get
 /// Error
 ERROR; }
 /// Define an abstract asset task used with a {BABYLON.AssetsManager} class to load assets into a scene
 @JS("BABYLON.AbstractAssetTask" ) abstract class AbstractAssetTask { // @Ignore
 AbstractAssetTask .fakeConstructor$() ;
 /// Task name
 external String get name; external set name(String v);
 /// Callback called when the task is successful
 external VoidFunc1<dynamic> get onSuccess; external set onSuccess(VoidFunc1<dynamic> v);
 /// Callback called when the task is not successful
 external Function/*(task: any, message?: string, exception?: any) => void*/ get onError; external set onError(Function/*(task: any, message?: string, exception?: any) => void*/ v);
 /// Creates a new {BABYLON.AssetsManager}
 external factory AbstractAssetTask(
 /// Task name
 String name); external get JS$_isCompleted; external set JS$_isCompleted(v); external get JS$_taskState; external set JS$_taskState(v); external get JS$_errorObject; external set JS$_errorObject(v);
 /// Get if the task is completed
 external bool get isCompleted; external set isCompleted(bool v);
 /// Gets the current state of the task
 external num/*enum AssetTaskState*/ get taskState; external set taskState(num/*enum AssetTaskState*/ v);
 /// Gets the current error object (if task is in error)
 external dynamic/*{
            message?: string;
            exception?: any;
        }*/ get errorObject; external set errorObject(dynamic/*{
            message?: string;
            exception?: any;
        }*/ v);
 /// Internal only
 /// @hidden
 external void JS$_setErrorObject([String message, dynamic exception]);
 /// Execute the current task
 external void run(Scene scene, void onSuccess(), void onError([String message, dynamic exception]));
 /// Execute the current task
 external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception])); external onErrorCallback(onError, [message, exception]); external onDoneCallback(onSuccess, onError); }

 /// Define the interface used by progress events raised during assets loading
 @anonymous @JS() abstract class IAssetsProgressEvent {
 /// Defines the number of remaining tasks to process
 external num get remainingCount; external set remainingCount(num v);
 /// Defines the total number of tasks
 external num get totalCount; external set totalCount(num v);
 /// Defines the task that was just processed
 external AbstractAssetTask get task; external set task(AbstractAssetTask v); external factory IAssetsProgressEvent({ num remainingCount, num totalCount, AbstractAssetTask task}); }

 /// Class used to share progress information about assets loading
 @JS("BABYLON.AssetsProgressEvent" ) class AssetsProgressEvent implements IAssetsProgressEvent { // @Ignore
 AssetsProgressEvent .fakeConstructor$() ;
 /// Defines the number of remaining tasks to process
 external num get remainingCount; external set remainingCount(num v);
 /// Defines the total number of tasks
 external num get totalCount; external set totalCount(num v);
 /// Defines the task that was just processed
 external AbstractAssetTask get task; external set task(AbstractAssetTask v);
 /// Creates a {BABYLON.AssetsProgressEvent}
 external factory AssetsProgressEvent(num remainingCount, num totalCount, AbstractAssetTask task); }

 /// Define a task used by {BABYLON.AssetsManager} to load meshes
 @JS("BABYLON.MeshAssetTask" ) class MeshAssetTask extends AbstractAssetTask { // @Ignore
 MeshAssetTask .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the name of the task
 external String get name; external set name(String v);
 /// Defines the list of mesh's names you want to load
 external dynamic get meshesNames; external set meshesNames(dynamic v);
 /// Defines the root url to use as a base to load your meshes and associated resources
 external String get rootUrl; external set rootUrl(String v);
 /// Defines the filename of the scene to load from
 external String get sceneFilename; external set sceneFilename(String v);
 /// Gets the list of loaded meshes
 external List<AbstractMesh> get loadedMeshes; external set loadedMeshes(List<AbstractMesh> v);
 /// Gets the list of loaded particle systems
 external List<ParticleSystem> get loadedParticleSystems; external set loadedParticleSystems(List<ParticleSystem> v);
 /// Gets the list of loaded skeletons
 external List<Skeleton> get loadedSkeletons; external set loadedSkeletons(List<Skeleton> v);
 /// Callback called when the task is successful
 external VoidFunc1<MeshAssetTask> get onSuccess; external set onSuccess(VoidFunc1<MeshAssetTask> v);
 /// Callback called when the task is successful
 external Function/*(task: MeshAssetTask, message?: string, exception?: any) => void*/ get onError; external set onError(Function/*(task: MeshAssetTask, message?: string, exception?: any) => void*/ v);
 /// Creates a new {BABYLON.MeshAssetTask}
 external factory MeshAssetTask(
 /// Defines the name of the task
 String name,
 /// Defines the list of mesh's names you want to load
 dynamic meshesNames,
 /// Defines the root url to use as a base to load your meshes and associated resources
 String rootUrl,
 /// Defines the filename of the scene to load from
 String sceneFilename);
 /// Execute the current task
 external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception])); }

 /// Define a task used by {BABYLON.AssetsManager} to load text content
 @JS("BABYLON.TextFileAssetTask" ) class TextFileAssetTask extends AbstractAssetTask { // @Ignore
 TextFileAssetTask .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the name of the task
 external String get name; external set name(String v);
 /// Defines the location of the file to load
 external String get url; external set url(String v);
 /// Gets the loaded text string
 external String get text; external set text(String v);
 /// Callback called when the task is successful
 external VoidFunc1<TextFileAssetTask> get onSuccess; external set onSuccess(VoidFunc1<TextFileAssetTask> v);
 /// Callback called when the task is successful
 external Function/*(task: TextFileAssetTask, message?: string, exception?: any) => void*/ get onError; external set onError(Function/*(task: TextFileAssetTask, message?: string, exception?: any) => void*/ v);
 /// Creates a new TextFileAssetTask object
 external factory TextFileAssetTask(
 /// Defines the name of the task
 String name,
 /// Defines the location of the file to load
 String url);
 /// Execute the current task
 external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception])); }

 /// Define a task used by {BABYLON.AssetsManager} to load binary data
 @JS("BABYLON.BinaryFileAssetTask" ) class BinaryFileAssetTask extends AbstractAssetTask { // @Ignore
 BinaryFileAssetTask .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the name of the task
 external String get name; external set name(String v);
 /// Defines the location of the file to load
 external String get url; external set url(String v);
 /// Gets the lodaded data (as an array buffer)
 external ByteBuffer get data; external set data(ByteBuffer v);
 /// Callback called when the task is successful
 external VoidFunc1<BinaryFileAssetTask> get onSuccess; external set onSuccess(VoidFunc1<BinaryFileAssetTask> v);
 /// Callback called when the task is successful
 external Function/*(task: BinaryFileAssetTask, message?: string, exception?: any) => void*/ get onError; external set onError(Function/*(task: BinaryFileAssetTask, message?: string, exception?: any) => void*/ v);
 /// Creates a new BinaryFileAssetTask object
 external factory BinaryFileAssetTask(
 /// Defines the name of the task
 String name,
 /// Defines the location of the file to load
 String url);
 /// Execute the current task
 external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception])); }

 /// Define a task used by {BABYLON.AssetsManager} to load images
 @JS("BABYLON.ImageAssetTask" ) class ImageAssetTask extends AbstractAssetTask { // @Ignore
 ImageAssetTask .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the name of the task
 external String get name; external set name(String v);
 /// Defines the location of the image to load
 external String get url; external set url(String v);
 /// Gets the loaded images
 external ImageElement get image; external set image(ImageElement v);
 /// Callback called when the task is successful
 external VoidFunc1<ImageAssetTask> get onSuccess; external set onSuccess(VoidFunc1<ImageAssetTask> v);
 /// Callback called when the task is successful
 external Function/*(task: ImageAssetTask, message?: string, exception?: any) => void*/ get onError; external set onError(Function/*(task: ImageAssetTask, message?: string, exception?: any) => void*/ v);
 /// Creates a new ImageAssetTask
 external factory ImageAssetTask(
 /// Defines the name of the task
 String name,
 /// Defines the location of the image to load
 String url);
 /// Execute the current task
 external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception])); }

 /// Defines the interface used by texture loading tasks
 @anonymous @JS() abstract class ITextureAssetTask <TEX extends BaseTexture > {
 /// Gets the loaded texture
 external TEX get texture; external set texture(TEX v); external factory ITextureAssetTask({ TEX texture}); }

 /// Define a task used by {BABYLON.AssetsManager} to load 2D textures
 @JS("BABYLON.TextureAssetTask" ) class TextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<Texture> { // @Ignore
 TextureAssetTask .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the name of the task
 external String get name; external set name(String v);
 /// Defines the location of the file to load
 external String get url; external set url(String v);
 /// Defines if mipmap should not be generated (default is false)
 external dynamic/*bool|dynamic*/ get noMipmap; external set noMipmap(dynamic/*bool|dynamic*/ v);
 /// Defines if texture must be inverted on Y axis (default is false)
 external dynamic/*bool|dynamic*/ get invertY; external set invertY(dynamic/*bool|dynamic*/ v);
 /// Defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)
 external num get samplingMode; external set samplingMode(num v);
 /// Gets the loaded texture
 external Texture get texture; external set texture(Texture v);
 /// Callback called when the task is successful
 external VoidFunc1<TextureAssetTask> get onSuccess; external set onSuccess(VoidFunc1<TextureAssetTask> v);
 /// Callback called when the task is successful
 external Function/*(task: TextureAssetTask, message?: string, exception?: any) => void*/ get onError; external set onError(Function/*(task: TextureAssetTask, message?: string, exception?: any) => void*/ v);
 /// Creates a new TextureAssetTask object
 external factory TextureAssetTask(
 /// Defines the name of the task
 String name,
 /// Defines the location of the file to load
 String url, [
 /// Defines if mipmap should not be generated (default is false)
 dynamic/*bool|dynamic*/ noMipmap,
 /// Defines if texture must be inverted on Y axis (default is false)
 dynamic/*bool|dynamic*/ invertY,
 /// Defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)
 num samplingMode]);
 /// Execute the current task
 external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception])); }

 /// Define a task used by {BABYLON.AssetsManager} to load cube textures
 @JS("BABYLON.CubeTextureAssetTask" ) class CubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<CubeTexture> { // @Ignore
 CubeTextureAssetTask .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the name of the task
 external String get name; external set name(String v);
 /// Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
 external String get url; external set url(String v);
 /// Defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
 external dynamic/*List<String>|dynamic*/ get extensions; external set extensions(dynamic/*List<String>|dynamic*/ v);
 /// Defines if mipmaps should not be generated (default is false)
 external dynamic/*bool|dynamic*/ get noMipmap; external set noMipmap(dynamic/*bool|dynamic*/ v);
 /// Defines the explicit list of files (undefined by default)
 external dynamic/*List<String>|dynamic*/ get files; external set files(dynamic/*List<String>|dynamic*/ v);
 /// Gets the loaded texture
 external CubeTexture get texture; external set texture(CubeTexture v);
 /// Callback called when the task is successful
 external VoidFunc1<CubeTextureAssetTask> get onSuccess; external set onSuccess(VoidFunc1<CubeTextureAssetTask> v);
 /// Callback called when the task is successful
 external Function/*(task: CubeTextureAssetTask, message?: string, exception?: any) => void*/ get onError; external set onError(Function/*(task: CubeTextureAssetTask, message?: string, exception?: any) => void*/ v);
 /// Creates a new CubeTextureAssetTask
 external factory CubeTextureAssetTask(
 /// Defines the name of the task
 String name,
 /// Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
 String url, [
 /// Defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
 dynamic/*List<String>|dynamic*/ extensions,
 /// Defines if mipmaps should not be generated (default is false)
 dynamic/*bool|dynamic*/ noMipmap,
 /// Defines the explicit list of files (undefined by default)
 dynamic/*List<String>|dynamic*/ files]);
 /// Execute the current task
 external void runTask(Scene scene, void onSuccess(), void onError([String message, dynamic exception])); }

 /// Define a task used by {BABYLON.AssetsManager} to load HDR cube textures
 @JS("BABYLON.HDRCubeTextureAssetTask" ) class HDRCubeTextureAssetTask extends AbstractAssetTask implements ITextureAssetTask<HDRCubeTexture> { // @Ignore
 HDRCubeTextureAssetTask .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the name of the task
 external String get name; external set name(String v);
 /// Defines the location of the file to load
 external String get url; external set url(String v);
 /// Defines the desired size (the more it increases the longer the generation will be)
 external num get size; external set size(num v);
 /// Defines if mipmaps should not be generated (default is false)
 external bool get noMipmap; external set noMipmap(bool v);
 /// Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
 external bool get generateHarmonics; external set generateHarmonics(bool v);
 /// Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
 external bool get gammaSpace; external set gammaSpace(bool v);
 /// Internal Use Only
 external bool get reserved; external set reserved(bool v);
 /// Gets the loaded texture
 external HDRCubeTexture get texture; external set texture(HDRCubeTexture v);
 /// Callback called when the task is successful
 external VoidFunc1<HDRCubeTextureAssetTask> get onSuccess; external set onSuccess(VoidFunc1<HDRCubeTextureAssetTask> v);
 /// Callback called when the task is successful
 external Function/*(task: HDRCubeTextureAssetTask, message?: string, exception?: any) => void*/ get onError; external set onError(Function/*(task: HDRCubeTextureAssetTask, message?: string, exception?: any) => void*/ v);
 /// Creates a new HDRCubeTextureAssetTask object
 external factory HDRCubeTextureAssetTask(
 /// Defines the name of the task
 String name,
 /// Defines the location of the file to load
 String url,
 /// Defines the desired size (the more it increases the longer the generation will be)
 num size, [
 /// Defines if mipmaps should not be generated (default is false)
 bool noMipmap,
 /// Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
 bool generateHarmonics,
 /// Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
 bool gammaSpace,
 /// Internal Use Only
 bool reserved]);
 /// Execute the current task
 external void run(Scene scene, void onSuccess(), void onError([String message, dynamic exception])); }

 /// This class can be used to easily import assets into a scene
 /// @see http://doc.babylonjs.com/how_to/how_to_use_assetsmanager
 @JS("BABYLON.AssetsManager" ) class AssetsManager { // @Ignore
 AssetsManager .fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_isLoading; external set JS$_isLoading(v); external List<AbstractAssetTask> get JS$_tasks; external set JS$_tasks(List<AbstractAssetTask> v); external num get JS$_waitingTasksCount; external set JS$_waitingTasksCount(num v); external num get JS$_totalTasksCount; external set JS$_totalTasksCount(num v);
 /// Callback called when all tasks are processed
 external VoidFunc1<List<AbstractAssetTask>> get onFinish; external set onFinish(VoidFunc1<List<AbstractAssetTask>> v);
 /// Callback called when a task is successful
 external VoidFunc1<AbstractAssetTask> get onTaskSuccess; external set onTaskSuccess(VoidFunc1<AbstractAssetTask> v);
 /// Callback called when a task had an error
 external VoidFunc1<AbstractAssetTask> get onTaskError; external set onTaskError(VoidFunc1<AbstractAssetTask> v);
 /// Callback called when a task is done (whatever the result is)
 external VoidFunc3<num, num, AbstractAssetTask> get onProgress; external set onProgress(VoidFunc3<num, num, AbstractAssetTask> v);
 /// Observable called when all tasks are processed
 external Observable<AbstractAssetTask> get onTaskSuccessObservable; external set onTaskSuccessObservable(Observable<AbstractAssetTask> v);
 /// Observable called when a task had an error
 external Observable<AbstractAssetTask> get onTaskErrorObservable; external set onTaskErrorObservable(Observable<AbstractAssetTask> v);
 /// Observable called when a task is successful
 external Observable<List<AbstractAssetTask>> get onTasksDoneObservable; external set onTasksDoneObservable(Observable<List<AbstractAssetTask>> v);
 /// Observable called when a task is done (whatever the result is)
 external Observable<IAssetsProgressEvent> get onProgressObservable; external set onProgressObservable(Observable<IAssetsProgressEvent> v);
 /// Gets or sets a boolean defining if the {BABYLON.AssetsManager} should use the default loading screen
 /// @see http://doc.babylonjs.com/how_to/creating_a_custom_loading_screen
 external bool get useDefaultLoadingScreen; external set useDefaultLoadingScreen(bool v);
 /// Creates a new AssetsManager
 external factory AssetsManager(Scene scene);
 /// Add a {BABYLON.MeshAssetTask} to the list of active tasks
 external MeshAssetTask addMeshTask(String taskName, dynamic meshesNames, String rootUrl, String sceneFilename);
 /// Add a {BABYLON.TextFileAssetTask} to the list of active tasks
 external TextFileAssetTask addTextFileTask(String taskName, String url);
 /// Add a {BABYLON.BinaryFileAssetTask} to the list of active tasks
 external BinaryFileAssetTask addBinaryFileTask(String taskName, String url);
 /// Add a {BABYLON.ImageAssetTask} to the list of active tasks
 external ImageAssetTask addImageTask(String taskName, String url);
 /// Add a {BABYLON.TextureAssetTask} to the list of active tasks
 external TextureAssetTask addTextureTask(String taskName, String url, [bool noMipmap, bool invertY, num samplingMode]);
 /// Add a {BABYLON.CubeTextureAssetTask} to the list of active tasks
 external CubeTextureAssetTask addCubeTextureTask(String taskName, String url, [List<String> extensions, bool noMipmap, List<String> files]);
 /// Add a {BABYLON.HDRCubeTextureAssetTask} to the list of active tasks
 external HDRCubeTextureAssetTask addHDRCubeTextureTask(String taskName, String url, num size, [bool noMipmap, bool generateHarmonics, bool gammaSpace, bool reserved]); external JS$_decreaseWaitingTasksCount(task); external JS$_runTask(task);
 /// Reset the {BABYLON.AssetsManager} and remove all tasks
 external AssetsManager reset();
 /// Start the loading process
 external AssetsManager load(); }

 /// Class used to enable access to IndexedDB
 /// @see @https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
 @JS("BABYLON.Database" ) class Database { // @Ignore
 Database .fakeConstructor$() ;
 external get callbackManifestChecked; external set callbackManifestChecked(v); external get currentSceneUrl; external set currentSceneUrl(v); external get db; external set db(v); external get JS$_enableSceneOffline; external set JS$_enableSceneOffline(v); external get JS$_enableTexturesOffline; external set JS$_enableTexturesOffline(v); external get manifestVersionFound; external set manifestVersionFound(v); external get mustUpdateRessources; external set mustUpdateRessources(v); external get hasReachedQuota; external set hasReachedQuota(v); external get isSupported; external set isSupported(v); external get idbFactory; external set idbFactory(v);
 /// Gets a boolean indicating if the user agent supports blob storage (this value will be updated after creating the first Database object)
 external static bool get IsUASupportingBlobStorage; external static set IsUASupportingBlobStorage(bool v);
 /// Gets a boolean indicating if Database storate is enabled
 external static bool get IDBStorageEnabled; external static set IDBStorageEnabled(bool v);
 /// Gets a boolean indicating if scene must be saved in the database
 external bool get enableSceneOffline; external set enableSceneOffline(bool v);
 /// Gets a boolean indicating if textures must be saved in the database
 external bool get enableTexturesOffline; external set enableTexturesOffline(bool v);
 /// Creates a new Database
 external factory Database(String urlToScene, dynamic callbackManifestChecked(bool checked), [bool disableManifestCheck]); external static get JS$_ParseURL; external static set JS$_ParseURL(v); external static get JS$_ReturnFullUrlLocation; external static set JS$_ReturnFullUrlLocation(v); external JS$_checkManifestFile();
 /// Open the database and make it available
 external void openAsync(void successCallback(), void errorCallback());
 /// Loads an image from the database
 external void loadImageFromDB(String url, ImageElement image); external JS$_loadImageFromDBAsync(url, image, notInDBCallback); external JS$_saveImageIntoDBAsync(url, image); external JS$_checkVersionFromDB(url, versionLoaded); external JS$_loadVersionFromDBAsync(url, callback, updateInDBCallback); external JS$_saveVersionIntoDBAsync(url, callback);
 /// Loads a file from database
 external void loadFileFromDB(String url, void sceneLoaded(dynamic data), [void progressCallBack(dynamic data), void errorCallback(), bool useArrayBuffer]); external JS$_loadFileFromDBAsync(url, callback, notInDBCallback, [useArrayBuffer]); external JS$_saveFileIntoDBAsync(url, callback, [progressCallback, useArrayBuffer]); }

 @anonymous @JS() abstract class DDSInfo { external num get width; external set width(num v); external num get height; external set height(num v); external num get mipmapCount; external set mipmapCount(num v); external bool get isFourCC; external set isFourCC(bool v); external bool get isRGB; external set isRGB(bool v); external bool get isLuminance; external set isLuminance(bool v); external bool get isCube; external set isCube(bool v); external bool get isCompressed; external set isCompressed(bool v); external num get dxgiFormat; external set dxgiFormat(num v); external num get textureType; external set textureType(num v);
 /// Sphericle polynomial created for the dds texture
 external SphericalPolynomial get sphericalPolynomial; external set sphericalPolynomial(SphericalPolynomial v); external factory DDSInfo({ num width, num height, num mipmapCount, bool isFourCC, bool isRGB, bool isLuminance, bool isCube, bool isCompressed, num dxgiFormat, num textureType, SphericalPolynomial sphericalPolynomial}); }

 @JS("BABYLON.DDSTools" ) class DDSTools { // @Ignore
 DDSTools .fakeConstructor$() ;
 external static bool get StoreLODInAlphaChannel; external static set StoreLODInAlphaChannel(bool v); external static DDSInfo GetDDSInfo(dynamic arrayBuffer); external static get JS$_FloatView; external static set JS$_FloatView(v); external static get JS$_Int32View; external static set JS$_Int32View(v); external static JS$_ToHalfFloat(value); external static JS$_FromHalfFloat(value); external static JS$_GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod); external static JS$_GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod); external static JS$_GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod); external static JS$_GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod); external static JS$_GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod); external static JS$_GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset); external static JS$_ExtractLongWordOrder(value); external static JS$_GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset); external static JS$_GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer); external static void UploadDDSLevels(Engine engine, RenderingContext gl, dynamic arrayBuffer, DDSInfo info, bool loadMipmaps, num faces, [num lodIndex, num currentFace]); }

 @JS("BABYLON.expandToProperty" ) external VoidFunc2<dynamic, String> expandToProperty(String callback, [String/*String|Null*/ targetKey]); @JS("BABYLON.serialize" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serialize([String sourceName]); @JS("BABYLON.serializeAsTexture" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsTexture([String sourceName]); @JS("BABYLON.serializeAsColor3" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsColor3([String sourceName]); @JS("BABYLON.serializeAsFresnelParameters" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsFresnelParameters([String sourceName]); @JS("BABYLON.serializeAsVector2" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsVector2([String sourceName]); @JS("BABYLON.serializeAsVector3" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsVector3([String sourceName]); @JS("BABYLON.serializeAsMeshReference" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsMeshReference([String sourceName]); @JS("BABYLON.serializeAsColorCurves" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsColorCurves([String sourceName]); @JS("BABYLON.serializeAsColor4" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsColor4([String sourceName]); @JS("BABYLON.serializeAsImageProcessingConfiguration" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsImageProcessingConfiguration([String sourceName]); @JS("BABYLON.serializeAsQuaternion" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsQuaternion([String sourceName]);
 /// Decorator used to define property that can be serialized as reference to a camera
 @JS("BABYLON.serializeAsCameraReference" ) external VoidFunc2<dynamic, dynamic/*String|dynamic*/> serializeAsCameraReference([String sourceName]); @JS("BABYLON.SerializationHelper" ) class SerializationHelper { // @Ignore
 SerializationHelper .fakeConstructor$() ;
 external static dynamic Serialize /*<T>*/(dynamic/*=T*/ entity, [dynamic serializationObject]); external static dynamic/*=T*/ Parse /*<T>*/(dynamic/*=T*/ creationFunction(), dynamic source, Scene/*Scene|Null*/ scene, [String/*String|Null*/ rootUrl]); external static dynamic/*=T*/ Clone /*<T>*/(dynamic/*=T*/ creationFunction(), dynamic/*=T*/ source); external static dynamic/*=T*/ Instanciate /*<T>*/(dynamic/*=T*/ creationFunction(), dynamic/*=T*/ source); }

 /// Wrapper class for promise with external resolve and reject.
 @JS("BABYLON.Deferred" ) class Deferred <T > { // @Ignore
 Deferred .fakeConstructor$() ;
 /// The promise associated with this deferred object.
 external Promise<T> get promise; external set promise(Promise<T> v); external get JS$_resolve; external set JS$_resolve(v); external get JS$_reject; external set JS$_reject(v);
 /// The resolve method of the promise associated with this deferred object.
 external VoidFunc1Opt1<dynamic/*T|PromiseLike<T>|dynamic*/> get resolve; external set resolve(VoidFunc1Opt1<dynamic/*T|PromiseLike<T>|dynamic*/> v);
 /// The reject method of the promise associated with this deferred object.
 external VoidFunc1Opt1<dynamic> get reject; external set reject(VoidFunc1Opt1<dynamic> v);
 /// Constructor for this deferred object.
 external factory Deferred(); }

 @JS("BABYLON.FilesInput" ) class FilesInput { // @Ignore
 FilesInput .fakeConstructor$() ;
 external static dynamic/*JSMap of <String,File>*/ get FilesToLoad; external static set FilesToLoad(dynamic/*JSMap of <String,File>*/ v); external Func3<File, String, String, > get onProcessFileCallback; external set onProcessFileCallback(Func3<File, String, String, > v); external get JS$_engine; external set JS$_engine(v); external get JS$_currentScene; external set JS$_currentScene(v); external get JS$_sceneLoadedCallback; external set JS$_sceneLoadedCallback(v); external get JS$_progressCallback; external set JS$_progressCallback(v); external get JS$_additionalRenderLoopLogicCallback; external set JS$_additionalRenderLoopLogicCallback(v); external get JS$_textureLoadingCallback; external set JS$_textureLoadingCallback(v); external get JS$_startingProcessingFilesCallback; external set JS$_startingProcessingFilesCallback(v); external get JS$_onReloadCallback; external set JS$_onReloadCallback(v); external get JS$_errorCallback; external set JS$_errorCallback(v); external get JS$_elementToMonitor; external set JS$_elementToMonitor(v); external get JS$_sceneFileToLoad; external set JS$_sceneFileToLoad(v); external get JS$_filesToLoad; external set JS$_filesToLoad(v); external factory FilesInput(Engine engine, Scene scene, void sceneLoadedCallback(File sceneFile, Scene scene), void progressCallback(SceneLoaderProgressEvent progress), void additionalRenderLoopLogicCallback(), void textureLoadingCallback(num remaining), void startingProcessingFilesCallback(), void onReloadCallback(File sceneFile), void errorCallback(File sceneFile, Scene scene, String message)); external get JS$_dragEnterHandler; external set JS$_dragEnterHandler(v); external get JS$_dragOverHandler; external set JS$_dragOverHandler(v); external get JS$_dropHandler; external set JS$_dropHandler(v); external void monitorElementForDragNDrop(HtmlElement elementToMonitor); external void dispose(); external renderFunction(); external drag(e); external drop(eventDrop); external JS$_traverseFolder(folder, files, remaining, callback); external JS$_processFiles(files); external void loadFiles(dynamic event); external JS$_processReload(); external void reload(); }

 /// for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 /// for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 @JS("BABYLON.KhronosTextureContainer" ) class KhronosTextureContainer { // @Ignore
 KhronosTextureContainer .fakeConstructor$() ;
 external dynamic get arrayBuffer; external set arrayBuffer(dynamic v); external static num get HEADER_LEN; external static set HEADER_LEN(num v); external static num get COMPRESSED_2D; external static set COMPRESSED_2D(num v); external static num get COMPRESSED_3D; external static set COMPRESSED_3D(num v); external static num get TEX_2D; external static set TEX_2D(num v); external static num get TEX_3D; external static set TEX_3D(num v); external num get glType; external set glType(num v); external num get glTypeSize; external set glTypeSize(num v); external num get glFormat; external set glFormat(num v); external num get glInternalFormat; external set glInternalFormat(num v); external num get glBaseInternalFormat; external set glBaseInternalFormat(num v); external num get pixelWidth; external set pixelWidth(num v); external num get pixelHeight; external set pixelHeight(num v); external num get pixelDepth; external set pixelDepth(num v); external num get numberOfArrayElements; external set numberOfArrayElements(num v); external num get numberOfFaces; external set numberOfFaces(num v); external num get numberOfMipmapLevels; external set numberOfMipmapLevels(num v); external num get bytesOfKeyValueData; external set bytesOfKeyValueData(num v); external num get loadType; external set loadType(num v);
 external factory KhronosTextureContainer(dynamic arrayBuffer, num facesExpected, [bool threeDExpected, bool textureArrayExpected]); external num switchEndainness(num val);
 /// It is assumed that the texture has already been created & is currently bound
 external void uploadLevels(RenderingContext gl, bool loadMipmaps); external JS$_upload2DCompressedLevels(gl, loadMipmaps); }

 /// A class serves as a medium between the observable and its observers
 @JS("BABYLON.EventState" ) class EventState { // @Ignore
 EventState .fakeConstructor$() ;
 /// Create a new EventState
 external factory EventState(num mask, [bool skipNextObservers, dynamic target, dynamic currentTarget]);
 /// Initialize the current event state
 external EventState initalize(num mask, [bool skipNextObservers, dynamic target, dynamic currentTarget]);
 /// An Observer can set this property to true to prevent subsequent observers of being notified
 external bool get skipNextObservers; external set skipNextObservers(bool v);
 /// Get the mask value that were used to trigger the event corresponding to this EventState object
 external num get mask; external set mask(num v);
 /// The object that originally notified the event
 external dynamic get target; external set target(dynamic v);
 /// The current object in the bubbling phase
 external dynamic get currentTarget; external set currentTarget(dynamic v);
 /// This will be populated with the return value of the last function that was executed.
 /// If it is the first function in the callback chain it will be the event data.
 external dynamic get lastReturnValue; external set lastReturnValue(dynamic v); }

 /// Represent an Observer registered to a given Observable object.
 @JS("BABYLON.Observer" ) class Observer <T > { // @Ignore
 Observer .fakeConstructor$() ;
 /// Defines the callback to call when the observer is notified
 external VoidFunc2<T, EventState> get callback; external set callback(VoidFunc2<T, EventState> v);
 /// Defines the mask of the observer (used to filter notifications)
 external num get mask; external set mask(num v);
 /// Defines the current scope used to restore the JS context
 external dynamic get scope; external set scope(dynamic v);
 /// @hidden
 external bool get JS$_willBeUnregistered; external set JS$_willBeUnregistered(bool v);
 /// Gets or sets a property defining that the observer as to be unregistered after the next notification
 external bool get unregisterOnNextCall; external set unregisterOnNextCall(bool v);
 /// Creates a new observer
 external factory Observer(
 /// Defines the callback to call when the observer is notified
 void callback(T eventData, EventState eventState),
 /// Defines the mask of the observer (used to filter notifications)
 num mask, [
 /// Defines the current scope used to restore the JS context
 dynamic scope]); }

 /// Represent a list of observers registered to multiple Observables object.
 @JS("BABYLON.MultiObserver" ) class MultiObserver <T > { // @Ignore
 MultiObserver .fakeConstructor$() ;
 external get JS$_observers; external set JS$_observers(v); external get JS$_observables; external set JS$_observables(v);
 /// Release associated resources
 external void dispose();
 /// Raise a callback when one of the observable will notify
 external static MultiObserver<dynamic/*=T*/> Watch /*<T>*/(List<Observable<dynamic/*=T*/>> observables, void callback(dynamic/*=T*/ eventData, EventState eventState), [num mask, dynamic scope]); }

 /// The Observable class is a simple implementation of the Observable pattern.
 /// There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
 /// This enable a more fine grained execution without having to rely on multiple different Observable objects.
 /// For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
 /// A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
 @JS("BABYLON.Observable" ) class Observable <T > { // @Ignore
 Observable .fakeConstructor$() ;
 external get JS$_observers; external set JS$_observers(v); external get JS$_eventState; external set JS$_eventState(v); external get JS$_onObserverAdded; external set JS$_onObserverAdded(v);
 /// Creates a new observable
 external factory Observable([void onObserverAdded(Observer<T> observer)]);
 /// Create a new Observer with the specified callback
 external Observer<T>/*Observer<T>|Null*/ add(void callback(T eventData, EventState eventState), [num mask, bool insertFirst, dynamic scope, bool unregisterOnFirstCall]);
 /// Remove an Observer from the Observable object
 external bool remove(Observer<T>/*Observer<T>|Null*/ observer);
 /// Remove a callback from the Observable object
 external bool removeCallback(void callback(T eventData, EventState eventState), [dynamic scope]); external JS$_deferUnregister(observer);
 /// Notify all Observers by calling their respective callback with the given data
 /// Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
 external bool notifyObservers(T eventData, [num mask, dynamic target, dynamic currentTarget]);
 /// Calling this will execute each callback, expecting it to be a promise or return a value.
 /// If at any point in the chain one function fails, the promise will fail and the execution will not continue.
 /// This is useful when a chain of events (sometimes async events) is needed to initialize a certain object
 /// and it is crucial that all callbacks will be executed.
 /// The order of the callbacks is kept, callbacks are not executed parallel.
 external Promise<T> notifyObserversWithPromise(T eventData, [num mask, dynamic target, dynamic currentTarget]);
 /// Notify a specific observer
 external void notifyObserver(Observer<T> observer, T eventData, [num mask]);
 /// Gets a boolean indicating if the observable has at least one observer
 external bool hasObservers();
 /// Clear the list of observers
 external void clear();
 /// Clone the current observable
 external Observable<T> clone();
 /// Does this observable handles observer registered with a given mask
 external bool hasSpecificMask([num mask]); }

 /// Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window
 @JS("BABYLON.PerformanceMonitor" ) class PerformanceMonitor { // @Ignore
 PerformanceMonitor .fakeConstructor$() ;
 external get JS$_enabled; external set JS$_enabled(v); external get JS$_rollingFrameTime; external set JS$_rollingFrameTime(v); external get JS$_lastFrameTimeMs; external set JS$_lastFrameTimeMs(v);
 /// constructor
 external factory PerformanceMonitor([num frameSampleSize]);
 /// Samples current frame
 external void sampleFrame([num timeMs]);
 /// Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
 external num get averageFrameTime; external set averageFrameTime(num v);
 /// Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
 external num get averageFrameTimeVariance; external set averageFrameTimeVariance(num v);
 /// Returns the frame time of the most recent frame
 external num get instantaneousFrameTime; external set instantaneousFrameTime(num v);
 /// Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
 external num get averageFPS; external set averageFPS(num v);
 /// Returns the average framerate in frames per second using the most recent frame time
 external num get instantaneousFPS; external set instantaneousFPS(num v);
 /// Returns true if enough samples have been taken to completely fill the sliding window
 external bool get isSaturated; external set isSaturated(bool v);
 /// Enables contributions to the sliding window sample set
 external void enable();
 /// Disables contributions to the sliding window sample set
 /// Samples will not be interpolated over the disabled period
 external void disable();
 /// Returns true if sampling is enabled
 external bool get isEnabled; external set isEnabled(bool v);
 /// Resets performance monitor
 external void reset(); }

 /// RollingAverage
 /// Utility to efficiently compute the rolling average and variance over a sliding window of samples
 @JS("BABYLON.RollingAverage" ) class RollingAverage { // @Ignore
 RollingAverage .fakeConstructor$() ;
 /// Current average
 external num get average; external set average(num v);
 /// Current variance
 external num get variance; external set variance(num v); external List<num> get JS$_samples; external set JS$_samples(List<num> v); external num get JS$_sampleCount; external set JS$_sampleCount(num v); external num get JS$_pos; external set JS$_pos(num v); external num get JS$_m2; external set JS$_m2(num v);
 /// constructor
 external factory RollingAverage(num length);
 /// Adds a sample to the sample set
 external void add(num v);
 /// Returns previously added values or null if outside of history or outside the sliding window domain
 external num history(num i);
 /// Returns true if enough samples have been taken to completely fill the sliding window
 external bool isSaturated();
 /// Resets the rolling average (equivalent to 0 samples taken so far)
 external void reset();
 /// Wraps a value around the sample range boundaries
 external num JS$_wrapPosition(num i); }

 /// Helper class that provides a small promise polyfill
 @JS("BABYLON.PromisePolyfill" ) class PromisePolyfill { // @Ignore
 PromisePolyfill .fakeConstructor$() ;
 /// Static function used to check if the polyfill is required
 /// If this is the case then the function will inject the polyfill to window.Promise
 external static void Apply([bool force]); }

 /// Defines the root class used to create scene optimization to use with SceneOptimizer
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.SceneOptimization" ) class SceneOptimization { // @Ignore
 SceneOptimization .fakeConstructor$() ;
 /// Defines the priority of this optimization (0 by default which means first in the list)
 external num get priority; external set priority(num v);
 /// Gets a string describing the action executed by the current optimization
 external String getDescription();
 /// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
 external bool apply(Scene scene, SceneOptimizer optimizer);
 /// Creates the SceneOptimization object
 external factory SceneOptimization([
 /// Defines the priority of this optimization (0 by default which means first in the list)
 num priority]); }

 /// Defines an optimization used to reduce the size of render target textures
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.TextureOptimization" ) class TextureOptimization extends SceneOptimization { // @Ignore
 TextureOptimization .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the priority of this optimization (0 by default which means first in the list)
 external num get priority; external set priority(num v);
 /// Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
 external num get maximumSize; external set maximumSize(num v);
 /// Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
 external num get step; external set step(num v);
 /// Gets a string describing the action executed by the current optimization
 external String getDescription();
 /// Creates the TextureOptimization object
 external factory TextureOptimization([
 /// Defines the priority of this optimization (0 by default which means first in the list)
 num priority,
 /// Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
 num maximumSize,
 /// Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
 num step]);
 /// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
 external bool apply(Scene scene, SceneOptimizer optimizer); }

 /// Defines an optimization used to increase or decrease the rendering resolution
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.HardwareScalingOptimization" ) class HardwareScalingOptimization extends SceneOptimization { // @Ignore
 HardwareScalingOptimization .fakeConstructor$() : super.fakeConstructor$() ;
 /// Defines the priority of this optimization (0 by default which means first in the list)
 external num get priority; external set priority(num v);
 /// Defines the maximum scale to use (2 by default)
 external num get maximumScale; external set maximumScale(num v);
 /// Defines the step to use between two passes (0.5 by default)
 external num get step; external set step(num v); external get JS$_currentScale; external set JS$_currentScale(v); external get JS$_directionOffset; external set JS$_directionOffset(v);
 /// Gets a string describing the action executed by the current optimization
 external String getDescription();
 /// Creates the HardwareScalingOptimization object
 external factory HardwareScalingOptimization([
 /// Defines the priority of this optimization (0 by default which means first in the list)
 num priority,
 /// Defines the maximum scale to use (2 by default)
 num maximumScale,
 /// Defines the step to use between two passes (0.5 by default)
 num step]);
 /// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
 external bool apply(Scene scene, SceneOptimizer optimizer); }

 /// Defines an optimization used to remove shadows
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.ShadowsOptimization" ) class ShadowsOptimization extends SceneOptimization { // @Ignore
 ShadowsOptimization .fakeConstructor$() : super.fakeConstructor$() ;
 /// Gets a string describing the action executed by the current optimization
 external String getDescription();
 /// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
 external bool apply(Scene scene, SceneOptimizer optimizer); }

 /// Defines an optimization used to turn post-processes off
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.PostProcessesOptimization" ) class PostProcessesOptimization extends SceneOptimization { // @Ignore
 PostProcessesOptimization .fakeConstructor$() : super.fakeConstructor$() ;
 /// Gets a string describing the action executed by the current optimization
 external String getDescription();
 /// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
 external bool apply(Scene scene, SceneOptimizer optimizer); }

 /// Defines an optimization used to turn lens flares off
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.LensFlaresOptimization" ) class LensFlaresOptimization extends SceneOptimization { // @Ignore
 LensFlaresOptimization .fakeConstructor$() : super.fakeConstructor$() ;
 /// Gets a string describing the action executed by the current optimization
 external String getDescription();
 /// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
 external bool apply(Scene scene, SceneOptimizer optimizer); }

 /// Defines an optimization based on user defined callback.
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.CustomOptimization" ) class CustomOptimization extends SceneOptimization { // @Ignore
 CustomOptimization .fakeConstructor$() : super.fakeConstructor$() ;
 /// Callback called to apply the custom optimization.
 external Func2<Scene, SceneOptimizer, bool> get onApply; external set onApply(Func2<Scene, SceneOptimizer, bool> v);
 /// Callback called to get custom description
 external Func0<String> get onGetDescription; external set onGetDescription(Func0<String> v);
 /// Gets a string describing the action executed by the current optimization
 external String getDescription();
 /// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
 external bool apply(Scene scene, SceneOptimizer optimizer); }

 /// Defines an optimization used to turn particles off
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.ParticlesOptimization" ) class ParticlesOptimization extends SceneOptimization { // @Ignore
 ParticlesOptimization .fakeConstructor$() : super.fakeConstructor$() ;
 /// Gets a string describing the action executed by the current optimization
 external String getDescription();
 /// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
 external bool apply(Scene scene, SceneOptimizer optimizer); }

 /// Defines an optimization used to turn render targets off
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.RenderTargetsOptimization" ) class RenderTargetsOptimization extends SceneOptimization { // @Ignore
 RenderTargetsOptimization .fakeConstructor$() : super.fakeConstructor$() ;
 /// Gets a string describing the action executed by the current optimization
 external String getDescription();
 /// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
 external bool apply(Scene scene, SceneOptimizer optimizer); }

 /// Defines an optimization used to merge meshes with compatible materials
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.MergeMeshesOptimization" ) class MergeMeshesOptimization extends SceneOptimization { // @Ignore
 MergeMeshesOptimization .fakeConstructor$() : super.fakeConstructor$() ;
 external static get JS$_UpdateSelectionTree; external static set JS$_UpdateSelectionTree(v);
 /// Gets or sets a boolean which defines if optimization octree has to be updated
 /// Gets or sets a boolean which defines if optimization octree has to be updated
 external static bool get UpdateSelectionTree; external static set UpdateSelectionTree(bool v);
 /// Gets a string describing the action executed by the current optimization
 external String getDescription(); external get JS$_canBeMerged; external set JS$_canBeMerged(v);
 /// This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization
 external bool apply(Scene scene, SceneOptimizer optimizer, [bool updateSelectionTree]); }

 /// Defines a list of options used by SceneOptimizer
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.SceneOptimizerOptions" ) class SceneOptimizerOptions { // @Ignore
 SceneOptimizerOptions .fakeConstructor$() ;
 /// Defines the target frame rate to reach (60 by default)
 external num get targetFrameRate; external set targetFrameRate(num v);
 /// Defines the interval between two checkes (2000ms by default)
 external num get trackerDuration; external set trackerDuration(num v);
 /// Gets the list of optimizations to apply
 external List<SceneOptimization> get optimizations; external set optimizations(List<SceneOptimization> v);
 /// Creates a new list of options used by SceneOptimizer
 external factory SceneOptimizerOptions([
 /// Defines the target frame rate to reach (60 by default)
 num targetFrameRate,
 /// Defines the interval between two checkes (2000ms by default)
 num trackerDuration]);
 /// Add a new optimization
 external SceneOptimizerOptions addOptimization(SceneOptimization optimization);
 /// Add a new custom optimization
 external SceneOptimizerOptions addCustomOptimization(bool onApply(Scene scene), String onGetDescription(), [num priority]);
 /// Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene
 external static SceneOptimizerOptions LowDegradationAllowed([num targetFrameRate]);
 /// Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual
 external static SceneOptimizerOptions ModerateDegradationAllowed([num targetFrameRate]);
 /// Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual
 external static SceneOptimizerOptions HighDegradationAllowed([num targetFrameRate]); }

 /// Class used to run optimizations in order to reach a target frame rate
 /// More details at http://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
 @JS("BABYLON.SceneOptimizer" ) class SceneOptimizer implements IDisposable { // @Ignore
 SceneOptimizer .fakeConstructor$() ;
 external get JS$_isRunning; external set JS$_isRunning(v); external get JS$_options; external set JS$_options(v); external get JS$_scene; external set JS$_scene(v); external get JS$_currentPriorityLevel; external set JS$_currentPriorityLevel(v); external get JS$_targetFrameRate; external set JS$_targetFrameRate(v); external get JS$_trackerDuration; external set JS$_trackerDuration(v); external get JS$_currentFrameRate; external set JS$_currentFrameRate(v); external get JS$_sceneDisposeObserver; external set JS$_sceneDisposeObserver(v); external get JS$_improvementMode; external set JS$_improvementMode(v);
 /// Defines an observable called when the optimizer reaches the target frame rate
 external Observable<SceneOptimizer> get onSuccessObservable; external set onSuccessObservable(Observable<SceneOptimizer> v);
 /// Defines an observable called when the optimizer enables an optimization
 external Observable<SceneOptimization> get onNewOptimizationAppliedObservable; external set onNewOptimizationAppliedObservable(Observable<SceneOptimization> v);
 /// Defines an observable called when the optimizer is not able to reach the target frame rate
 external Observable<SceneOptimizer> get onFailureObservable; external set onFailureObservable(Observable<SceneOptimizer> v);
 /// Gets a boolean indicating if the optimizer is in improvement mode
 external bool get isInImprovementMode; external set isInImprovementMode(bool v);
 /// Gets the current priority level (0 at start)
 external num get currentPriorityLevel; external set currentPriorityLevel(num v);
 /// Gets the current frame rate checked by the SceneOptimizer
 external num get currentFrameRate; external set currentFrameRate(num v);
 /// Gets or sets the current target frame rate (60 by default)
 /// Gets or sets the current target frame rate (60 by default)
 external num get targetFrameRate; external set targetFrameRate(num v);
 /// Gets or sets the current interval between two checks (every 2000ms by default)
 /// Gets or sets the current interval between two checks (every 2000ms by default)
 external num get trackerDuration; external set trackerDuration(num v);
 /// Gets the list of active optimizations
 external List<SceneOptimization> get optimizations; external set optimizations(List<SceneOptimization> v);
 /// Creates a new SceneOptimizer
 external factory SceneOptimizer(Scene scene, [SceneOptimizerOptions options, bool autoGeneratePriorities, bool improvementMode]);
 /// Stops the current optimizer
 external void stop();
 /// Reset the optimizer to initial step (current priority level = 0)
 external void reset();
 /// Start the optimizer. By default it will try to reach a specific framerate
 /// but if the optimizer is set with improvementMode === true then it will run all optimiatiation while frame rate is above the target frame rate
 external void start(); external JS$_checkCurrentState();
 /// Release all resources
 external void dispose();
 /// Helper function to create a SceneOptimizer with one single line of code
 external static SceneOptimizer OptimizeAsync(Scene scene, [SceneOptimizerOptions options, void onSuccess(), void onFailure()]); }

 @JS("BABYLON.SceneSerializer" ) class SceneSerializer { // @Ignore
 SceneSerializer .fakeConstructor$() ;
 external static void ClearCache(); external static dynamic Serialize(Scene scene); external static dynamic SerializeMesh(dynamic toSerialize, [bool withParents, bool withChildren]); }

 @JS("BABYLON.SmartArray" ) class SmartArray <T > { // @Ignore
 SmartArray .fakeConstructor$() ;
 external List<T> get data; external set data(List<T> v); external num get length; external set length(num v); external num get JS$_id; external set JS$_id(num v); /* Index signature is not yet supported by JavaScript interop. */
 external factory SmartArray(num capacity); external void push(T value); external void forEach(void func(T content)); external void sort(num compareFn(T a, T b)); external void reset(); external void dispose(); external void concat(dynamic array); external num indexOf(T value); external bool contains(T value); external static get JS$_GlobalId; external static set JS$_GlobalId(v); }

 @JS("BABYLON.SmartArrayNoDuplicate" ) class SmartArrayNoDuplicate <T > extends SmartArray<T> { // @Ignore
 SmartArrayNoDuplicate .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_duplicateId; external set JS$_duplicateId(v); /* Index signature is not yet supported by JavaScript interop. */
 external void push(T value); external bool pushNoDuplicate(T value); external void reset(); external void concatWithNoDuplicate(dynamic array); }

 /// This class implement a typical dictionary using a string as key and the generic type T as value.
 /// The underlying implementation relies on an associative array to ensure the best performances.
 /// The value can be anything including 'null' but except 'undefined'
 @JS("BABYLON.StringDictionary" ) class StringDictionary <T > { // @Ignore
 StringDictionary .fakeConstructor$() ;
 /// This will clear this dictionary and copy the content from the 'source' one.
 /// If the T value is a custom object, it won't be copied/cloned, the same object will be used
 external void copyFrom(StringDictionary<T> source);
 /// Get a value based from its key
 external dynamic/*T|dynamic*/ JS$get(String key);
 /// Get a value from its key or add it if it doesn't exist.
 /// This method will ensure you that a given key/data will be present in the dictionary.
 /// The factory will only be invoked if there's no data for the given key.
 external T getOrAddWithFactory(String key, T JS$factory(String key));
 /// Get a value from its key if present in the dictionary otherwise add it
 external T getOrAdd(String key, T val);
 /// Check if there's a given key in the dictionary
 external bool contains(String key);
 /// Add a new key and its corresponding value
 external bool add(String key, T value); external bool JS$set(String key, T value);
 /// Get the element of the given key and remove it from the dictionary
 external T/*T|Null*/ getAndRemove(String key);
 /// Remove a key/value from the dictionary.
 external bool remove(String key);
 /// Clear the whole content of the dictionary
 external void clear(); external num get count; external set count(num v);
 /// Execute a callback on each key/val of the dictionary.
 /// Note that you can remove any element in this dictionary in the callback implementation
 external void forEach(void callback(String key, T val));
 /// Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.
 /// If the callback returns null or undefined the method will iterate to the next key/value pair
 /// Note that you can remove any element in this dictionary in the callback implementation
 external dynamic/*TRes|Null*/ first /*<TRes>*/(dynamic/*=TRes*/ callback(String key, T val)); external get JS$_count; external set JS$_count(v); external get JS$_data; external set JS$_data(v); }

 @JS("BABYLON.Tags" ) class Tags { // @Ignore
 Tags .fakeConstructor$() ;
 external static void EnableFor(dynamic obj); external static void DisableFor(dynamic obj); external static bool HasTags(dynamic obj); external static dynamic GetTags(dynamic obj, [bool asString]); external static void AddTagsTo(dynamic obj, String tagsString); external static void JS$_AddTagTo(dynamic obj, String tag); external static void RemoveTagsFrom(dynamic obj, String tagsString); external static void JS$_RemoveTagFrom(dynamic obj, String tag); external static bool MatchesQuery(dynamic obj, String tagsQuery); }

 @JS("BABYLON.TextureTools" ) class TextureTools { // @Ignore
 TextureTools .fakeConstructor$() ;
 /// Uses the GPU to create a copy texture rescaled at a given size
 external static Texture CreateResizedCopy(Texture texture, num width, num height, [bool useBilinearMode]); external static BaseTexture GetEnvironmentBRDFTexture(Scene scene); external static get JS$_environmentBRDFBase64Texture; external static set JS$_environmentBRDFBase64Texture(v); }

 @JS("BABYLON.TGATools" ) class TGATools { // @Ignore
 TGATools .fakeConstructor$() ;
 external static get JS$_TYPE_INDEXED; external static set JS$_TYPE_INDEXED(v); external static get JS$_TYPE_RGB; external static set JS$_TYPE_RGB(v); external static get JS$_TYPE_GREY; external static set JS$_TYPE_GREY(v); external static get JS$_TYPE_RLE_INDEXED; external static set JS$_TYPE_RLE_INDEXED(v); external static get JS$_TYPE_RLE_RGB; external static set JS$_TYPE_RLE_RGB(v); external static get JS$_TYPE_RLE_GREY; external static set JS$_TYPE_RLE_GREY(v); external static get JS$_ORIGIN_MASK; external static set JS$_ORIGIN_MASK(v); external static get JS$_ORIGIN_SHIFT; external static set JS$_ORIGIN_SHIFT(v); external static get JS$_ORIGIN_BL; external static set JS$_ORIGIN_BL(v); external static get JS$_ORIGIN_BR; external static set JS$_ORIGIN_BR(v); external static get JS$_ORIGIN_UL; external static set JS$_ORIGIN_UL(v); external static get JS$_ORIGIN_UR; external static set JS$_ORIGIN_UR(v); external static dynamic GetTGAHeader(Uint8List data); external static void UploadContent(RenderingContext gl, Uint8List data); external static Uint8List JS$_getImageData8bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end); external static Uint8List JS$_getImageData16bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end); external static Uint8List JS$_getImageData24bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end); external static Uint8List JS$_getImageData32bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end); external static Uint8List JS$_getImageDataGrey8bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end); external static Uint8List JS$_getImageDataGrey16bits(dynamic header, Uint8List palettes, Uint8List pixel_data, num y_start, num y_step, num y_end, num x_start, num x_step, num x_end); }

 @anonymous @JS() abstract class IAnimatable { external List<Animation> get animations; external set animations(List<Animation> v); external factory IAnimatable({ List<Animation> animations}); }

 @JS("BABYLON.LoadFileError" ) class LoadFileError extends Error { // @Ignore
 LoadFileError .fakeConstructor$() : super.fakeConstructor$() ;
 external dynamic/*HttpRequest|dynamic*/ get request; external set request(dynamic/*HttpRequest|dynamic*/ v); external static get JS$_setPrototypeOf; external static set JS$_setPrototypeOf(v); external factory LoadFileError(String message, [dynamic/*HttpRequest|dynamic*/ request]); }

 @JS("BABYLON.RetryStrategy" ) class RetryStrategy { // @Ignore
 RetryStrategy .fakeConstructor$() ;
 external static Func3<String, HttpRequest, num, num> ExponentialBackoff([num maxRetries, num baseInterval]); }

 @anonymous @JS() abstract class IFileRequest {
 /// Raised when the request is complete (success or error).
 external Observable<IFileRequest> get onCompleteObservable; external set onCompleteObservable(Observable<IFileRequest> v);
 /// Aborts the request for a file.
 external VoidFunc0 get abort; external set abort(VoidFunc0 v); external factory IFileRequest({ Observable<IFileRequest> onCompleteObservable, VoidFunc0 abort}); }

 @JS("BABYLON.Tools" ) class Tools { // @Ignore
 Tools .fakeConstructor$() ;
 external static String get BaseUrl; external static set BaseUrl(String v); external static Func3<String, HttpRequest, num, num> get DefaultRetryStrategy; external static set DefaultRetryStrategy(Func3<String, HttpRequest, num, num> v);
 /// Default behaviour for cors in the application.
 /// It can be a string if the expected behavior is identical in the entire app.
 /// Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
 external static dynamic/*String|Func1<String|List<String>, String>*/ get CorsBehavior; external static set CorsBehavior(dynamic/*String|Func1<String|List<String>, String>*/ v); external static bool get UseFallbackTexture; external static set UseFallbackTexture(bool v);
 /// Use this object to register external classes like custom textures or material
 /// to allow the laoders to instantiate them
 external static dynamic/*JSMap of <String,Object>*/ get RegisteredExternalClasses; external static set RegisteredExternalClasses(dynamic/*JSMap of <String,Object>*/ v); external static String get fallbackTexture; external static set fallbackTexture(String v);
 /// Interpolates between a and b via alpha
 external static num Mix(num a, num b, num alpha); external static dynamic Instantiate(String className);
 /// Provides a slice function that will work even on IE
 external static dynamic/*=T*/ Slice /*<T>*/(dynamic/*=T*/ data, [num start, num end]); external static void SetImmediate(void action()); external static bool IsExponentOfTwo(num value); external static get JS$_tmpFloatArray; external static set JS$_tmpFloatArray(v);
 /// Returns the nearest 32-bit single precision float representation of a Number
 /// to a number or to NaN if it cannot be converted
 external static num FloatRound(num value);
 /// Find the next highest power of two.
 external static num CeilingPOT(num x);
 /// Find the next lowest power of two.
 external static num FloorPOT(num x);
 /// Find the nearest power of two.
 external static num NearestPOT(num x); external static num GetExponentOfTwo(num value, num max, [num mode]); external static String GetFilename(String path);
 /// Extracts the "folder" part of a path (everything before the filename).
 external static String GetFolderPath(String uri, [bool returnUnchangedIfNoSlash]); external static String GetDOMTextContent(HtmlElement element); external static num ToDegrees(num angle); external static num ToRadians(num angle); external static String EncodeArrayBufferTobase64(ByteBuffer buffer); external static dynamic/*{
            minimum: Vector3;
            maximum: Vector3;
        }*/ ExtractMinAndMaxIndexed(dynamic/*List<num>|Float32List*/ positions, dynamic/*List<num>|Int32List|Uint32List|Uint16List*/ indices, num indexStart, num indexCount, [Vector2/*Vector2|Null*/ bias]); external static dynamic/*{
            minimum: Vector3;
            maximum: Vector3;
        }*/ ExtractMinAndMax(dynamic/*List<num>|Float32List*/ positions, num start, num count, [Vector2/*Vector2|Null*/ bias, num stride]); external static Func1<num, Vector2/*Vector2|Null*/> Vector2ArrayFeeder(dynamic/*List<Vector2>|Float32List*/ array); external static dynamic/*{
            minimum: Vector2;
            maximum: Vector2;
        }*/ ExtractMinAndMaxVector2(Vector2 feeder(num index), [Vector2/*Vector2|Null*/ bias]); external static List<dynamic>/*List<dynamic>|Null*/ MakeArray(dynamic obj, [bool allowsNullUndefined]); external static String GetPointerPrefix();
 external static num QueueNewFrame(void func(), [dynamic requester]); external static void RequestFullscreen(HtmlElement element); external static void ExitFullscreen(); external static void SetCorsBehavior(dynamic/*String|List<String>*/ url, dynamic/*{
            crossOrigin: string | null;
        }*/ element); external static String CleanUrl(String url); external static Func1<String, String> get PreprocessUrl; external static set PreprocessUrl(Func1<String, String> v); external static ImageElement LoadImage(dynamic url, void onLoad(ImageElement img), void onError([String message, dynamic exception]), Database/*Database|Null*/ database); external static IFileRequest LoadFile(String url, void onSuccess(dynamic/*String|ByteBuffer*/ data, [String responseURL]), [void onProgress(dynamic data), Database database, bool useArrayBuffer, void onError([HttpRequest request, dynamic exception])]);
 /// Load a script (identified by an url). When the url returns, the
 /// content of this file is added into a new script element, attached to the DOM (body element)
 external static void LoadScript(String scriptUrl, void onSuccess(), [void onError([String message, dynamic exception])]); external static IFileRequest ReadFileAsDataURL(Blob fileToLoad, void callback(dynamic data), dynamic progressCallback(ProgressEvent ev)); external static IFileRequest ReadFile(File fileToLoad, void callback(dynamic data), [dynamic progressCallBack(ProgressEvent ev), bool useArrayBuffer]); external static String FileAsURL(String content); external static String Format(num value, [num decimals]); external static void CheckExtends(Vector3 v, Vector3 min, Vector3 max); external static void DeepCopy(dynamic source, dynamic destination, [List<String> doNotCopyList, List<String> mustCopyList]); external static bool IsEmpty(dynamic obj); external static void RegisterTopRootEvents(List<dynamic/*{
            name: string;
            handler: Nullable<(e: FocusEvent) => any>;
        }*/> events); external static void UnregisterTopRootEvents(List<dynamic/*{
            name: string;
            handler: Nullable<(e: FocusEvent) => any>;
        }*/> events); external static void DumpFramebuffer(num width, num height, Engine engine, [void successCallback(String data), String mimeType, String fileName]); external static void EncodeScreenshotCanvasData([void successCallback(String data), String mimeType, String fileName]); external static void CreateScreenshot(Engine engine, Camera camera, dynamic size, [void successCallback(String data), String mimeType]);
 /// Generates an image screenshot from the specified camera.
 /// following (optional) properties: precision, width, height. If a single number is passed,
 /// it will be used for both width and height. If an object is passed, the screenshot size
 /// will be derived from the parameters. The precision property is a multiplier allowing
 /// rendering at a higher or lower resolution.
 /// screenshot as a string of base64-encoded characters. This string can be assigned to the
 /// src parameter of an <img> to display it.
 /// Check your browser for supported MIME types.
 /// @constructor
 external static void CreateScreenshotUsingRenderTarget(Engine engine, Camera camera, dynamic size, [void successCallback(String data), String mimeType, num samples, bool antialiasing, String fileName]); external static bool ValidateXHRData(HttpRequest xhr, [num dataType]);
 /// Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
 /// Be aware Math.random() could cause collisions, but:
 /// "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
 external static String RandomId();
 /// Test if the given uri is a base64 string.
 external static bool IsBase64(String uri);
 /// Decode the given base64 uri.
 external static ByteBuffer DecodeBase64(String uri); external static get JS$_NoneLogLevel; external static set JS$_NoneLogLevel(v); external static get JS$_MessageLogLevel; external static set JS$_MessageLogLevel(v); external static get JS$_WarningLogLevel; external static set JS$_WarningLogLevel(v); external static get JS$_ErrorLogLevel; external static set JS$_ErrorLogLevel(v); external static get JS$_LogCache; external static set JS$_LogCache(v); external static num get errorsCount; external static set errorsCount(num v); external static VoidFunc1<String> get OnNewCacheEntry; external static set OnNewCacheEntry(VoidFunc1<String> v); external static num get NoneLogLevel; external static set NoneLogLevel(num v); external static num get MessageLogLevel; external static set MessageLogLevel(num v); external static num get WarningLogLevel; external static set WarningLogLevel(num v); external static num get ErrorLogLevel; external static set ErrorLogLevel(num v); external static num get AllLogLevel; external static set AllLogLevel(num v); external static JS$_AddLogEntry(entry); external static JS$_FormatMessage(message); external static JS$_LogDisabled(message); external static JS$_LogEnabled(message); external static JS$_WarnDisabled(message); external static JS$_WarnEnabled(message); external static JS$_ErrorDisabled(message); external static JS$_ErrorEnabled(message); external static VoidFunc1<String> get Log; external static set Log(VoidFunc1<String> v); external static VoidFunc1<String> get Warn; external static set Warn(VoidFunc1<String> v); external static VoidFunc1<String> get Error; external static set Error(VoidFunc1<String> v); external static String get LogCache; external static set LogCache(String v); external static void ClearLogCache(); external static num get LogLevels; external static set LogLevels(num v); external static bool IsWindowObjectExist(); external static get JS$_PerformanceNoneLogLevel; external static set JS$_PerformanceNoneLogLevel(v); external static get JS$_PerformanceUserMarkLogLevel; external static set JS$_PerformanceUserMarkLogLevel(v); external static get JS$_PerformanceConsoleLogLevel; external static set JS$_PerformanceConsoleLogLevel(v); external static get JS$_performance; external static set JS$_performance(v); external static num get PerformanceNoneLogLevel; external static set PerformanceNoneLogLevel(num v); external static num get PerformanceUserMarkLogLevel; external static set PerformanceUserMarkLogLevel(num v); external static num get PerformanceConsoleLogLevel; external static set PerformanceConsoleLogLevel(num v); external static num get PerformanceLogLevel; external static set PerformanceLogLevel(num v); external static void JS$_StartPerformanceCounterDisabled(String counterName, [bool condition]); external static void JS$_EndPerformanceCounterDisabled(String counterName, [bool condition]); external static void JS$_StartUserMark(String counterName, [bool condition]); external static void JS$_EndUserMark(String counterName, [bool condition]); external static void JS$_StartPerformanceConsole(String counterName, [bool condition]); external static void JS$_EndPerformanceConsole(String counterName, [bool condition]); external static VoidFunc2Opt1<String, bool> get StartPerformanceCounter; external static set StartPerformanceCounter(VoidFunc2Opt1<String, bool> v); external static VoidFunc2Opt1<String, bool> get EndPerformanceCounter; external static set EndPerformanceCounter(VoidFunc2Opt1<String, bool> v); external static num get Now; external static set Now(num v);
 /// This method will return the name of the class used to create the instance of the given object.
 /// It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.
 external static String GetClassName(dynamic object, [bool isType]); external static dynamic/*T|Null*/ First /*<T>*/(List<dynamic/*=T*/> array, bool predicate(dynamic/*=T*/ item));
 /// This method will return the name of the full name of the class, including its owning module (if any).
 /// It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).
 external static String/*String|Null*/ getFullClassName(dynamic object, [bool isType]);
 /// This method can be used with hashCodeFromStream when your input is an array of values that are either: number, string, boolean or custom type implementing the getHashCode():number method.
 external static Func1<num, num> arrayOrStringFeeder(dynamic array);
 /// Compute the hashCode of a stream of number
 /// To compute the HashCode on a string or an Array of data types implementing the getHashCode() method, use the arrayOrStringFeeder method.
 external static num hashCodeFromStream(num feeder(num index));
 /// Returns a promise that resolves after the given amount of time.
 external static Promise<Null> DelayAsync(num delay); }

 /// This class is used to track a performance counter which is number based.
 /// The user has access to many properties which give statistics of different nature
 /// The implementer can track two kinds of Performance Counter: time and count
 /// For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.
 /// For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.
 @JS("BABYLON.PerfCounter" ) class PerfCounter { // @Ignore
 PerfCounter .fakeConstructor$() ;
 external static bool get Enabled; external static set Enabled(bool v);
 /// Returns the smallest value ever
 external num get min; external set min(num v);
 /// Returns the biggest value ever
 external num get max; external set max(num v);
 /// Returns the average value since the performance counter is running
 external num get average; external set average(num v);
 /// Returns the average value of the last second the counter was monitored
 external num get lastSecAverage; external set lastSecAverage(num v);
 /// Returns the current value
 external num get current; external set current(num v); external num get total; external set total(num v); external num get count; external set count(num v); external factory PerfCounter();
 /// Call this method to start monitoring a new frame.
 /// This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.
 external void fetchNewFrame();
 /// Call this method to monitor a count of something (e.g. mesh drawn in viewport count)
 external void addCount(num newCount, bool fetchResult);
 /// Start monitoring this performance counter
 external void beginMonitoring();
 /// Compute the time lapsed since the previous beginMonitoring() call.
 external void endMonitoring([bool newFrame]); external JS$_fetchResult(); external get JS$_startMonitoringTime; external set JS$_startMonitoringTime(v); external get JS$_min; external set JS$_min(v); external get JS$_max; external set JS$_max(v); external get JS$_average; external set JS$_average(v); external get JS$_current; external set JS$_current(v); external get JS$_totalValueCount; external set JS$_totalValueCount(v); external get JS$_totalAccumulated; external set JS$_totalAccumulated(v); external get JS$_lastSecAverage; external set JS$_lastSecAverage(v); external get JS$_lastSecAccumulated; external set JS$_lastSecAccumulated(v); external get JS$_lastSecTime; external set JS$_lastSecTime(v); external get JS$_lastSecValueCount; external set JS$_lastSecValueCount(v); }

 /// Use this className as a decorator on a given class definition to add it a name and optionally its module.
 /// You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.
 /// This method is the only way to get it done in all cases, even if the .js file declaring the class is minified
 @JS("BABYLON.className" ) external VoidFunc1<Object> className(String name, [String module]);
 /// An implementation of a loop for asynchronous functions.
 @JS("BABYLON.AsyncLoop" ) class AsyncLoop { // @Ignore
 AsyncLoop .fakeConstructor$() ;
 external num get iterations; external set iterations(num v); external get JS$_fn; external set JS$_fn(v); external get JS$_successCallback; external set JS$_successCallback(v); external num get index; external set index(num v); external get JS$_done; external set JS$_done(v);
 /// Constroctor.
 external factory AsyncLoop(num iterations, void JS$_fn(AsyncLoop asyncLoop), void JS$_successCallback(), [num offset]);
 /// Execute the next iteration. Must be called after the last iteration was finished.
 external void executeNext();
 /// Break the loop and run the success callback.
 external void breakLoop();
 /// Helper function
 external static AsyncLoop Run(num iterations, void JS$_fn(AsyncLoop asyncLoop), void JS$_successCallback(), [num offset]);
 /// A for-loop that will run a given number of iterations synchronous and the rest async.
 /// @constructor
 external static void SyncAsyncForLoop(num iterations, num syncedIterations, void fn(num iteration), void callback(), [bool breakFunction(), num timeout]); }

 /// Defines the potential axis of a Joystick
 @JS("BABYLON.JoystickAxis" ) class JoystickAxis { external static num get
 /// X axis
 X; external static num get
 /// Y axis
 Y; external static num get
 /// Z axis
 Z; }
 /// Class used to define virtual joystick (used in touch mode)
 @JS("BABYLON.VirtualJoystick" ) class VirtualJoystick { // @Ignore
 VirtualJoystick .fakeConstructor$() ;
 /// Gets or sets a boolean indicating that left and right values must be inverted
 external bool get reverseLeftRight; external set reverseLeftRight(bool v);
 /// Gets or sets a boolean indicating that up and down values must be inverted
 external bool get reverseUpDown; external set reverseUpDown(bool v);
 /// Gets the offset value for the position (ie. the change of the position value)
 external Vector3 get deltaPosition; external set deltaPosition(Vector3 v);
 /// Gets a boolean indicating if the virtual joystick was pressed
 external bool get pressed; external set pressed(bool v); external static get JS$_globalJoystickIndex; external static set JS$_globalJoystickIndex(v); external static get vjCanvas; external static set vjCanvas(v); external static get vjCanvasContext; external static set vjCanvasContext(v); external static get vjCanvasWidth; external static set vjCanvasWidth(v); external static get vjCanvasHeight; external static set vjCanvasHeight(v); external static get halfWidth; external static set halfWidth(v); external get JS$_action; external set JS$_action(v); external get JS$_axisTargetedByLeftAndRight; external set JS$_axisTargetedByLeftAndRight(v); external get JS$_axisTargetedByUpAndDown; external set JS$_axisTargetedByUpAndDown(v); external get JS$_joystickSensibility; external set JS$_joystickSensibility(v); external get JS$_inversedSensibility; external set JS$_inversedSensibility(v); external get JS$_joystickPointerID; external set JS$_joystickPointerID(v); external get JS$_joystickColor; external set JS$_joystickColor(v); external get JS$_joystickPointerPos; external set JS$_joystickPointerPos(v); external get JS$_joystickPreviousPointerPos; external set JS$_joystickPreviousPointerPos(v); external get JS$_joystickPointerStartPos; external set JS$_joystickPointerStartPos(v); external get JS$_deltaJoystickVector; external set JS$_deltaJoystickVector(v); external get JS$_leftJoystick; external set JS$_leftJoystick(v); external get JS$_touches; external set JS$_touches(v); external get JS$_onPointerDownHandlerRef; external set JS$_onPointerDownHandlerRef(v); external get JS$_onPointerMoveHandlerRef; external set JS$_onPointerMoveHandlerRef(v); external get JS$_onPointerUpHandlerRef; external set JS$_onPointerUpHandlerRef(v); external get JS$_onResize; external set JS$_onResize(v);
 /// Creates a new virtual joystick
 external factory VirtualJoystick([bool leftJoystick]);
 /// Defines joystick sensibility (ie. the ratio beteen a physical move and virtual joystick position change)
 external void setJoystickSensibility(num newJoystickSensibility); external JS$_onPointerDown(e); external JS$_onPointerMove(e); external JS$_onPointerUp(e);
 /// Change the color of the virtual joystick
 external void setJoystickColor(String newColor);
 /// Defines a callback to call when the joystick is touched
 external void setActionOnTouch(dynamic action());
 /// Defines which axis you'd like to control for left & right
 external void setAxisForLeftRight(num/*enum JoystickAxis*/ axis);
 /// Defines which axis you'd like to control for up & down
 external void setAxisForUpDown(num/*enum JoystickAxis*/ axis); external JS$_drawVirtualJoystick();
 /// Release internal HTML canvas
 external void releaseCanvas(); }

 /// Helper class to push actions to a pool of workers.
 @JS("BABYLON.WorkerPool" ) class WorkerPool implements IDisposable { // @Ignore
 WorkerPool .fakeConstructor$() ;
 external get JS$_workerInfos; external set JS$_workerInfos(v); external get JS$_pendingActions; external set JS$_pendingActions(v);
 /// Constructor
 external factory WorkerPool(List<Worker> workers);
 /// Terminates all workers and clears any pending actions.
 external void dispose();
 /// Pushes an action to the worker pool. If all the workers are active, the action will be
 /// pended until a worker has completed its action.
 external void push(void action(Worker worker, void onComplete())); external JS$_execute(workerInfo, action); }

 @JS("BABYLON.AutoRotationBehavior" ) class AutoRotationBehavior implements Behavior<ArcRotateCamera> { // @Ignore
 AutoRotationBehavior .fakeConstructor$() ;
 external String get name; external set name(String v); external get JS$_zoomStopsAnimation; external set JS$_zoomStopsAnimation(v); external get JS$_idleRotationSpeed; external set JS$_idleRotationSpeed(v); external get JS$_idleRotationWaitTime; external set JS$_idleRotationWaitTime(v); external get JS$_idleRotationSpinupTime; external set JS$_idleRotationSpinupTime(v);
 /// Gets the flag that indicates if user zooming should stop animation.
 /// Sets the flag that indicates if user zooming should stop animation.
 external bool get zoomStopsAnimation; external set zoomStopsAnimation(bool v);
 /// Gets the default speed at which the camera rotates around the model.
 /// Sets the default speed at which the camera rotates around the model.
 external num get idleRotationSpeed; external set idleRotationSpeed(num v);
 /// Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.
 /// Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.
 external num get idleRotationWaitTime; external set idleRotationWaitTime(num v);
 /// Gets the time (milliseconds) to take to spin up to the full idle rotation speed.
 /// Sets the time (milliseconds) to take to spin up to the full idle rotation speed.
 external num get idleRotationSpinupTime; external set idleRotationSpinupTime(num v);
 /// Gets a value indicating if the camera is currently rotating because of this behavior
 external bool get rotationInProgress; external set rotationInProgress(bool v); external get JS$_onPrePointerObservableObserver; external set JS$_onPrePointerObservableObserver(v); external get JS$_onAfterCheckInputsObserver; external set JS$_onAfterCheckInputsObserver(v); external get JS$_attachedCamera; external set JS$_attachedCamera(v); external get JS$_isPointerDown; external set JS$_isPointerDown(v); external get JS$_lastFrameTime; external set JS$_lastFrameTime(v); external get JS$_lastInteractionTime; external set JS$_lastInteractionTime(v); external get JS$_cameraRotationSpeed; external set JS$_cameraRotationSpeed(v); external void init(); external void attach(ArcRotateCamera camera); external void detach();
 /// Returns true if user is scrolling.
 external JS$_userIsZooming(); external get JS$_lastFrameRadius; external set JS$_lastFrameRadius(v); external JS$_shouldAnimationStopForInteraction();
 /// Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
 external JS$_applyUserInteraction(); external JS$_userIsMoving(); }

 /// Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius
 @JS("BABYLON.BouncingBehavior" ) class BouncingBehavior implements Behavior<ArcRotateCamera> { // @Ignore
 BouncingBehavior .fakeConstructor$() ;
 external String get name; external set name(String v);
 /// The easing function used by animations
 external static BackEase get EasingFunction; external static set EasingFunction(BackEase v);
 /// The easing mode used by animations
 external static num get EasingMode; external static set EasingMode(num v);
 /// The duration of the animation, in milliseconds
 external num get transitionDuration; external set transitionDuration(num v);
 /// Length of the distance animated by the transition when lower radius is reached
 external num get lowerRadiusTransitionRange; external set lowerRadiusTransitionRange(num v);
 /// Length of the distance animated by the transition when upper radius is reached
 external num get upperRadiusTransitionRange; external set upperRadiusTransitionRange(num v); external get JS$_autoTransitionRange; external set JS$_autoTransitionRange(v);
 /// Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
 /// Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
 /// Transition ranges will be set to 5% of the bounding box diagonal in world space
 external bool get autoTransitionRange; external set autoTransitionRange(bool v); external get JS$_attachedCamera; external set JS$_attachedCamera(v); external get JS$_onAfterCheckInputsObserver; external set JS$_onAfterCheckInputsObserver(v); external get JS$_onMeshTargetChangedObserver; external set JS$_onMeshTargetChangedObserver(v); external void init(); external void attach(ArcRotateCamera camera); external void detach(); external get JS$_radiusIsAnimating; external set JS$_radiusIsAnimating(v); external get JS$_radiusBounceTransition; external set JS$_radiusBounceTransition(v); external get JS$_animatables; external set JS$_animatables(v); external get JS$_cachedWheelPrecision; external set JS$_cachedWheelPrecision(v);
 /// Checks if the camera radius is at the specified limit. Takes into account animation locks.
 external JS$_isRadiusAtLimit(radiusLimit);
 /// Applies an animation to the radius of the camera, extending by the radiusDelta.
 external JS$_applyBoundRadiusAnimation(radiusDelta);
 /// Removes all animation locks. Allows new animations to be added to any of the camera properties.
 external void JS$_clearAnimationLocks();
 /// Stops and removes all animations that have been applied to the camera
 external void stopAllAnimations(); }

 @JS("BABYLON.FramingBehavior" ) class FramingBehavior implements Behavior<ArcRotateCamera> { // @Ignore
 FramingBehavior .fakeConstructor$() ;
 external String get name; external set name(String v); external get JS$_mode; external set JS$_mode(v); external get JS$_radiusScale; external set JS$_radiusScale(v); external get JS$_positionScale; external set JS$_positionScale(v); external get JS$_defaultElevation; external set JS$_defaultElevation(v); external get JS$_elevationReturnTime; external set JS$_elevationReturnTime(v); external get JS$_elevationReturnWaitTime; external set JS$_elevationReturnWaitTime(v); external get JS$_zoomStopsAnimation; external set JS$_zoomStopsAnimation(v); external get JS$_framingTime; external set JS$_framingTime(v);
 /// The easing function used by animations
 external static ExponentialEase get EasingFunction; external static set EasingFunction(ExponentialEase v);
 /// The easing mode used by animations
 external static num get EasingMode; external static set EasingMode(num v);
 /// Gets current mode used by the behavior.
 /// Sets the current mode used by the behavior
 external num get mode; external set mode(num v);
 /// Gets the scale applied to the radius
 /// Sets the scale applied to the radius (1 by default)
 external num get radiusScale; external set radiusScale(num v);
 /// Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
 /// Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
 external num get positionScale; external set positionScale(num v);
 /// Gets the angle above/below the horizontal plane to return to when the return to default elevation idle
 /// behaviour is triggered, in radians.
 /// Sets the angle above/below the horizontal plane to return to when the return to default elevation idle
 /// behaviour is triggered, in radians.
 external num get defaultElevation; external set defaultElevation(num v);
 /// Gets the time (in milliseconds) taken to return to the default beta position.
 /// Negative value indicates camera should not return to default.
 /// Sets the time (in milliseconds) taken to return to the default beta position.
 /// Negative value indicates camera should not return to default.
 external num get elevationReturnTime; external set elevationReturnTime(num v);
 /// Gets the delay (in milliseconds) taken before the camera returns to the default beta position.
 /// Sets the delay (in milliseconds) taken before the camera returns to the default beta position.
 external num get elevationReturnWaitTime; external set elevationReturnWaitTime(num v);
 /// Gets the flag that indicates if user zooming should stop animation.
 /// Sets the flag that indicates if user zooming should stop animation.
 external bool get zoomStopsAnimation; external set zoomStopsAnimation(bool v);
 /// Gets the transition time when framing the mesh, in milliseconds
 /// Sets the transition time when framing the mesh, in milliseconds
 external num get framingTime; external set framingTime(num v); external get JS$_onPrePointerObservableObserver; external set JS$_onPrePointerObservableObserver(v); external get JS$_onAfterCheckInputsObserver; external set JS$_onAfterCheckInputsObserver(v); external get JS$_onMeshTargetChangedObserver; external set JS$_onMeshTargetChangedObserver(v); external get JS$_attachedCamera; external set JS$_attachedCamera(v); external get JS$_isPointerDown; external set JS$_isPointerDown(v); external get JS$_lastInteractionTime; external set JS$_lastInteractionTime(v); external void init(); external void attach(ArcRotateCamera camera); external void detach(); external get JS$_animatables; external set JS$_animatables(v); external get JS$_betaIsAnimating; external set JS$_betaIsAnimating(v); external get JS$_betaTransition; external set JS$_betaTransition(v); external get JS$_radiusTransition; external set JS$_radiusTransition(v); external get JS$_vectorTransition; external set JS$_vectorTransition(v);
 /// Targets the given mesh and updates zoom level accordingly.
 external void zoomOnMesh(AbstractMesh mesh, [bool focusOnOriginXZ, VoidFunc0/*VoidFunc0|Null*/ onAnimationEnd]);
 /// Targets the given mesh with its children and updates zoom level accordingly.
 external void zoomOnMeshHierarchy(AbstractMesh mesh, [bool focusOnOriginXZ, VoidFunc0/*VoidFunc0|Null*/ onAnimationEnd]);
 /// Targets the given meshes with their children and updates zoom level accordingly.
 external void zoomOnMeshesHierarchy(List<AbstractMesh> meshes, [bool focusOnOriginXZ, VoidFunc0/*VoidFunc0|Null*/ onAnimationEnd]);
 /// Targets the given mesh and updates zoom level accordingly.
 external void zoomOnBoundingInfo(Vector3 minimumWorld, Vector3 maximumWorld, [bool focusOnOriginXZ, VoidFunc0/*VoidFunc0|Null*/ onAnimationEnd]);
 /// Calculates the lowest radius for the camera based on the bounding box of the mesh.
 /// frustum width.
 /// to fully enclose the mesh in the viewing frustum.
 external num JS$_calculateLowerRadiusFromModelBoundingSphere(Vector3 minimumWorld, Vector3 maximumWorld);
 /// Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera
 /// is automatically returned to its default position (expected to be above ground plane).
 external JS$_maintainCameraAboveGround();
 /// Returns the frustum slope based on the canvas ratio and camera FOV
 external JS$_getFrustumSlope();
 /// Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.
 external JS$_clearAnimationLocks();
 /// Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
 external JS$_applyUserInteraction();
 /// Stops and removes all animations that have been applied to the camera
 external void stopAllAnimations();
 /// Gets a value indicating if the user is moving the camera
 external bool get isUserIsMoving; external set isUserIsMoving(bool v);
 /// The camera can move all the way towards the mesh.
 external static num get IgnoreBoundsSizeMode; external static set IgnoreBoundsSizeMode(num v);
 /// The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides
 external static num get FitFrustumSidesMode; external static set FitFrustumSidesMode(num v); }

 @JS("BABYLON.ArcRotateCameraGamepadInput" ) class ArcRotateCameraGamepadInput implements ICameraInput<ArcRotateCamera> { // @Ignore
 ArcRotateCameraGamepadInput .fakeConstructor$() ;
 external ArcRotateCamera get camera; external set camera(ArcRotateCamera v); external Gamepad/*Gamepad|Null*/ get gamepad; external set gamepad(Gamepad/*Gamepad|Null*/ v); external get JS$_onGamepadConnectedObserver; external set JS$_onGamepadConnectedObserver(v); external get JS$_onGamepadDisconnectedObserver; external set JS$_onGamepadDisconnectedObserver(v); external num get gamepadRotationSensibility; external set gamepadRotationSensibility(num v); external num get gamepadMoveSensibility; external set gamepadMoveSensibility(num v); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external void checkInputs(); external String getClassName(); external String getSimpleName(); }

 @JS("BABYLON.ArcRotateCameraKeyboardMoveInput" ) class ArcRotateCameraKeyboardMoveInput implements ICameraInput<ArcRotateCamera> { // @Ignore
 ArcRotateCameraKeyboardMoveInput .fakeConstructor$() ;
 external ArcRotateCamera get camera; external set camera(ArcRotateCamera v); external get JS$_keys; external set JS$_keys(v); external List<num> get keysUp; external set keysUp(List<num> v); external List<num> get keysDown; external set keysDown(List<num> v); external List<num> get keysLeft; external set keysLeft(List<num> v); external List<num> get keysRight; external set keysRight(List<num> v); external List<num> get keysReset; external set keysReset(List<num> v); external num get panningSensibility; external set panningSensibility(num v); external num get zoomingSensibility; external set zoomingSensibility(num v); external bool get useAltToZoom; external set useAltToZoom(bool v); external get JS$_ctrlPressed; external set JS$_ctrlPressed(v); external get JS$_altPressed; external set JS$_altPressed(v); external get JS$_onCanvasBlurObserver; external set JS$_onCanvasBlurObserver(v); external get JS$_onKeyboardObserver; external set JS$_onKeyboardObserver(v); external get JS$_engine; external set JS$_engine(v); external get JS$_scene; external set JS$_scene(v); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external void checkInputs(); external String getClassName(); external String getSimpleName(); }

 @JS("BABYLON.ArcRotateCameraMouseWheelInput" ) class ArcRotateCameraMouseWheelInput implements ICameraInput<ArcRotateCamera> { // @Ignore
 ArcRotateCameraMouseWheelInput .fakeConstructor$() ;
 external ArcRotateCamera get camera; external set camera(ArcRotateCamera v); external get JS$_wheel; external set JS$_wheel(v); external get JS$_observer; external set JS$_observer(v); external num get wheelPrecision; external set wheelPrecision(num v);
 /// wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
 /// It defines the percentage of current camera.radius to use as delta when wheel is used.
 external num get wheelDeltaPercentage; external set wheelDeltaPercentage(num v); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external String getClassName(); external String getSimpleName(); }

 @JS("BABYLON.ArcRotateCameraPointersInput" ) class ArcRotateCameraPointersInput implements ICameraInput<ArcRotateCamera> { // @Ignore
 ArcRotateCameraPointersInput .fakeConstructor$() ;
 external ArcRotateCamera get camera; external set camera(ArcRotateCamera v); external List<num> get buttons; external set buttons(List<num> v); external num get angularSensibilityX; external set angularSensibilityX(num v); external num get angularSensibilityY; external set angularSensibilityY(num v); external num get pinchPrecision; external set pinchPrecision(num v);
 /// pinchDeltaPercentage will be used instead of pinchPrecision if different from 0.
 /// It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
 external num get pinchDeltaPercentage; external set pinchDeltaPercentage(num v); external num get panningSensibility; external set panningSensibility(num v); external bool get multiTouchPanning; external set multiTouchPanning(bool v); external bool get multiTouchPanAndZoom; external set multiTouchPanAndZoom(bool v); external get JS$_isPanClick; external set JS$_isPanClick(v); external bool get pinchInwards; external set pinchInwards(bool v); external get JS$_pointerInput; external set JS$_pointerInput(v); external get JS$_observer; external set JS$_observer(v); external get JS$_onMouseMove; external set JS$_onMouseMove(v); external get JS$_onGestureStart; external set JS$_onGestureStart(v); external get JS$_onGesture; external set JS$_onGesture(v); external get JS$_MSGestureHandler; external set JS$_MSGestureHandler(v); external get JS$_onLostFocus; external set JS$_onLostFocus(v); external get JS$_onContextMenu; external set JS$_onContextMenu(v); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external String getClassName(); external String getSimpleName(); }

 @JS("BABYLON.ArcRotateCameraVRDeviceOrientationInput" ) class ArcRotateCameraVRDeviceOrientationInput implements ICameraInput<ArcRotateCamera> { // @Ignore
 ArcRotateCameraVRDeviceOrientationInput .fakeConstructor$() ;
 external ArcRotateCamera get camera; external set camera(ArcRotateCamera v); external num get alphaCorrection; external set alphaCorrection(num v); external num get betaCorrection; external set betaCorrection(num v); external num get gammaCorrection; external set gammaCorrection(num v); external get JS$_alpha; external set JS$_alpha(v); external get JS$_gamma; external set JS$_gamma(v); external get JS$_dirty; external set JS$_dirty(v); external get JS$_deviceOrientationHandler; external set JS$_deviceOrientationHandler(v); external factory ArcRotateCameraVRDeviceOrientationInput(); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void JS$_onOrientationEvent(DeviceOrientationEvent evt); external void checkInputs(); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external String getClassName(); external String getSimpleName(); }

 /// Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.
 /// Screen rotation is taken into account.
 @JS("BABYLON.FreeCameraDeviceOrientationInput" ) class FreeCameraDeviceOrientationInput implements ICameraInput<FreeCamera> { // @Ignore
 FreeCameraDeviceOrientationInput .fakeConstructor$() ;
 external get JS$_camera; external set JS$_camera(v); external get JS$_screenOrientationAngle; external set JS$_screenOrientationAngle(v); external get JS$_constantTranform; external set JS$_constantTranform(v); external get JS$_screenQuaternion; external set JS$_screenQuaternion(v); external get JS$_alpha; external set JS$_alpha(v); external get JS$_beta; external set JS$_beta(v); external get JS$_gamma; external set JS$_gamma(v); external factory FreeCameraDeviceOrientationInput(); external FreeCamera get camera; external set camera(FreeCamera v); external void attachControl(HtmlElement element, [bool noPreventDefault]); external get JS$_orientationChanged; external set JS$_orientationChanged(v); external get JS$_deviceOrientation; external set JS$_deviceOrientation(v); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external void checkInputs(); external String getClassName(); external String getSimpleName(); }

 @JS("BABYLON.FreeCameraGamepadInput" ) class FreeCameraGamepadInput implements ICameraInput<FreeCamera> { // @Ignore
 FreeCameraGamepadInput .fakeConstructor$() ;
 external FreeCamera get camera; external set camera(FreeCamera v); external Gamepad/*Gamepad|Null*/ get gamepad; external set gamepad(Gamepad/*Gamepad|Null*/ v); external get JS$_onGamepadConnectedObserver; external set JS$_onGamepadConnectedObserver(v); external get JS$_onGamepadDisconnectedObserver; external set JS$_onGamepadDisconnectedObserver(v); external num get gamepadAngularSensibility; external set gamepadAngularSensibility(num v); external num get gamepadMoveSensibility; external set gamepadMoveSensibility(num v); external get JS$_cameraTransform; external set JS$_cameraTransform(v); external get JS$_deltaTransform; external set JS$_deltaTransform(v); external get JS$_vector3; external set JS$_vector3(v); external get JS$_vector2; external set JS$_vector2(v); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external void checkInputs(); external String getClassName(); external String getSimpleName(); }

 @JS("BABYLON.FreeCameraKeyboardMoveInput" ) class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> { // @Ignore
 FreeCameraKeyboardMoveInput .fakeConstructor$() ;
 external FreeCamera get camera; external set camera(FreeCamera v); external get JS$_keys; external set JS$_keys(v); external get JS$_onCanvasBlurObserver; external set JS$_onCanvasBlurObserver(v); external get JS$_onKeyboardObserver; external set JS$_onKeyboardObserver(v); external get JS$_engine; external set JS$_engine(v); external get JS$_scene; external set JS$_scene(v); external List<num> get keysUp; external set keysUp(List<num> v); external List<num> get keysDown; external set keysDown(List<num> v); external List<num> get keysLeft; external set keysLeft(List<num> v); external List<num> get keysRight; external set keysRight(List<num> v); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external void checkInputs(); external String getClassName(); external void JS$_onLostFocus(FocusEvent e); external String getSimpleName(); }

 @JS("BABYLON.FreeCameraMouseInput" ) class FreeCameraMouseInput implements ICameraInput<FreeCamera> { // @Ignore
 FreeCameraMouseInput .fakeConstructor$() ;
 external bool get touchEnabled; external set touchEnabled(bool v); external FreeCamera get camera; external set camera(FreeCamera v); external List<num> get buttons; external set buttons(List<num> v); external num get angularSensibility; external set angularSensibility(num v); external get JS$_pointerInput; external set JS$_pointerInput(v); external get JS$_onMouseMove; external set JS$_onMouseMove(v); external get JS$_observer; external set JS$_observer(v); external get previousPosition; external set previousPosition(v); external factory FreeCameraMouseInput([bool touchEnabled]); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external String getClassName(); external String getSimpleName(); }

 @JS("BABYLON.FreeCameraTouchInput" ) class FreeCameraTouchInput implements ICameraInput<FreeCamera> { // @Ignore
 FreeCameraTouchInput .fakeConstructor$() ;
 external FreeCamera get camera; external set camera(FreeCamera v); external get JS$_offsetX; external set JS$_offsetX(v); external get JS$_offsetY; external set JS$_offsetY(v); external get JS$_pointerPressed; external set JS$_pointerPressed(v); external get JS$_pointerInput; external set JS$_pointerInput(v); external get JS$_observer; external set JS$_observer(v); external get JS$_onLostFocus; external set JS$_onLostFocus(v); external num get touchAngularSensibility; external set touchAngularSensibility(num v); external num get touchMoveSensibility; external set touchMoveSensibility(num v); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external void checkInputs(); external String getClassName(); external String getSimpleName(); }

 @JS("BABYLON.FreeCameraVirtualJoystickInput" ) class FreeCameraVirtualJoystickInput implements ICameraInput<FreeCamera> { // @Ignore
 FreeCameraVirtualJoystickInput .fakeConstructor$() ;
 external FreeCamera get camera; external set camera(FreeCamera v); external get JS$_leftjoystick; external set JS$_leftjoystick(v); external get JS$_rightjoystick; external set JS$_rightjoystick(v); external VirtualJoystick getLeftJoystick(); external VirtualJoystick getRightJoystick(); external void checkInputs(); external void attachControl(HtmlElement element, [bool noPreventDefault]); external void detachControl(HtmlElement/*HtmlElement|Null*/ element); external String getClassName(); external String getSimpleName(); }

 @JS("BABYLON.VRCameraMetrics" ) class VRCameraMetrics { // @Ignore
 VRCameraMetrics .fakeConstructor$() ;
 external num get hResolution; external set hResolution(num v); external num get vResolution; external set vResolution(num v); external num get hScreenSize; external set hScreenSize(num v); external num get vScreenSize; external set vScreenSize(num v); external num get vScreenCenter; external set vScreenCenter(num v); external num get eyeToScreenDistance; external set eyeToScreenDistance(num v); external num get lensSeparationDistance; external set lensSeparationDistance(num v); external num get interpupillaryDistance; external set interpupillaryDistance(num v); external List<num> get distortionK; external set distortionK(List<num> v); external List<num> get chromaAbCorrection; external set chromaAbCorrection(List<num> v); external num get postProcessScaleFactor; external set postProcessScaleFactor(num v); external num get lensCenterOffset; external set lensCenterOffset(num v); external bool get compensateDistortion; external set compensateDistortion(bool v); external num get aspectRatio; external set aspectRatio(num v); external num get aspectRatioFov; external set aspectRatioFov(num v); external Matrix get leftHMatrix; external set leftHMatrix(Matrix v); external Matrix get rightHMatrix; external set rightHMatrix(Matrix v); external Matrix get leftPreViewMatrix; external set leftPreViewMatrix(Matrix v); external Matrix get rightPreViewMatrix; external set rightPreViewMatrix(Matrix v); external static VRCameraMetrics GetDefault(); }

 @JS("BABYLON.VRDeviceOrientationFreeCamera" ) class VRDeviceOrientationFreeCamera extends DeviceOrientationCamera { // @Ignore
 VRDeviceOrientationFreeCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external factory VRDeviceOrientationFreeCamera(String name, Vector3 position, Scene scene, [bool compensateDistortion, VRCameraMetrics vrCameraMetrics]); external String getClassName(); }

 @JS("BABYLON.VRDeviceOrientationGamepadCamera" ) class VRDeviceOrientationGamepadCamera extends VRDeviceOrientationFreeCamera { // @Ignore
 VRDeviceOrientationGamepadCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external factory VRDeviceOrientationGamepadCamera(String name, Vector3 position, Scene scene, [bool compensateDistortion, VRCameraMetrics vrCameraMetrics]); external String getClassName(); }

 @JS("BABYLON.VRDeviceOrientationArcRotateCamera" ) class VRDeviceOrientationArcRotateCamera extends ArcRotateCamera { // @Ignore
 VRDeviceOrientationArcRotateCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external factory VRDeviceOrientationArcRotateCamera(String name, num alpha, num beta, num radius, Vector3 target, Scene scene, [bool compensateDistortion, VRCameraMetrics vrCameraMetrics]); external String getClassName(); }

 /// Options to modify the vr teleportation behavior.
 @anonymous @JS() abstract class VRTeleportationOptions {
 /// The name of the mesh which should be used as the teleportation floor. (default: null)
 external String get floorMeshName; external set floorMeshName(String v);
 /// A list of meshes to be used as the teleportation floor. (default: empty)
 external List<Mesh> get floorMeshes; external set floorMeshes(List<Mesh> v); external factory VRTeleportationOptions({ String floorMeshName, List<Mesh> floorMeshes}); }

 /// Options to modify the vr experience helper's behavior.
 @anonymous @JS() abstract class VRExperienceHelperOptions implements WebVROptions {
 /// Create a DeviceOrientationCamera to be used as your out of vr camera.
 external bool get createDeviceOrientationCamera; external set createDeviceOrientationCamera(bool v);
 /// Create a VRDeviceOrientationFreeCamera to be used for VR when no external HMD is found.
 external bool get createFallbackVRDeviceOrientationFreeCamera; external set createFallbackVRDeviceOrientationFreeCamera(bool v); external factory VRExperienceHelperOptions({ bool createDeviceOrientationCamera, bool createFallbackVRDeviceOrientationFreeCamera, bool
 /// Sets if the webVR camera should be tracked to the vrDevice. (default: true)
 trackPosition, num
 /// Sets the scale of the vrDevice in babylon space. (default: 1)
 positionScale, String
 /// If there are more than one VRDisplays, this will choose the display matching this name. (default: pick first vrDisplay)
 displayName, bool
 /// Should the native controller meshes be initialized. (default: true)
 controllerMeshes, bool
 /// Creating a default HemiLight only on controllers. (default: true)
 defaultLightingOnControllers, bool
 /// If you don't want to use the default VR button of the helper. (default: false)
 useCustomVRButton, ButtonElement
 /// If you'd like to provide your own button to the VRHelper. (default: standard babylon vr button)
 customVRButton, num
 /// To change the length of the ray for gaze/controllers. Will be scaled by positionScale. (default: 100)
 rayLength, num
 /// To change the default offset from the ground to account for user's height in meters. Will be scaled by positionScale. (default: 1.7)
 defaultHeight}); }

 @JS("BABYLON.VRExperienceHelper" ) class VRExperienceHelper { // @Ignore
 VRExperienceHelper .fakeConstructor$() ;
 external VRExperienceHelperOptions get webVROptions; external set webVROptions(VRExperienceHelperOptions v); external get JS$_scene; external set JS$_scene(v); external get JS$_position; external set JS$_position(v); external get JS$_btnVR; external set JS$_btnVR(v); external get JS$_btnVRDisplayed; external set JS$_btnVRDisplayed(v); external get JS$_webVRsupported; external set JS$_webVRsupported(v); external get JS$_webVRready; external set JS$_webVRready(v); external get JS$_webVRrequesting; external set JS$_webVRrequesting(v); external get JS$_webVRpresenting; external set JS$_webVRpresenting(v); external get JS$_fullscreenVRpresenting; external set JS$_fullscreenVRpresenting(v); external get JS$_canvas; external set JS$_canvas(v); external get JS$_webVRCamera; external set JS$_webVRCamera(v); external get JS$_vrDeviceOrientationCamera; external set JS$_vrDeviceOrientationCamera(v); external get JS$_deviceOrientationCamera; external set JS$_deviceOrientationCamera(v); external get JS$_existingCamera; external set JS$_existingCamera(v); external get JS$_onKeyDown; external set JS$_onKeyDown(v); external get JS$_onVrDisplayPresentChange; external set JS$_onVrDisplayPresentChange(v); external get JS$_onVRDisplayChanged; external set JS$_onVRDisplayChanged(v); external get JS$_onVRRequestPresentStart; external set JS$_onVRRequestPresentStart(v); external get JS$_onVRRequestPresentComplete; external set JS$_onVRRequestPresentComplete(v); external Observable<VRExperienceHelper> get onEnteringVRObservable; external set onEnteringVRObservable(Observable<VRExperienceHelper> v); external Observable<VRExperienceHelper> get onExitingVRObservable; external set onExitingVRObservable(Observable<VRExperienceHelper> v); external Observable<WebVRController> get onControllerMeshLoadedObservable; external set onControllerMeshLoadedObservable(Observable<WebVRController> v); external Observable<VRExperienceHelper> get onEnteringVR; external set onEnteringVR(Observable<VRExperienceHelper> v); external Observable<VRExperienceHelper> get onExitingVR; external set onExitingVR(Observable<VRExperienceHelper> v); external Observable<WebVRController> get onControllerMeshLoaded; external set onControllerMeshLoaded(Observable<WebVRController> v); external get JS$_rayLength; external set JS$_rayLength(v); external get JS$_useCustomVRButton; external set JS$_useCustomVRButton(v); external get JS$_teleportationRequested; external set JS$_teleportationRequested(v); external get JS$_teleportActive; external set JS$_teleportActive(v); external get JS$_floorMeshName; external set JS$_floorMeshName(v); external get JS$_floorMeshesCollection; external set JS$_floorMeshesCollection(v); external get JS$_rotationAllowed; external set JS$_rotationAllowed(v); external get JS$_teleportBackwardsVector; external set JS$_teleportBackwardsVector(v); external get JS$_teleportationTarget; external set JS$_teleportationTarget(v); external get JS$_isDefaultTeleportationTarget; external set JS$_isDefaultTeleportationTarget(v); external get JS$_postProcessMove; external set JS$_postProcessMove(v); external get JS$_teleportationFillColor; external set JS$_teleportationFillColor(v); external get JS$_teleportationBorderColor; external set JS$_teleportationBorderColor(v); external get JS$_rotationAngle; external set JS$_rotationAngle(v); external get JS$_haloCenter; external set JS$_haloCenter(v); external get JS$_cameraGazer; external set JS$_cameraGazer(v); external get JS$_padSensibilityUp; external set JS$_padSensibilityUp(v); external get JS$_padSensibilityDown; external set JS$_padSensibilityDown(v); external get leftController; external set leftController(v); external get rightController; external set rightController(v); external Observable<AbstractMesh> get onNewMeshSelected; external set onNewMeshSelected(Observable<AbstractMesh> v); external Observable<PickingInfo> get onNewMeshPicked; external set onNewMeshPicked(Observable<PickingInfo> v); external get JS$_circleEase; external set JS$_circleEase(v); external Observable<Vector3> get onBeforeCameraTeleport; external set onBeforeCameraTeleport(Observable<Vector3> v); external Observable<Vector3> get onAfterCameraTeleport; external set onAfterCameraTeleport(Observable<Vector3> v); external Observable<AbstractMesh> get onSelectedMeshUnselected; external set onSelectedMeshUnselected(Observable<AbstractMesh> v); external get JS$_raySelectionPredicate; external set JS$_raySelectionPredicate(v); external Func1<AbstractMesh, bool> get raySelectionPredicate; external set raySelectionPredicate(Func1<AbstractMesh, bool> v); external Func1<AbstractMesh, bool> get meshSelectionPredicate; external set meshSelectionPredicate(Func1<AbstractMesh, bool> v); external bool get teleportationEnabled; external set teleportationEnabled(bool v); external get JS$_defaultHeight; external set JS$_defaultHeight(v); external get JS$_teleportationInitialized; external set JS$_teleportationInitialized(v); external get JS$_interactionsEnabled; external set JS$_interactionsEnabled(v); external get JS$_interactionsRequested; external set JS$_interactionsRequested(v); external get JS$_displayGaze; external set JS$_displayGaze(v); external get JS$_displayLaserPointer; external set JS$_displayLaserPointer(v); external Mesh get teleportationTarget; external set teleportationTarget(Mesh v); external Mesh get gazeTrackerMesh; external set gazeTrackerMesh(Mesh v); external bool get displayGaze; external set displayGaze(bool v); external bool get displayLaserPointer; external set displayLaserPointer(bool v); external DeviceOrientationCamera/*DeviceOrientationCamera|Null*/ get deviceOrientationCamera; external set deviceOrientationCamera(DeviceOrientationCamera/*DeviceOrientationCamera|Null*/ v); external Camera/*Camera|Null*/ get currentVRCamera; external set currentVRCamera(Camera/*Camera|Null*/ v); external WebVRFreeCamera get webVRCamera; external set webVRCamera(WebVRFreeCamera v); external VRDeviceOrientationFreeCamera/*VRDeviceOrientationFreeCamera|Null*/ get vrDeviceOrientationCamera; external set vrDeviceOrientationCamera(VRDeviceOrientationFreeCamera/*VRDeviceOrientationFreeCamera|Null*/ v); external get JS$_teleportationRequestInitiated; external set JS$_teleportationRequestInitiated(v); external factory VRExperienceHelper(Scene scene, [VRExperienceHelperOptions webVROptions]); external JS$_onDefaultMeshLoaded(webVRController); external get JS$_onResize; external set JS$_onResize(v); external get JS$_onFullscreenChange; external set JS$_onFullscreenChange(v); external bool get isInVRMode; external set isInVRMode(bool v); external onVrDisplayPresentChange(); external onVRDisplayChanged(eventArgs); external moveButtonToBottomRight(); external displayVRButton(); external updateButtonVisibility(); external void enterVR(); external void exitVR(); external Vector3 get position; external set position(Vector3 v); external void enableInteractions(); external get beforeRender; external set beforeRender(v); external JS$_isTeleportationFloor(mesh); external void addFloorMesh(Mesh floorMesh); external void removeFloorMesh(Mesh floorMesh); external void enableTeleportation([VRTeleportationOptions vrTeleportationOptions]); external get JS$_onNewGamepadConnected; external set JS$_onNewGamepadConnected(v); external get JS$_tryEnableInteractionOnController; external set JS$_tryEnableInteractionOnController(v); external get JS$_onNewGamepadDisconnected; external set JS$_onNewGamepadDisconnected(v); external JS$_enableInteractionOnController(controller); external JS$_checkTeleportWithRay(stateObject, gazer); external JS$_checkRotate(stateObject, gazer); external JS$_checkTeleportBackwards(stateObject, gazer); external JS$_enableTeleportationOnController(controller); external JS$_createTeleportationCircles(); external JS$_displayTeleportationTarget(); external JS$_hideTeleportationTarget(); external JS$_rotateCamera(right); external JS$_moveTeleportationSelectorTo(hit, gazer, ray); external get JS$_workingVector; external set JS$_workingVector(v); external get JS$_workingQuaternion; external set JS$_workingQuaternion(v); external get JS$_workingMatrix; external set JS$_workingMatrix(v); external JS$_teleportCamera(location); external JS$_convertNormalToDirectionOfRay(normal, ray); external JS$_castRayAndSelectObject(gazer); external JS$_notifySelectedMeshUnselected(mesh); external void changeLaserColor(Color3 color); external void changeGazeColor(Color3 color); external void dispose(); external String getClassName(); }

 @anonymous @JS() abstract class DevicePose { external Float32List/*Float32List|Null*/ get position; external set position(Float32List/*Float32List|Null*/ v); external Float32List/*Float32List|Null*/ get linearVelocity; external set linearVelocity(Float32List/*Float32List|Null*/ v); external Float32List/*Float32List|Null*/ get linearAcceleration; external set linearAcceleration(Float32List/*Float32List|Null*/ v); external Float32List/*Float32List|Null*/ get orientation; external set orientation(Float32List/*Float32List|Null*/ v); external Float32List/*Float32List|Null*/ get angularVelocity; external set angularVelocity(Float32List/*Float32List|Null*/ v); external Float32List/*Float32List|Null*/ get angularAcceleration; external set angularAcceleration(Float32List/*Float32List|Null*/ v); external factory DevicePose({ Float32List/*Float32List|Null*/ position, Float32List/*Float32List|Null*/ linearVelocity, Float32List/*Float32List|Null*/ linearAcceleration, Float32List/*Float32List|Null*/ orientation, Float32List/*Float32List|Null*/ angularVelocity, Float32List/*Float32List|Null*/ angularAcceleration}); }

 @anonymous @JS() abstract class PoseControlled { external Vector3 get position; external set position(Vector3 v); external Quaternion get rotationQuaternion; external set rotationQuaternion(Quaternion v); external Vector3 get devicePosition; external set devicePosition(Vector3 v); external Quaternion get deviceRotationQuaternion; external set deviceRotationQuaternion(Quaternion v); external DevicePose/*DevicePose|Null*/ get rawPose; external set rawPose(DevicePose/*DevicePose|Null*/ v); external num get deviceScaleFactor; external set deviceScaleFactor(num v); external void updateFromDevice(DevicePose poseData); }

 @anonymous @JS() abstract class WebVROptions { external bool get trackPosition; external set trackPosition(bool v); external num get positionScale; external set positionScale(num v); external String get displayName; external set displayName(String v); external bool get controllerMeshes; external set controllerMeshes(bool v); external bool get defaultLightingOnControllers; external set defaultLightingOnControllers(bool v); external bool get useCustomVRButton; external set useCustomVRButton(bool v); external ButtonElement get customVRButton; external set customVRButton(ButtonElement v); external num get rayLength; external set rayLength(num v); external num get defaultHeight; external set defaultHeight(num v); external factory WebVROptions({ bool trackPosition, num positionScale, String displayName, bool controllerMeshes, bool defaultLightingOnControllers, bool useCustomVRButton, ButtonElement customVRButton, num rayLength, num defaultHeight}); }

 /// This represents a WebVR camera.
 /// The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.
 /// @example http://doc.babylonjs.com/how_to/webvr_camera
 @JS("BABYLON.WebVRFreeCamera" ) class WebVRFreeCamera extends FreeCamera implements PoseControlled { // @Ignore
 WebVRFreeCamera .fakeConstructor$() : super.fakeConstructor$() ;
 external get webVROptions; external set webVROptions(v);
 /// The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay
 external dynamic get JS$_vrDevice; external set JS$_vrDevice(dynamic v);
 /// The rawPose of the vrDevice.
 external DevicePose/*DevicePose|Null*/ get rawPose; external set rawPose(DevicePose/*DevicePose|Null*/ v); external get JS$_onVREnabled; external set JS$_onVREnabled(v); external get JS$_specsVersion; external set JS$_specsVersion(v); external get JS$_attached; external set JS$_attached(v); external get JS$_frameData; external set JS$_frameData(v); external List<Node> get JS$_descendants; external set JS$_descendants(List<Node> v); external get JS$_deviceRoomPosition; external set JS$_deviceRoomPosition(v); external get JS$_deviceRoomRotationQuaternion; external set JS$_deviceRoomRotationQuaternion(v); external get JS$_standingMatrix; external set JS$_standingMatrix(v);
 /// Represents device position in babylon space.
 external Vector3 get devicePosition; external set devicePosition(Vector3 v);
 /// Represents device rotation in babylon space.
 external Quaternion get deviceRotationQuaternion; external set deviceRotationQuaternion(Quaternion v);
 /// The scale of the device to be used when translating from device space to babylon space.
 external num get deviceScaleFactor; external set deviceScaleFactor(num v); external get JS$_deviceToWorld; external set JS$_deviceToWorld(v); external get JS$_worldToDevice; external set JS$_worldToDevice(v);
 /// References to the webVR controllers for the vrDevice.
 external List<WebVRController> get controllers; external set controllers(List<WebVRController> v);
 /// Emits an event when a controller is attached.
 external Observable<List<WebVRController>> get onControllersAttachedObservable; external set onControllersAttachedObservable(Observable<List<WebVRController>> v);
 /// Emits an event when a controller's mesh has been loaded;
 external Observable<WebVRController> get onControllerMeshLoadedObservable; external set onControllerMeshLoadedObservable(Observable<WebVRController> v);
 /// If the rig cameras be used as parent instead of this camera.
 external bool get rigParenting; external set rigParenting(bool v); external get JS$_lightOnControllers; external set JS$_lightOnControllers(v); external get JS$_defaultHeight; external set JS$_defaultHeight(v);
 /// Instantiates a WebVRFreeCamera.
 external factory WebVRFreeCamera(String name, Vector3 position, Scene scene, [WebVROptions webVROptions]);
 /// Gets the device distance from the ground in meters.
 external num deviceDistanceToRoomGround();
 /// Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
 external void useStandingMatrix([void callback(bool bool)]);
 /// Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
 external Promise<bool> useStandingMatrixAsync();
 /// Disposes the camera
 external void dispose();
 /// Gets a vrController by name.
 external WebVRController/*WebVRController|Null*/ getControllerByName(String name); external get JS$_leftController; external set JS$_leftController(v);
 /// The controller corrisponding to the users left hand.
 external WebVRController/*WebVRController|Null*/ get leftController; external set leftController(WebVRController/*WebVRController|Null*/ v); external get JS$_rightController; external set JS$_rightController(v);
 /// The controller corrisponding to the users right hand.
 external WebVRController/*WebVRController|Null*/ get rightController; external set rightController(WebVRController/*WebVRController|Null*/ v);
 /// Casts a ray forward from the vrCamera's gaze.
 external Ray getForwardRay([num length]);
 /// Updates the camera based on device's frame data
 external void JS$_checkInputs();
 /// Updates the poseControlled values based on the input device pose.
 external void updateFromDevice(DevicePose poseData);
 /// WebVR's attach control will start broadcasting frames to the device.
 /// Note that in certain browsers (chrome for example) this function must be called
 /// within a user-interaction callback. Example:
 /// <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre>
 external void attachControl(HtmlElement element, [bool noPreventDefault]);
 /// Detaches the camera from the html element and disables VR
 external void detachControl(HtmlElement element);
 external String getClassName();
 /// Calls resetPose on the vrDisplay
 /// See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose
 external void resetToCurrentRotation();
 /// Updates the rig cameras (left and right eye)
 external void JS$_updateRigCameras(); external get JS$_workingVector; external set JS$_workingVector(v); external get JS$_oneVector; external set JS$_oneVector(v); external get JS$_workingMatrix; external set JS$_workingMatrix(v); external get updateCacheCalled; external set updateCacheCalled(v);
 /// Updates the cached values of the camera
 external void JS$_updateCache([bool ignoreParentClass]);
 /// Updates the current device position and rotation in the babylon world
 external void update();
 /// Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)
 external Matrix JS$_getViewMatrix();
 /// This function is called by the two RIG cameras.
 /// 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)
 external Matrix JS$_getWebVRViewMatrix(); external Matrix JS$_getWebVRProjectionMatrix(); external get JS$_onGamepadConnectedObserver; external set JS$_onGamepadConnectedObserver(v); external get JS$_onGamepadDisconnectedObserver; external set JS$_onGamepadDisconnectedObserver(v);
 /// Initializes the controllers and their meshes
 external void initControllers(); }

 @anonymous @JS() abstract class IOctreeContainer <T > { external List<OctreeBlock<T>> get blocks; external set blocks(List<OctreeBlock<T>> v); external factory IOctreeContainer({ List<OctreeBlock<T>> blocks}); }

 @JS("BABYLON.Octree" ) class Octree <T > { // @Ignore
 Octree .fakeConstructor$() ;
 external num get maxDepth; external set maxDepth(num v); external List<OctreeBlock<T>> get blocks; external set blocks(List<OctreeBlock<T>> v); external List<T> get dynamicContent; external set dynamicContent(List<T> v); external get JS$_maxBlockCapacity; external set JS$_maxBlockCapacity(v); external get JS$_selectionContent; external set JS$_selectionContent(v); external get JS$_creationFunc; external set JS$_creationFunc(v); external factory Octree(void creationFunc(T entry, OctreeBlock<T> block), [num maxBlockCapacity, num maxDepth]); external void update(Vector3 worldMin, Vector3 worldMax, List<T> entries); external void addMesh(T entry); external SmartArray<T> select(List<Plane> frustumPlanes, [bool allowDuplicate]); external SmartArray<T> intersects(Vector3 sphereCenter, num sphereRadius, [bool allowDuplicate]); external SmartArray<T> intersectsRay(Ray ray); external static void JS$_CreateBlocks /*<T>*/(Vector3 worldMin, Vector3 worldMax, List<dynamic/*=T*/> entries, num maxBlockCapacity, num currentDepth, num maxDepth, IOctreeContainer<dynamic/*=T*/> target, void creationFunc(dynamic/*=T*/ entry, OctreeBlock<dynamic/*=T*/> block)); external static VoidFunc2<AbstractMesh, OctreeBlock<AbstractMesh>> get CreationFuncForMeshes; external static set CreationFuncForMeshes(VoidFunc2<AbstractMesh, OctreeBlock<AbstractMesh>> v); external static VoidFunc2<SubMesh, OctreeBlock<SubMesh>> get CreationFuncForSubMeshes; external static set CreationFuncForSubMeshes(VoidFunc2<SubMesh, OctreeBlock<SubMesh>> v); }

 @JS("BABYLON.OctreeBlock" ) class OctreeBlock <T > { // @Ignore
 OctreeBlock .fakeConstructor$() ;
 external List<T> get entries; external set entries(List<T> v); external List<OctreeBlock<T>> get blocks; external set blocks(List<OctreeBlock<T>> v); external get JS$_depth; external set JS$_depth(v); external get JS$_maxDepth; external set JS$_maxDepth(v); external get JS$_capacity; external set JS$_capacity(v); external get JS$_minPoint; external set JS$_minPoint(v); external get JS$_maxPoint; external set JS$_maxPoint(v); external get JS$_boundingVectors; external set JS$_boundingVectors(v); external get JS$_creationFunc; external set JS$_creationFunc(v); external factory OctreeBlock(Vector3 minPoint, Vector3 maxPoint, num capacity, num depth, num maxDepth, void creationFunc(T entry, OctreeBlock<T> block)); external num get capacity; external set capacity(num v); external Vector3 get minPoint; external set minPoint(Vector3 v); external Vector3 get maxPoint; external set maxPoint(Vector3 v); external void addEntry(T entry); external void addEntries(List<T> entries); external void select(List<Plane> frustumPlanes, SmartArrayNoDuplicate<T> selection, [bool allowDuplicate]); external void intersects(Vector3 sphereCenter, num sphereRadius, SmartArrayNoDuplicate<T> selection, [bool allowDuplicate]); external void intersectsRay(Ray ray, SmartArrayNoDuplicate<T> selection); external void createInnerBlocks(); }

 /// Google Daydream controller
 @JS("BABYLON.DaydreamController" ) class DaydreamController extends WebVRController { // @Ignore
 DaydreamController .fakeConstructor$() : super.fakeConstructor$() ;
 /// Base Url for the controller model.
 external static String get MODEL_BASE_URL; external static set MODEL_BASE_URL(String v);
 /// File name for the controller model.
 external static String get MODEL_FILENAME; external static set MODEL_FILENAME(String v);
 /// Gamepad Id prefix used to identify Daydream Controller.
 external static String get GAMEPAD_ID_PREFIX; external static set GAMEPAD_ID_PREFIX(String v);
 /// Creates a new DaydreamController from a gamepad
 external factory DaydreamController(dynamic vrGamepad);
 /// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
 external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);
 /// Called once for each button that changed state since the last frame
 external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes); }

 /// Gear VR Controller
 @JS("BABYLON.GearVRController" ) class GearVRController extends WebVRController { // @Ignore
 GearVRController .fakeConstructor$() : super.fakeConstructor$() ;
 /// Base Url for the controller model.
 external static String get MODEL_BASE_URL; external static set MODEL_BASE_URL(String v);
 /// File name for the controller model.
 external static String get MODEL_FILENAME; external static set MODEL_FILENAME(String v);
 /// Gamepad Id prefix used to identify this controller.
 external static String get GAMEPAD_ID_PREFIX; external static set GAMEPAD_ID_PREFIX(String v); external get JS$_buttonIndexToObservableNameMap; external set JS$_buttonIndexToObservableNameMap(v);
 /// Creates a new GearVRController from a gamepad
 external factory GearVRController(dynamic vrGamepad);
 /// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
 external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);
 /// Called once for each button that changed state since the last frame
 external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes); }

 /// Generic Controller
 @JS("BABYLON.GenericController" ) class GenericController extends WebVRController { // @Ignore
 GenericController .fakeConstructor$() : super.fakeConstructor$() ;
 /// Base Url for the controller model.
 external static String get MODEL_BASE_URL; external static set MODEL_BASE_URL(String v);
 /// File name for the controller model.
 external static String get MODEL_FILENAME; external static set MODEL_FILENAME(String v);
 /// Creates a new GenericController from a gamepad
 external factory GenericController(dynamic vrGamepad);
 /// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
 external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);
 /// Called once for each button that changed state since the last frame
 external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes); }

 /// Oculus Touch Controller
 @JS("BABYLON.OculusTouchController" ) class OculusTouchController extends WebVRController { // @Ignore
 OculusTouchController .fakeConstructor$() : super.fakeConstructor$() ;
 /// Base Url for the controller model.
 external static String get MODEL_BASE_URL; external static set MODEL_BASE_URL(String v);
 /// File name for the left controller model.
 external static String get MODEL_LEFT_FILENAME; external static set MODEL_LEFT_FILENAME(String v);
 /// File name for the right controller model.
 external static String get MODEL_RIGHT_FILENAME; external static set MODEL_RIGHT_FILENAME(String v);
 /// Fired when the secondary trigger on this controller is modified
 external Observable<ExtendedGamepadButton> get onSecondaryTriggerStateChangedObservable; external set onSecondaryTriggerStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the thumb rest on this controller is modified
 external Observable<ExtendedGamepadButton> get onThumbRestChangedObservable; external set onThumbRestChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Creates a new OculusTouchController from a gamepad
 external factory OculusTouchController(dynamic vrGamepad);
 /// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
 external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);
 /// Fired when the A button on this controller is modified
 external Observable<ExtendedGamepadButton> get onAButtonStateChangedObservable; external set onAButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the B button on this controller is modified
 external Observable<ExtendedGamepadButton> get onBButtonStateChangedObservable; external set onBButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the X button on this controller is modified
 external Observable<ExtendedGamepadButton> get onXButtonStateChangedObservable; external set onXButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the Y button on this controller is modified
 external Observable<ExtendedGamepadButton> get onYButtonStateChangedObservable; external set onYButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Called once for each button that changed state since the last frame
 /// 0) thumb stick (touch, press, value = pressed (0,1)). value is in this.leftStick
 /// 1) index trigger (touch (?), press (only when value > 0.1), value 0 to 1)
 /// 2) secondary trigger (same)
 /// 3) A (right) X (left), touch, pressed = value
 /// 4) B / Y
 /// 5) thumb rest
 external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes); }

 /// Defines the types of pose enabled controllers that are supported
 @JS("BABYLON.PoseEnabledControllerType" ) class PoseEnabledControllerType { external static num get
 /// HTC Vive
 VIVE; external static num get
 /// Oculus Rift
 OCULUS; external static num get
 /// Windows mixed reality
 WINDOWS; external static num get
 /// Samsung gear VR
 GEAR_VR; external static num get
 /// Google Daydream
 DAYDREAM; external static num get
 /// Generic
 GENERIC; }
 /// Defines the MutableGamepadButton interface for the state of a gamepad button
 @anonymous @JS() abstract class MutableGamepadButton {
 /// Value of the button/trigger
 external num get value; external set value(num v);
 /// If the button/trigger is currently touched
 external bool get touched; external set touched(bool v);
 /// If the button/trigger is currently pressed
 external bool get pressed; external set pressed(bool v); external factory MutableGamepadButton({ num value, bool touched, bool pressed}); }

 /// Defines the ExtendedGamepadButton interface for a gamepad button which includes state provided by a pose controller
 /// @hidden
 @anonymous @JS() abstract class ExtendedGamepadButton implements GamepadButton {
 /// If the button/trigger is currently pressed
 external bool get pressed; external set pressed(bool v);
 /// If the button/trigger is currently touched
 external bool get touched; external set touched(bool v);
 /// Value of the button/trigger
 external num get value; external set value(num v); external factory ExtendedGamepadButton({ bool pressed, bool touched, num value}); }

 /// Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
 @JS("BABYLON.PoseEnabledControllerHelper" ) class PoseEnabledControllerHelper { // @Ignore
 PoseEnabledControllerHelper .fakeConstructor$() ;
 /// Initializes a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
 external static dynamic/*OculusTouchController|WindowsMotionController|ViveController|GearVRController|DaydreamController|GenericController*/ InitiateController(dynamic vrGamepad); }

 /// Defines the PoseEnabledController object that contains state of a vr capable controller
 @JS("BABYLON.PoseEnabledController" ) class PoseEnabledController extends Gamepad implements PoseControlled { // @Ignore
 PoseEnabledController .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_deviceRoomPosition; external set JS$_deviceRoomPosition(v); external get JS$_deviceRoomRotationQuaternion; external set JS$_deviceRoomRotationQuaternion(v);
 /// The device position in babylon space
 external Vector3 get devicePosition; external set devicePosition(Vector3 v);
 /// The device rotation in babylon space
 external Quaternion get deviceRotationQuaternion; external set deviceRotationQuaternion(Quaternion v);
 /// The scale factor of the device in babylon space
 external num get deviceScaleFactor; external set deviceScaleFactor(num v);
 /// (Likely devicePosition should be used instead) The device position in its room space
 external Vector3 get position; external set position(Vector3 v);
 /// (Likely deviceRotationQuaternion should be used instead) The device rotation in its room space
 external Quaternion get rotationQuaternion; external set rotationQuaternion(Quaternion v);
 /// The type of controller (Eg. Windows mixed reality)
 external num/*enum PoseEnabledControllerType*/ get controllerType; external set controllerType(num/*enum PoseEnabledControllerType*/ v); external get JS$_calculatedPosition; external set JS$_calculatedPosition(v); external get JS$_calculatedRotation; external set JS$_calculatedRotation(v);
 /// The raw pose from the device
 external DevicePose get rawPose; external set rawPose(DevicePose v);
 /// Internal, the mesh attached to the controller
 external AbstractMesh/*AbstractMesh|Null*/ get JS$_mesh; external set JS$_mesh(AbstractMesh/*AbstractMesh|Null*/ v); external get JS$_poseControlledCamera; external set JS$_poseControlledCamera(v); external get JS$_leftHandSystemQuaternion; external set JS$_leftHandSystemQuaternion(v);
 /// Internal, matrix used to convert room space to babylon space
 external Matrix get JS$_deviceToWorld; external set JS$_deviceToWorld(Matrix v);
 /// Node to be used when casting a ray from the controller
 external AbstractMesh/*AbstractMesh|Null*/ get JS$_pointingPoseNode; external set JS$_pointingPoseNode(AbstractMesh/*AbstractMesh|Null*/ v);
 /// Name of the child mesh that can be used to cast a ray from the controller
 external static String get POINTING_POSE; external static set POINTING_POSE(String v);
 /// Creates a new PoseEnabledController from a gamepad
 external factory PoseEnabledController(dynamic browserGamepad); external get JS$_workingMatrix; external set JS$_workingMatrix(v);
 /// Updates the state of the pose enbaled controller and mesh based on the current position and rotation of the controller
 external void update();
 /// Updates the state of the pose enbaled controller based on the raw pose data from the device
 external void updateFromDevice(DevicePose poseData);
 /// @hidden
 external Observable<AbstractMesh> get JS$_meshAttachedObservable; external set JS$_meshAttachedObservable(Observable<AbstractMesh> v);
 /// Attaches a mesh to the controller
 external void attachToMesh(AbstractMesh mesh);
 /// Attaches the controllers mesh to a camera
 external void attachToPoseControlledCamera(TargetCamera camera);
 /// Disposes of the controller
 external void dispose();
 /// The mesh that is attached to the controller
 external AbstractMesh/*AbstractMesh|Null*/ get mesh; external set mesh(AbstractMesh/*AbstractMesh|Null*/ v);
 /// Gets the ray of the controller in the direction the controller is pointing
 external Ray getForwardRay([num length]); }

 /// Vive Controller
 @JS("BABYLON.ViveController" ) class ViveController extends WebVRController { // @Ignore
 ViveController .fakeConstructor$() : super.fakeConstructor$() ;
 /// Base Url for the controller model.
 external static String get MODEL_BASE_URL; external static set MODEL_BASE_URL(String v);
 /// File name for the controller model.
 external static String get MODEL_FILENAME; external static set MODEL_FILENAME(String v);
 /// Creates a new ViveController from a gamepad
 external factory ViveController(dynamic vrGamepad);
 /// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
 external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]);
 /// Fired when the left button on this controller is modified
 external Observable<ExtendedGamepadButton> get onLeftButtonStateChangedObservable; external set onLeftButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the right button on this controller is modified
 external Observable<ExtendedGamepadButton> get onRightButtonStateChangedObservable; external set onRightButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the menu button on this controller is modified
 external Observable<ExtendedGamepadButton> get onMenuButtonStateChangedObservable; external set onMenuButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Called once for each button that changed state since the last frame
 /// Vive mapping:
 /// 0: touchpad
 /// 1: trigger
 /// 2: left AND right buttons
 /// 3: menu button
 external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes); }

 /// Defines the WebVRController object that represents controllers tracked in 3D space
 @JS("BABYLON.WebVRController" ) abstract class WebVRController extends PoseEnabledController { // @Ignore
 WebVRController .fakeConstructor$() : super.fakeConstructor$() ;
 /// Internal, the default controller model for the controller
 external AbstractMesh get JS$_defaultModel; external set JS$_defaultModel(AbstractMesh v);
 /// Fired when the trigger state has changed
 external Observable<ExtendedGamepadButton> get onTriggerStateChangedObservable; external set onTriggerStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the main button state has changed
 external Observable<ExtendedGamepadButton> get onMainButtonStateChangedObservable; external set onMainButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the secondary button state has changed
 external Observable<ExtendedGamepadButton> get onSecondaryButtonStateChangedObservable; external set onSecondaryButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the pad state has changed
 external Observable<ExtendedGamepadButton> get onPadStateChangedObservable; external set onPadStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when controllers stick values have changed
 external Observable<StickValues> get onPadValuesChangedObservable; external set onPadValuesChangedObservable(Observable<StickValues> v);
 /// Array of button availible on the controller
 external List<MutableGamepadButton> get JS$_buttons; external set JS$_buttons(List<MutableGamepadButton> v); external get JS$_onButtonStateChange; external set JS$_onButtonStateChange(v);
 /// Fired when a controller button's state has changed
 external void onButtonStateChange(void callback(num controlledIndex, num buttonIndex, ExtendedGamepadButton state));
 /// X and Y axis corrisponding to the controllers joystick
 external StickValues get pad; external set pad(StickValues v);
 /// 'left' or 'right', see https://w3c.github.io/gamepad/extensions.html#gamepadhand-enum
 external String get hand; external set hand(String v);
 /// The default controller model for the controller
 external AbstractMesh get defaultModel; external set defaultModel(AbstractMesh v);
 /// Creates a new WebVRController from a gamepad
 external factory WebVRController(dynamic vrGamepad);
 /// Updates the state of the controller and mesh based on the current position and rotation of the controller
 external void update();
 /// Function to be called when a button is modified
 external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton value, GamepadButtonChanges changes);
 /// Loads a mesh and attaches it to the controller
 external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh)]); external JS$_setButtonValue(newState, currentState, buttonIndex); external get JS$_changes; external set JS$_changes(v); external JS$_checkChanges(newState, currentState);
 /// Disposes of th webVRCOntroller
 external void dispose(); }

 /// Defines the WindowsMotionController object that the state of the windows motion controller
 @JS("BABYLON.WindowsMotionController" ) class WindowsMotionController extends WebVRController { // @Ignore
 WindowsMotionController .fakeConstructor$() : super.fakeConstructor$() ;
 /// The base url used to load the left and right controller models
 external static String get MODEL_BASE_URL; external static set MODEL_BASE_URL(String v);
 /// The name of the left controller model file
 external static String get MODEL_LEFT_FILENAME; external static set MODEL_LEFT_FILENAME(String v);
 /// The name of the right controller model file
 external static String get MODEL_RIGHT_FILENAME; external static set MODEL_RIGHT_FILENAME(String v);
 /// The controller name prefix for this controller type
 external static String get GAMEPAD_ID_PREFIX; external static set GAMEPAD_ID_PREFIX(String v);
 /// The controller id pattern for this controller type
 external static get GAMEPAD_ID_PATTERN; external static set GAMEPAD_ID_PATTERN(v); external get JS$_loadedMeshInfo; external set JS$_loadedMeshInfo(v); external get JS$_mapping; external set JS$_mapping(v);
 /// Fired when the trackpad on this controller is clicked
 external Observable<ExtendedGamepadButton> get onTrackpadChangedObservable; external set onTrackpadChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the trackpad on this controller is modified
 external Observable<StickValues> get onTrackpadValuesChangedObservable; external set onTrackpadValuesChangedObservable(Observable<StickValues> v);
 /// The current x and y values of this controller's trackpad
 external StickValues get trackpad; external set trackpad(StickValues v);
 /// Creates a new WindowsMotionController from a gamepad
 external factory WindowsMotionController(dynamic vrGamepad);
 /// Fired when the trigger on this controller is modified
 external Observable<ExtendedGamepadButton> get onTriggerButtonStateChangedObservable; external set onTriggerButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the menu button on this controller is modified
 external Observable<ExtendedGamepadButton> get onMenuButtonStateChangedObservable; external set onMenuButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the grip button on this controller is modified
 external Observable<ExtendedGamepadButton> get onGripButtonStateChangedObservable; external set onGripButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the thumbstick button on this controller is modified
 external Observable<ExtendedGamepadButton> get onThumbstickButtonStateChangedObservable; external set onThumbstickButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the touchpad button on this controller is modified
 external Observable<ExtendedGamepadButton> get onTouchpadButtonStateChangedObservable; external set onTouchpadButtonStateChangedObservable(Observable<ExtendedGamepadButton> v);
 /// Fired when the touchpad values on this controller are modified
 external Observable<StickValues> get onTouchpadValuesChangedObservable; external set onTouchpadValuesChangedObservable(Observable<StickValues> v);
 /// Called once per frame by the engine.
 external void update();
 /// Called once for each button that changed state since the last frame
 external void JS$_handleButtonChange(num buttonIdx, ExtendedGamepadButton state, GamepadButtonChanges changes);
 /// Moves the buttons on the controller mesh based on their current state
 external void JS$_lerpButtonTransform(String buttonName, num buttonValue);
 /// Moves the axis on the controller mesh based on its current state
 /// @hidden
 external void JS$_lerpAxisTransform(num axis, num axisValue);
 /// Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.
 external void initControllerMesh(Scene scene, [void meshLoaded(AbstractMesh mesh), bool forceDefault]);
 /// Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that
 /// can be transformed by button presses and axes values, based on this._mapping.
 external processModel(scene, meshes); external createMeshInfo(rootNode);
 /// Gets the ray of the controller in the direction the controller is pointing
 external Ray getForwardRay([num length]);
 /// Disposes of the controller
 external void dispose(); }

 /// Interface to implement to create a shadow generator compatible with BJS.
 @anonymous @JS() abstract class IShadowGenerator {
 /// Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
 external RenderTargetTexture/*RenderTargetTexture|Null*/ getShadowMap();
 /// Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
 external RenderTargetTexture/*RenderTargetTexture|Null*/ getShadowMapForRendering();
 /// Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
 external bool isReady(SubMesh subMesh, bool useInstances);
 /// Prepare all the defines in a material relying on a shadow map at the specified light index.
 external void prepareDefines(MaterialDefines defines, num lightIndex);
 /// Binds the shadow related information inside of an effect (information like near, far, darkness...
 /// defined in the generator but impacting the effect).
 /// It implies the unifroms available on the materials are the standard BJS ones.
 external void bindShadowLight(String lightIndex, Effect effect);
 /// Gets the transformation matrix used to project the meshes into the map from the light point of view.
 /// (eq to shadow prjection matrix * light transform matrix)
 external Matrix getTransformMatrix();
 /// Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
 /// Cube and 2D textures for instance.
 external void recreateShadowMap();
 /// Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
 external void forceCompilation([void onCompiled(ShadowGenerator generator), Partial<dynamic/*{
            useInstances: boolean;
        }*/> options]);
 /// Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
 external Promise<Null> forceCompilationAsync([Partial<dynamic/*{
            useInstances: boolean;
        }*/> options]);
 /// Serializes the shadow generator setup to a json object.
 external dynamic serialize();
 /// Disposes the Shadow map and related Textures and effects.
 external void dispose(); }

 /// Default implementation IShadowGenerator.
 /// This is the main object responsible of generating shadows in the framework.
 /// Documentation: https://doc.babylonjs.com/babylon101/shadows
 @JS("BABYLON.ShadowGenerator" ) class ShadowGenerator implements IShadowGenerator { // @Ignore
 ShadowGenerator .fakeConstructor$() ;
 /// Shadow generator mode None: no filtering applied.
 external static num get FILTER_NONE; external static set FILTER_NONE(num v);
 /// Shadow generator mode ESM: Exponential Shadow Mapping.
 /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
 external static num get FILTER_EXPONENTIALSHADOWMAP; external static set FILTER_EXPONENTIALSHADOWMAP(num v);
 /// Shadow generator mode Poisson Sampling: Percentage Closer Filtering.
 /// (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)
 external static num get FILTER_POISSONSAMPLING; external static set FILTER_POISSONSAMPLING(num v);
 /// Shadow generator mode ESM: Blurred Exponential Shadow Mapping.
 /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
 external static num get FILTER_BLUREXPONENTIALSHADOWMAP; external static set FILTER_BLUREXPONENTIALSHADOWMAP(num v);
 /// Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing
 /// edge artifacts on steep falloff.
 /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
 external static num get FILTER_CLOSEEXPONENTIALSHADOWMAP; external static set FILTER_CLOSEEXPONENTIALSHADOWMAP(num v);
 /// Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing
 /// edge artifacts on steep falloff.
 /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
 external static num get FILTER_BLURCLOSEEXPONENTIALSHADOWMAP; external static set FILTER_BLURCLOSEEXPONENTIALSHADOWMAP(num v);
 /// Shadow generator mode PCF: Percentage Closer Filtering
 /// benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
 /// (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)
 external static num get FILTER_PCF; external static set FILTER_PCF(num v);
 /// Shadow generator mode PCSS: Percentage Closering Soft Shadow.
 /// benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
 /// Contact Hardening
 external static num get FILTER_PCSS; external static set FILTER_PCSS(num v);
 /// Reserved for PCF and PCSS
 /// Highest Quality.
 /// Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.
 /// Execute PCSS with 32 taps blocker search and 64 taps PCF.
 external static num get QUALITY_HIGH; external static set QUALITY_HIGH(num v);
 /// Reserved for PCF and PCSS
 /// Good tradeoff for quality/perf cross devices
 /// Execute PCF on a 3*3 kernel.
 /// Execute PCSS with 16 taps blocker search and 32 taps PCF.
 external static num get QUALITY_MEDIUM; external static set QUALITY_MEDIUM(num v);
 /// Reserved for PCF and PCSS
 /// The lowest quality but the fastest.
 /// Execute PCF on a 1*1 kernel.
 /// Execute PCSS with 16 taps blocker search and 16 taps PCF.
 external static num get QUALITY_LOW; external static set QUALITY_LOW(num v); external get JS$_bias; external set JS$_bias(v);
 /// Gets the bias: offset applied on the depth preventing acnea (in light direction).
 /// Sets the bias: offset applied on the depth preventing acnea (in light direction).
 external num get bias; external set bias(num v); external get JS$_normalBias; external set JS$_normalBias(v);
 /// Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
 /// Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
 external num get normalBias; external set normalBias(num v); external get JS$_blurBoxOffset; external set JS$_blurBoxOffset(v);
 /// Gets the blur box offset: offset applied during the blur pass.
 /// Only usefull if useKernelBlur = false
 /// Sets the blur box offset: offset applied during the blur pass.
 /// Only usefull if useKernelBlur = false
 external num get blurBoxOffset; external set blurBoxOffset(num v); external get JS$_blurScale; external set JS$_blurScale(v);
 /// Gets the blur scale: scale of the blurred texture compared to the main shadow map.
 /// 2 means half of the size.
 /// Sets the blur scale: scale of the blurred texture compared to the main shadow map.
 /// 2 means half of the size.
 external num get blurScale; external set blurScale(num v); external get JS$_blurKernel; external set JS$_blurKernel(v);
 /// Gets the blur kernel: kernel size of the blur pass.
 /// Only usefull if useKernelBlur = true
 /// Sets the blur kernel: kernel size of the blur pass.
 /// Only usefull if useKernelBlur = true
 external num get blurKernel; external set blurKernel(num v); external get JS$_useKernelBlur; external set JS$_useKernelBlur(v);
 /// Gets whether the blur pass is a kernel blur (if true) or box blur.
 /// Only usefull in filtered mode (useBlurExponentialShadowMap...)
 /// Sets whether the blur pass is a kernel blur (if true) or box blur.
 /// Only usefull in filtered mode (useBlurExponentialShadowMap...)
 external bool get useKernelBlur; external set useKernelBlur(bool v); external get JS$_depthScale; external set JS$_depthScale(v);
 /// Gets the depth scale used in ESM mode.
 /// Sets the depth scale used in ESM mode.
 /// This can override the scale stored on the light.
 external num get depthScale; external set depthScale(num v); external get JS$_filter; external set JS$_filter(v);
 /// Gets the current mode of the shadow generator (normal, PCF, ESM...).
 /// The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
 /// Sets the current mode of the shadow generator (normal, PCF, ESM...).
 /// The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
 external num get filter; external set filter(num v);
 /// Gets if the current filter is set to Poisson Sampling.
 /// Sets the current filter to Poisson Sampling.
 external bool get usePoissonSampling; external set usePoissonSampling(bool v);
 /// Gets if the current filter is set to VSM.
 /// DEPRECATED. Should use useExponentialShadowMap instead.
 /// Sets the current filter is to VSM.
 /// DEPRECATED. Should use useExponentialShadowMap instead.
 external bool get useVarianceShadowMap; external set useVarianceShadowMap(bool v);
 /// Gets if the current filter is set to blurred VSM.
 /// DEPRECATED. Should use useBlurExponentialShadowMap instead.
 /// Sets the current filter is to blurred VSM.
 /// DEPRECATED. Should use useBlurExponentialShadowMap instead.
 external bool get useBlurVarianceShadowMap; external set useBlurVarianceShadowMap(bool v);
 /// Gets if the current filter is set to ESM.
 /// Sets the current filter is to ESM.
 external bool get useExponentialShadowMap; external set useExponentialShadowMap(bool v);
 /// Gets if the current filter is set to filtered ESM.
 /// Gets if the current filter is set to filtered  ESM.
 external bool get useBlurExponentialShadowMap; external set useBlurExponentialShadowMap(bool v);
 /// Gets if the current filter is set to "close ESM" (using the inverse of the
 /// exponential to prevent steep falloff artifacts).
 /// Sets the current filter to "close ESM" (using the inverse of the
 /// exponential to prevent steep falloff artifacts).
 external bool get useCloseExponentialShadowMap; external set useCloseExponentialShadowMap(bool v);
 /// Gets if the current filter is set to filtered "close ESM" (using the inverse of the
 /// exponential to prevent steep falloff artifacts).
 /// Sets the current filter to filtered "close ESM" (using the inverse of the
 /// exponential to prevent steep falloff artifacts).
 external bool get useBlurCloseExponentialShadowMap; external set useBlurCloseExponentialShadowMap(bool v);
 /// Gets if the current filter is set to "PCF" (percentage closer filtering).
 /// Sets the current filter to "PCF" (percentage closer filtering).
 external bool get usePercentageCloserFiltering; external set usePercentageCloserFiltering(bool v); external get JS$_filteringQuality; external set JS$_filteringQuality(v);
 /// Gets the PCF or PCSS Quality.
 /// Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
 /// Sets the PCF or PCSS Quality.
 /// Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
 external num get filteringQuality; external set filteringQuality(num v);
 /// Gets if the current filter is set to "PCSS" (contact hardening).
 /// Sets the current filter to "PCSS" (contact hardening).
 external bool get useContactHardeningShadow; external set useContactHardeningShadow(bool v); external get JS$_contactHardeningLightSizeUVRatio; external set JS$_contactHardeningLightSizeUVRatio(v);
 /// Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
 /// Using a ratio helps keeping shape stability independently of the map size.
 /// It does not account for the light projection as it was having too much
 /// instability during the light setup or during light position changes.
 /// Only valid if useContactHardeningShadow is true.
 /// Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
 /// Using a ratio helps keeping shape stability independently of the map size.
 /// It does not account for the light projection as it was having too much
 /// instability during the light setup or during light position changes.
 /// Only valid if useContactHardeningShadow is true.
 external num get contactHardeningLightSizeUVRatio; external set contactHardeningLightSizeUVRatio(num v); external get JS$_darkness; external set JS$_darkness(v);
 /// Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
 /// 0 means strongest and 1 would means no shadow.
 external num getDarkness();
 /// Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
 external ShadowGenerator setDarkness(num darkness); external get JS$_transparencyShadow; external set JS$_transparencyShadow(v);
 /// Sets the ability to have transparent shadow (boolean).
 external ShadowGenerator setTransparencyShadow(bool transparent); external get JS$_shadowMap; external set JS$_shadowMap(v); external get JS$_shadowMap2; external set JS$_shadowMap2(v);
 /// Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
 external RenderTargetTexture/*RenderTargetTexture|Null*/ getShadowMap();
 /// Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
 external RenderTargetTexture/*RenderTargetTexture|Null*/ getShadowMapForRendering();
 /// Helper function to add a mesh and its descendants to the list of shadow casters.
 external ShadowGenerator addShadowCaster(AbstractMesh mesh, [bool includeDescendants]);
 /// Helper function to remove a mesh and its descendants from the list of shadow casters
 external ShadowGenerator removeShadowCaster(AbstractMesh mesh, [bool includeDescendants]);
 /// Controls the extent to which the shadows fade out at the edge of the frustum
 /// Used only by directionals and spots
 external num get frustumEdgeFalloff; external set frustumEdgeFalloff(num v); external get JS$_light; external set JS$_light(v);
 /// Returns the associated light object.
 external IShadowLight getLight();
 /// If true the shadow map is generated by rendering the back face of the mesh instead of the front face.
 /// This can help with self-shadowing as the geometry making up the back of objects is slightly offset.
 /// It might on the other hand introduce peter panning.
 external bool get forceBackFacesOnly; external set forceBackFacesOnly(bool v); external get JS$_scene; external set JS$_scene(v); external get JS$_lightDirection; external set JS$_lightDirection(v); external get JS$_effect; external set JS$_effect(v); external get JS$_viewMatrix; external set JS$_viewMatrix(v); external get JS$_projectionMatrix; external set JS$_projectionMatrix(v); external get JS$_transformMatrix; external set JS$_transformMatrix(v); external get JS$_cachedPosition; external set JS$_cachedPosition(v); external get JS$_cachedDirection; external set JS$_cachedDirection(v); external get JS$_cachedDefines; external set JS$_cachedDefines(v); external get JS$_currentRenderID; external set JS$_currentRenderID(v); external get JS$_boxBlurPostprocess; external set JS$_boxBlurPostprocess(v); external get JS$_kernelBlurXPostprocess; external set JS$_kernelBlurXPostprocess(v); external get JS$_kernelBlurYPostprocess; external set JS$_kernelBlurYPostprocess(v); external get JS$_blurPostProcesses; external set JS$_blurPostProcesses(v); external get JS$_mapSize; external set JS$_mapSize(v); external get JS$_currentFaceIndex; external set JS$_currentFaceIndex(v); external get JS$_currentFaceIndexCache; external set JS$_currentFaceIndexCache(v); external get JS$_textureType; external set JS$_textureType(v); external get JS$_defaultTextureMatrix; external set JS$_defaultTextureMatrix(v);
 /// Creates a ShadowGenerator object.
 /// A ShadowGenerator is the required tool to use the shadows.
 /// Each light casting shadows needs to use its own ShadowGenerator.
 /// Documentation : http://doc.babylonjs.com/tutorials/shadows
 external factory ShadowGenerator(num mapSize, IShadowLight light, [bool useFullFloatFirst]); external JS$_initializeGenerator(); external JS$_initializeShadowMap(); external JS$_initializeBlurRTTAndPostProcesses(); external JS$_renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes); external JS$_renderSubMeshForShadowMap(subMesh); external JS$_applyFilterValues();
 /// Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
 external void forceCompilation([void onCompiled(ShadowGenerator generator), Partial<dynamic/*{
            useInstances: boolean;
        }*/> options]);
 /// Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.
 external Promise<Null> forceCompilationAsync([Partial<dynamic/*{
            useInstances: boolean;
        }*/> options]);
 /// Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
 external bool isReady(SubMesh subMesh, bool useInstances);
 /// Prepare all the defines in a material relying on a shadow map at the specified light index.
 external void prepareDefines(dynamic defines, num lightIndex);
 /// Binds the shadow related information inside of an effect (information like near, far, darkness...
 /// defined in the generator but impacting the effect).
 external void bindShadowLight(String lightIndex, Effect effect);
 /// Gets the transformation matrix used to project the meshes into the map from the light point of view.
 /// (eq to shadow prjection matrix * light transform matrix)
 external Matrix getTransformMatrix();
 /// Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
 /// Cube and 2D textures for instance.
 external void recreateShadowMap(); external JS$_disposeBlurPostProcesses(); external JS$_disposeRTTandPostProcesses();
 /// Disposes the ShadowGenerator.
 /// Returns nothing.
 external void dispose();
 /// Serializes the shadow generator setup to a json object.
 external dynamic serialize();
 /// Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
 external static ShadowGenerator Parse(dynamic parsedShadowGenerator, Scene scene); }

 /// Background material used to create an efficient environement around your scene.
 @JS("BABYLON.BackgroundMaterial" ) class BackgroundMaterial extends PushMaterial { // @Ignore
 BackgroundMaterial .fakeConstructor$() : super.fakeConstructor$() ;
 /// Standard reflectance value at parallel view angle.
 external static num get StandardReflectance0; external static set StandardReflectance0(num v);
 /// Standard reflectance value at grazing angle.
 external static num get StandardReflectance90; external static set StandardReflectance90(num v); external Color3 get JS$_primaryColor; external set JS$_primaryColor(Color3 v);
 /// Key light Color (multiply against the environement texture)
 external Color3 get primaryColor; external set primaryColor(Color3 v); external Color3/*Color3|Null*/ get JS$___perceptualColor; external set JS$___perceptualColor(Color3/*Color3|Null*/ v);
 /// Experimental Internal Use Only.
 /// Key light Color in "perceptual value" meaning the color you would like to see on screen.
 /// This acts as a helper to set the primary color to a more "human friendly" value.
 /// Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the
 /// output color as close as possible from the chosen value.
 /// (This does not account for contrast color grading and color curves as they are considered post effect and not directly
 /// part of lighting setup.)
 external Color3/*Color3|Null*/ get JS$_perceptualColor; external set JS$_perceptualColor(Color3/*Color3|Null*/ v); external num get JS$_primaryColorShadowLevel; external set JS$_primaryColorShadowLevel(num v);
 /// Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.
 /// The color opposite to the primary color is used at the level chosen to define what the black area would look.
 external num get primaryColorShadowLevel; external set primaryColorShadowLevel(num v); external num get JS$_primaryColorHighlightLevel; external set JS$_primaryColorHighlightLevel(num v);
 /// Defines the level of the highliights (highlight area of the reflection map) in order to help scaling the colors.
 /// The primary color is used at the level chosen to define what the white area would look.
 external num get primaryColorHighlightLevel; external set primaryColorHighlightLevel(num v); external BaseTexture/*BaseTexture|Null*/ get JS$_reflectionTexture; external set JS$_reflectionTexture(BaseTexture/*BaseTexture|Null*/ v);
 /// Reflection Texture used in the material.
 /// Should be author in a specific way for the best result (refer to the documentation).
 external BaseTexture/*BaseTexture|Null*/ get reflectionTexture; external set reflectionTexture(BaseTexture/*BaseTexture|Null*/ v); external num get JS$_reflectionBlur; external set JS$_reflectionBlur(num v);
 /// Reflection Texture level of blur.
 /// Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the
 /// texture twice.
 external num get reflectionBlur; external set reflectionBlur(num v); external BaseTexture/*BaseTexture|Null*/ get JS$_diffuseTexture; external set JS$_diffuseTexture(BaseTexture/*BaseTexture|Null*/ v);
 /// Diffuse Texture used in the material.
 /// Should be author in a specific way for the best result (refer to the documentation).
 external BaseTexture/*BaseTexture|Null*/ get diffuseTexture; external set diffuseTexture(BaseTexture/*BaseTexture|Null*/ v); external List<IShadowLight>/*List<IShadowLight>|Null*/ get JS$_shadowLights; external set JS$_shadowLights(List<IShadowLight>/*List<IShadowLight>|Null*/ v);
 /// Specify the list of lights casting shadow on the material.
 /// All scene shadow lights will be included if null.
 external List<IShadowLight>/*List<IShadowLight>|Null*/ get shadowLights; external set shadowLights(List<IShadowLight>/*List<IShadowLight>|Null*/ v); external num get JS$_shadowLevel; external set JS$_shadowLevel(num v);
 /// Helps adjusting the shadow to a softer level if required.
 /// 0 means black shadows and 1 means no shadows.
 external num get shadowLevel; external set shadowLevel(num v); external Vector3 get JS$_sceneCenter; external set JS$_sceneCenter(Vector3 v);
 /// In case of opacity Fresnel or reflection falloff, this is use as a scene center.
 /// It is usually zero but might be interesting to modify according to your setup.
 external Vector3 get sceneCenter; external set sceneCenter(Vector3 v); external bool get JS$_opacityFresnel; external set JS$_opacityFresnel(bool v);
 /// This helps specifying that the material is falling off to the sky box at grazing angle.
 /// This helps ensuring a nice transition when the camera goes under the ground.
 external bool get opacityFresnel; external set opacityFresnel(bool v); external bool get JS$_reflectionFresnel; external set JS$_reflectionFresnel(bool v);
 /// This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.
 /// This helps adding a mirror texture on the ground.
 external bool get reflectionFresnel; external set reflectionFresnel(bool v); external num get JS$_reflectionFalloffDistance; external set JS$_reflectionFalloffDistance(num v);
 /// This helps specifying the falloff radius off the reflection texture from the sceneCenter.
 /// This helps adding a nice falloff effect to the reflection if used as a mirror for instance.
 external num get reflectionFalloffDistance; external set reflectionFalloffDistance(num v); external num get JS$_reflectionAmount; external set JS$_reflectionAmount(num v);
 /// This specifies the weight of the reflection against the background in case of reflection Fresnel.
 external num get reflectionAmount; external set reflectionAmount(num v); external num get JS$_reflectionReflectance0; external set JS$_reflectionReflectance0(num v);
 /// This specifies the weight of the reflection at grazing angle.
 external num get reflectionReflectance0; external set reflectionReflectance0(num v); external num get JS$_reflectionReflectance90; external set JS$_reflectionReflectance90(num v);
 /// This specifies the weight of the reflection at a perpendicular point of view.
 external num get reflectionReflectance90; external set reflectionReflectance90(num v);
 /// Sets the reflection reflectance fresnel values according to the default standard
 /// empirically know to work well :-)
 external num get reflectionStandardFresnelWeight; external set reflectionStandardFresnelWeight(num v); external bool get JS$_useRGBColor; external set JS$_useRGBColor(bool v);
 /// Helps to directly use the maps channels instead of their level.
 external bool get useRGBColor; external set useRGBColor(bool v); external bool get JS$_enableNoise; external set JS$_enableNoise(bool v);
 /// This helps reducing the banding effect that could occur on the background.
 external bool get enableNoise; external set enableNoise(bool v);
 /// The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
 /// Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.
 /// Recommended to be keep at 1.0 except for special cases.
 external num get fovMultiplier; external set fovMultiplier(num v); external get JS$_fovMultiplier; external set JS$_fovMultiplier(v);
 /// Enable the FOV adjustment feature controlled by fovMultiplier.
 external bool get useEquirectangularFOV; external set useEquirectangularFOV(bool v); external get JS$_maxSimultaneousLights; external set JS$_maxSimultaneousLights(v);
 /// Number of Simultaneous lights allowed on the material.
 external num get maxSimultaneousLights; external set maxSimultaneousLights(num v);
 /// Default configuration related to image processing available in the Background Material.
 external ImageProcessingConfiguration get JS$_imageProcessingConfiguration; external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);
 /// Keep track of the image processing observer to allow dispose and replace.
 external get JS$_imageProcessingObserver; external set JS$_imageProcessingObserver(v);
 /// Attaches a new image processing configuration to the PBR Material.
 external void JS$_attachImageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ configuration);
 /// Gets the image processing configuration used either in this material.
 /// Sets the Default image processing configuration used either in the this material.
 /// If sets to null, the scene one is in use.
 external ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ get imageProcessingConfiguration; external set imageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ v);
 /// Gets wether the color curves effect is enabled.
 /// Sets wether the color curves effect is enabled.
 external bool get cameraColorCurvesEnabled; external set cameraColorCurvesEnabled(bool v);
 /// Gets wether the color grading effect is enabled.
 /// Gets wether the color grading effect is enabled.
 external bool get cameraColorGradingEnabled; external set cameraColorGradingEnabled(bool v);
 /// Gets wether tonemapping is enabled or not.
 /// Sets wether tonemapping is enabled or not
 external bool get cameraToneMappingEnabled; external set cameraToneMappingEnabled(bool v);
 /// The camera exposure used on this material.
 /// This property is here and not in the camera to allow controlling exposure without full screen post process.
 /// This corresponds to a photographic exposure.
 /// The camera exposure used on this material.
 /// This property is here and not in the camera to allow controlling exposure without full screen post process.
 /// This corresponds to a photographic exposure.
 external num get cameraExposure; external set cameraExposure(num v);
 /// Gets The camera contrast used on this material.
 /// Sets The camera contrast used on this material.
 external num get cameraContrast; external set cameraContrast(num v);
 /// Gets the Color Grading 2D Lookup Texture.
 /// Sets the Color Grading 2D Lookup Texture.
 external BaseTexture/*BaseTexture|Null*/ get cameraColorGradingTexture; external set cameraColorGradingTexture(BaseTexture/*BaseTexture|Null*/ v);
 /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
 /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
 /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
 /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
 /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
 /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
 /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
 /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
 external ColorCurves/*ColorCurves|Null*/ get cameraColorCurves; external set cameraColorCurves(ColorCurves/*ColorCurves|Null*/ v);
 /// Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.
 /// Setting this flag to true (not done automatically!) will convert it back to RGB.
 external bool get switchToBGR; external set switchToBGR(bool v); external get JS$_renderTargets; external set JS$_renderTargets(v); external get JS$_reflectionControls; external set JS$_reflectionControls(v); external get JS$_white; external set JS$_white(v); external get JS$_primaryShadowColor; external set JS$_primaryShadowColor(v); external get JS$_primaryHighlightColor; external set JS$_primaryHighlightColor(v);
 /// Instantiates a Background Material in the given scene
 external factory BackgroundMaterial(String name, Scene scene);
 /// The entire material has been created in order to prevent overdraw.
 external bool needAlphaTesting();
 /// The entire material has been created in order to prevent overdraw.
 external bool needAlphaBlending();
 /// Checks wether the material is ready to be rendered for a given mesh.
 external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool useInstances]);
 /// Compute the primary color according to the chosen perceptual color.
 external JS$_computePrimaryColorFromPerceptualColor();
 /// Compute the highlights and shadow colors according to their chosen levels.
 external JS$_computePrimaryColors();
 /// Build the uniform buffer used in the material.
 external void buildUniformLayout();
 /// Unbind the material.
 external void unbind();
 /// Bind only the world matrix to the material.
 external void bindOnlyWorldMatrix(Matrix world);
 /// Bind the material for a dedicated submeh (every used meshes will be considered opaque).
 external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);
 /// Dispose the material.
 external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]);
 /// Clones the material.
 external BackgroundMaterial clone(String name);
 /// Serializes the current material to its JSON representation.
 external dynamic serialize();
 /// Gets the class name of the material
 external String getClassName();
 /// Parse a JSON input to create back a background material.
 external static BackgroundMaterial Parse(dynamic source, Scene scene, String rootUrl); }

 /// The Physically based material base class of BJS.
 /// This offers the main features of a standard PBR material.
 /// For more information, please refer to the documentation :
 /// http://doc.babylonjs.com/extensions/Physically_Based_Rendering
 @JS("BABYLON.PBRBaseMaterial" ) abstract class PBRBaseMaterial extends PushMaterial { // @Ignore
 PBRBaseMaterial .fakeConstructor$() : super.fakeConstructor$() ;
 /// Intensity of the direct lights e.g. the four lights available in your scene.
 /// This impacts both the direct diffuse and specular highlights.
 external num get JS$_directIntensity; external set JS$_directIntensity(num v);
 /// Intensity of the emissive part of the material.
 /// This helps controlling the emissive effect without modifying the emissive color.
 external num get JS$_emissiveIntensity; external set JS$_emissiveIntensity(num v);
 /// Intensity of the environment e.g. how much the environment will light the object
 /// either through harmonics for rough material or through the refelction for shiny ones.
 external num get JS$_environmentIntensity; external set JS$_environmentIntensity(num v);
 /// This is a special control allowing the reduction of the specular highlights coming from the
 /// four lights of the scene. Those highlights may not be needed in full environment lighting.
 external num get JS$_specularIntensity; external set JS$_specularIntensity(num v);
 /// This stores the direct, emissive, environment, and specular light intensities into a Vector4.
 external get JS$_lightingInfos; external set JS$_lightingInfos(v);
 /// Debug Control allowing disabling the bump map on this material.
 external bool get JS$_disableBumpMap; external set JS$_disableBumpMap(bool v);
 /// AKA Diffuse Texture in standard nomenclature.
 external BaseTexture get JS$_albedoTexture; external set JS$_albedoTexture(BaseTexture v);
 /// AKA Occlusion Texture in other nomenclature.
 external BaseTexture get JS$_ambientTexture; external set JS$_ambientTexture(BaseTexture v);
 /// AKA Occlusion Texture Intensity in other nomenclature.
 external num get JS$_ambientTextureStrength; external set JS$_ambientTextureStrength(num v);
 /// Stores the alpha values in a texture.
 external BaseTexture get JS$_opacityTexture; external set JS$_opacityTexture(BaseTexture v);
 /// Stores the reflection values in a texture.
 external BaseTexture get JS$_reflectionTexture; external set JS$_reflectionTexture(BaseTexture v);
 /// Stores the refraction values in a texture.
 external BaseTexture get JS$_refractionTexture; external set JS$_refractionTexture(BaseTexture v);
 /// Stores the emissive values in a texture.
 external BaseTexture get JS$_emissiveTexture; external set JS$_emissiveTexture(BaseTexture v);
 /// AKA Specular texture in other nomenclature.
 external BaseTexture get JS$_reflectivityTexture; external set JS$_reflectivityTexture(BaseTexture v);
 /// Used to switch from specular/glossiness to metallic/roughness workflow.
 external BaseTexture get JS$_metallicTexture; external set JS$_metallicTexture(BaseTexture v);
 /// Specifies the metallic scalar of the metallic/roughness workflow.
 /// Can also be used to scale the metalness values of the metallic texture.
 external num get JS$_metallic; external set JS$_metallic(num v);
 /// Specifies the roughness scalar of the metallic/roughness workflow.
 /// Can also be used to scale the roughness values of the metallic texture.
 external num get JS$_roughness; external set JS$_roughness(num v);
 /// Used to enable roughness/glossiness fetch from a separate chanel depending on the current mode.
 /// Gray Scale represents roughness in metallic mode and glossiness in specular mode.
 external BaseTexture get JS$_microSurfaceTexture; external set JS$_microSurfaceTexture(BaseTexture v);
 /// Stores surface normal data used to displace a mesh in a texture.
 external BaseTexture get JS$_bumpTexture; external set JS$_bumpTexture(BaseTexture v);
 /// Stores the pre-calculated light information of a mesh in a texture.
 external BaseTexture get JS$_lightmapTexture; external set JS$_lightmapTexture(BaseTexture v);
 /// The color of a material in ambient lighting.
 external Color3 get JS$_ambientColor; external set JS$_ambientColor(Color3 v);
 /// AKA Diffuse Color in other nomenclature.
 external Color3 get JS$_albedoColor; external set JS$_albedoColor(Color3 v);
 /// AKA Specular Color in other nomenclature.
 external Color3 get JS$_reflectivityColor; external set JS$_reflectivityColor(Color3 v);
 /// The color applied when light is reflected from a material.
 external Color3 get JS$_reflectionColor; external set JS$_reflectionColor(Color3 v);
 /// The color applied when light is emitted from a material.
 external Color3 get JS$_emissiveColor; external set JS$_emissiveColor(Color3 v);
 /// AKA Glossiness in other nomenclature.
 external num get JS$_microSurface; external set JS$_microSurface(num v);
 /// source material index of refraction (IOR)' / 'destination material IOR.
 external num get JS$_indexOfRefraction; external set JS$_indexOfRefraction(num v);
 /// Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.
 external bool get JS$_invertRefractionY; external set JS$_invertRefractionY(bool v);
 /// This parameters will make the material used its opacity to control how much it is refracting aginst not.
 /// Materials half opaque for instance using refraction could benefit from this control.
 external bool get JS$_linkRefractionWithTransparency; external set JS$_linkRefractionWithTransparency(bool v);
 /// Specifies that the material will use the light map as a show map.
 external bool get JS$_useLightmapAsShadowmap; external set JS$_useLightmapAsShadowmap(bool v);
 /// This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
 /// makes the reflect vector face the model (under horizon).
 external bool get JS$_useHorizonOcclusion; external set JS$_useHorizonOcclusion(bool v);
 /// This parameters will enable/disable radiance occlusion by preventing the radiance to lit
 /// too much the area relying on ambient texture to define their ambient occlusion.
 external bool get JS$_useRadianceOcclusion; external set JS$_useRadianceOcclusion(bool v);
 /// Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
 external bool get JS$_useAlphaFromAlbedoTexture; external set JS$_useAlphaFromAlbedoTexture(bool v);
 /// Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).
 /// A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
 external bool get JS$_useSpecularOverAlpha; external set JS$_useSpecularOverAlpha(bool v);
 /// Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
 external bool get JS$_useMicroSurfaceFromReflectivityMapAlpha; external set JS$_useMicroSurfaceFromReflectivityMapAlpha(bool v);
 /// Specifies if the metallic texture contains the roughness information in its alpha channel.
 external bool get JS$_useRoughnessFromMetallicTextureAlpha; external set JS$_useRoughnessFromMetallicTextureAlpha(bool v);
 /// Specifies if the metallic texture contains the roughness information in its green channel.
 external bool get JS$_useRoughnessFromMetallicTextureGreen; external set JS$_useRoughnessFromMetallicTextureGreen(bool v);
 /// Specifies if the metallic texture contains the metallness information in its blue channel.
 external bool get JS$_useMetallnessFromMetallicTextureBlue; external set JS$_useMetallnessFromMetallicTextureBlue(bool v);
 /// Specifies if the metallic texture contains the ambient occlusion information in its red channel.
 external bool get JS$_useAmbientOcclusionFromMetallicTextureRed; external set JS$_useAmbientOcclusionFromMetallicTextureRed(bool v);
 /// Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
 external bool get JS$_useAmbientInGrayScale; external set JS$_useAmbientInGrayScale(bool v);
 /// In case the reflectivity map does not contain the microsurface information in its alpha channel,
 /// The material will try to infer what glossiness each pixel should be.
 external bool get JS$_useAutoMicroSurfaceFromReflectivityMap; external set JS$_useAutoMicroSurfaceFromReflectivityMap(bool v);
 /// BJS is using an harcoded light falloff based on a manually sets up range.
 /// In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
 /// This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
 external bool get JS$_usePhysicalLightFalloff; external set JS$_usePhysicalLightFalloff(bool v);
 /// Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
 /// A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
 external bool get JS$_useRadianceOverAlpha; external set JS$_useRadianceOverAlpha(bool v);
 /// Allows using an object space normal map (instead of tangent space).
 external bool get JS$_useObjectSpaceNormalMap; external set JS$_useObjectSpaceNormalMap(bool v);
 /// Allows using the bump map in parallax mode.
 external bool get JS$_useParallax; external set JS$_useParallax(bool v);
 /// Allows using the bump map in parallax occlusion mode.
 external bool get JS$_useParallaxOcclusion; external set JS$_useParallaxOcclusion(bool v);
 /// Controls the scale bias of the parallax mode.
 external num get JS$_parallaxScaleBias; external set JS$_parallaxScaleBias(num v);
 /// If sets to true, disables all the lights affecting the material.
 external bool get JS$_disableLighting; external set JS$_disableLighting(bool v);
 /// Number of Simultaneous lights allowed on the material.
 external num get JS$_maxSimultaneousLights; external set JS$_maxSimultaneousLights(num v);
 /// If sets to true, x component of normal map value will be inverted (x = 1.0 - x).
 external bool get JS$_invertNormalMapX; external set JS$_invertNormalMapX(bool v);
 /// If sets to true, y component of normal map value will be inverted (y = 1.0 - y).
 external bool get JS$_invertNormalMapY; external set JS$_invertNormalMapY(bool v);
 /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
 external bool get JS$_twoSidedLighting; external set JS$_twoSidedLighting(bool v);
 /// Defines the alpha limits in alpha test mode.
 external num get JS$_alphaCutOff; external set JS$_alphaCutOff(num v);
 /// Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
 external bool get JS$_forceAlphaTest; external set JS$_forceAlphaTest(bool v);
 /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
 /// And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
 external bool get JS$_useAlphaFresnel; external set JS$_useAlphaFresnel(bool v);
 /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
 /// And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
 external bool get JS$_useLinearAlphaFresnel; external set JS$_useLinearAlphaFresnel(bool v);
 /// The transparency mode of the material.
 external num/*num|Null*/ get JS$_transparencyMode; external set JS$_transparencyMode(num/*num|Null*/ v);
 /// Specifies the environment BRDF texture used to comput the scale and offset roughness values
 /// from cos thetav and roughness:
 /// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
 external BaseTexture/*BaseTexture|Null*/ get JS$_environmentBRDFTexture; external set JS$_environmentBRDFTexture(BaseTexture/*BaseTexture|Null*/ v);
 /// Force the shader to compute irradiance in the fragment shader in order to take bump in account.
 external bool get JS$_forceIrradianceInFragment; external set JS$_forceIrradianceInFragment(bool v);
 /// Force normal to face away from face.
 external bool get JS$_forceNormalForward; external set JS$_forceNormalForward(bool v);
 /// Enables specular anti aliasing in the PBR shader.
 /// It will both interacts on the Geometry for analytical and IBL lighting.
 /// It also prefilter the roughness map based on the bump values.
 external bool get JS$_enableSpecularAntiAliasing; external set JS$_enableSpecularAntiAliasing(bool v);
 /// Default configuration related to image processing available in the PBR Material.
 external ImageProcessingConfiguration get JS$_imageProcessingConfiguration; external set JS$_imageProcessingConfiguration(ImageProcessingConfiguration v);
 /// Keep track of the image processing observer to allow dispose and replace.
 external get JS$_imageProcessingObserver; external set JS$_imageProcessingObserver(v);
 /// Attaches a new image processing configuration to the PBR Material.
 external void JS$_attachImageProcessingConfiguration(ImageProcessingConfiguration/*ImageProcessingConfiguration|Null*/ configuration);
 /// Stores the available render targets.
 external get JS$_renderTargets; external set JS$_renderTargets(v);
 /// Sets the global ambient color for the material used in lighting calculations.
 external get JS$_globalAmbientColor; external set JS$_globalAmbientColor(v);
 /// Enables the use of logarithmic depth buffers, which is good for wide depth buffers.
 external get JS$_useLogarithmicDepth; external set JS$_useLogarithmicDepth(v);
 /// If set to true, no lighting calculations will be applied.
 external get JS$_unlit; external set JS$_unlit(v);
 /// Instantiates a new PBRMaterial instance.
 external factory PBRBaseMaterial(String name, Scene scene);
 /// Gets the name of the material class.
 external String getClassName();
 /// Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
 /// Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
 external bool get useLogarithmicDepth; external set useLogarithmicDepth(bool v);
 /// Gets the current transparency mode.
 /// Sets the transparency mode of the material.
 external num/*num|Null*/ get transparencyMode; external set transparencyMode(num/*num|Null*/ v);
 /// Returns true if alpha blending should be disabled.
 external get JS$_disableAlphaBlending; external set JS$_disableAlphaBlending(v);
 /// Specifies whether or not this material should be rendered in alpha blend mode.
 external bool needAlphaBlending();
 /// Specifies if the mesh will require alpha blending.
 external bool needAlphaBlendingForMesh(AbstractMesh mesh);
 /// Specifies whether or not this material should be rendered in alpha test mode.
 external bool needAlphaTesting();
 /// Specifies whether or not the alpha value of the albedo texture should be used for alpha blending.
 external bool JS$_shouldUseAlphaFromAlbedoTexture();
 /// Gets the texture used for the alpha test.
 external BaseTexture getAlphaTestTexture();
 /// Stores the reflectivity values based on metallic roughness workflow.
 external static get JS$_scaledReflectivity; external static set JS$_scaledReflectivity(v);
 /// Specifies that the submesh is ready to be used.
 external bool isReadyForSubMesh(AbstractMesh mesh, SubMesh subMesh, [bool useInstances]);
 /// Specifies if the material uses metallic roughness workflow.
 external bool isMetallicWorkflow(); external JS$_prepareEffect(mesh, defines, [onCompiled, onError, useInstances, useClipPlane]); external JS$_prepareDefines(mesh, defines, [useInstances, useClipPlane]);
 /// Force shader compilation
 external void forceCompilation(AbstractMesh mesh, [void onCompiled(Material material), Partial<dynamic/*{
            clipPlane: boolean;
        }*/> options]);
 /// Initializes the uniform buffer layout for the shader.
 external void buildUniformLayout();
 /// Unbinds the textures.
 external void unbind();
 /// Binds the submesh data.
 external void bindForSubMesh(Matrix world, Mesh mesh, SubMesh subMesh);
 /// Returns the animatable textures.
 external List<IAnimatable> getAnimatables();
 /// Returns the texture used for reflections.
 external JS$_getReflectionTexture();
 /// Returns the texture used for refraction or null if none is used.
 /// is linked with transparency, returns environment texture.  Otherwise, returns null.
 external JS$_getRefractionTexture();
 /// Disposes the resources of the material.
 external void dispose([bool forceDisposeEffect, bool forceDisposeTextures]); }

 /// The Physically based simple base material of BJS.
 /// This enables better naming and convention enforcements on top of the pbrMaterial.
 /// It is used as the base class for both the specGloss and metalRough conventions.
 @JS("BABYLON.PBRBaseSimpleMaterial" ) abstract class PBRBaseSimpleMaterial extends PBRBaseMaterial { // @Ignore
 PBRBaseSimpleMaterial .fakeConstructor$() : super.fakeConstructor$() ;
 /// Number of Simultaneous lights allowed on the material.
 external num get maxSimultaneousLights; external set maxSimultaneousLights(num v);
 /// If sets to true, disables all the lights affecting the material.
 external bool get disableLighting; external set disableLighting(bool v);
 /// Environment Texture used in the material (this is use for both reflection and environment lighting).
 external BaseTexture get environmentTexture; external set environmentTexture(BaseTexture v);
 /// If sets to true, x component of normal map value will invert (x = 1.0 - x).
 external bool get invertNormalMapX; external set invertNormalMapX(bool v);
 /// If sets to true, y component of normal map value will invert (y = 1.0 - y).
 external bool get invertNormalMapY; external set invertNormalMapY(bool v);
 /// Normal map used in the model.
 external BaseTexture get normalTexture; external set normalTexture(BaseTexture v);
 /// Emissivie color used to self-illuminate the model.
 external Color3 get emissiveColor; external set emissiveColor(Color3 v);
 /// Emissivie texture used to self-illuminate the model.
 external BaseTexture get emissiveTexture; external set emissiveTexture(BaseTexture v);
 /// Occlusion Channel Strenght.
 external num get occlusionStrength; external set occlusionStrength(num v);
 /// Occlusion Texture of the material (adding extra occlusion effects).
 external BaseTexture get occlusionTexture; external set occlusionTexture(BaseTexture v);
 /// Defines the alpha limits in alpha test mode.
 external num get alphaCutOff; external set alphaCutOff(num v);
 /// Gets the current double sided mode.
 /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
 external bool get doubleSided; external set doubleSided(bool v); external BaseTexture get lightmapTexture; external set lightmapTexture(BaseTexture v); external bool get useLightmapAsShadowmap; external set useLightmapAsShadowmap(bool v);
 /// Return the active textures of the material.
 external List<BaseTexture> getActiveTextures(); external bool hasTexture(BaseTexture texture);
 /// Instantiates a new PBRMaterial instance.
 external factory PBRBaseSimpleMaterial(String name, Scene scene); external String getClassName(); }

 /// The Physically based material of BJS.
 /// This offers the main features of a standard PBR material.
 /// For more information, please refer to the documentation :
 /// http://doc.babylonjs.com/extensions/Physically_Based_Rendering
 @JS("BABYLON.PBRMaterial" ) class PBRMaterial extends PBRBaseMaterial { // @Ignore
 PBRMaterial .fakeConstructor$() : super.fakeConstructor$() ;
 external static get JS$_PBRMATERIAL_OPAQUE; external static set JS$_PBRMATERIAL_OPAQUE(v);
 /// PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.
 external static num get PBRMATERIAL_OPAQUE; external static set PBRMATERIAL_OPAQUE(num v);
 /// Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
 external static get JS$_PBRMATERIAL_ALPHATEST; external static set JS$_PBRMATERIAL_ALPHATEST(v);
 /// PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
 external static num get PBRMATERIAL_ALPHATEST; external static set PBRMATERIAL_ALPHATEST(num v);
 /// Represents the value for Alpha Blend.  Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
 external static get JS$_PBRMATERIAL_ALPHABLEND; external static set JS$_PBRMATERIAL_ALPHABLEND(v);
 /// PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
 external static num get PBRMATERIAL_ALPHABLEND; external static set PBRMATERIAL_ALPHABLEND(num v);
 /// Represents the value for Alpha Test and Blend.  Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
 /// They are also discarded below the alpha cutoff threshold to improve performances.
 external static get JS$_PBRMATERIAL_ALPHATESTANDBLEND; external static set JS$_PBRMATERIAL_ALPHATESTANDBLEND(v);
 /// PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
 /// They are also discarded below the alpha cutoff threshold to improve performances.
 external static num get PBRMATERIAL_ALPHATESTANDBLEND; external static set PBRMATERIAL_ALPHATESTANDBLEND(num v);
 /// Intensity of the direct lights e.g. the four lights available in your scene.
 /// This impacts both the direct diffuse and specular highlights.
 external num get directIntensity; external set directIntensity(num v);
 /// Intensity of the emissive part of the material.
 /// This helps controlling the emissive effect without modifying the emissive color.
 external num get emissiveIntensity; external set emissiveIntensity(num v);
 /// Intensity of the environment e.g. how much the environment will light the object
 /// either through harmonics for rough material or through the refelction for shiny ones.
 external num get environmentIntensity; external set environmentIntensity(num v);
 /// This is a special control allowing the reduction of the specular highlights coming from the
 /// four lights of the scene. Those highlights may not be needed in full environment lighting.
 external num get specularIntensity; external set specularIntensity(num v);
 /// Debug Control allowing disabling the bump map on this material.
 external bool get disableBumpMap; external set disableBumpMap(bool v);
 /// AKA Diffuse Texture in standard nomenclature.
 external BaseTexture get albedoTexture; external set albedoTexture(BaseTexture v);
 /// AKA Occlusion Texture in other nomenclature.
 external BaseTexture get ambientTexture; external set ambientTexture(BaseTexture v);
 /// AKA Occlusion Texture Intensity in other nomenclature.
 external num get ambientTextureStrength; external set ambientTextureStrength(num v);
 /// Stores the alpha values in a texture.
 external BaseTexture get opacityTexture; external set opacityTexture(BaseTexture v);
 /// Stores the reflection values in a texture.
 external BaseTexture/*BaseTexture|Null*/ get reflectionTexture; external set reflectionTexture(BaseTexture/*BaseTexture|Null*/ v);
 /// Stores the emissive values in a texture.
 external BaseTexture get emissiveTexture; external set emissiveTexture(BaseTexture v);
 /// AKA Specular texture in other nomenclature.
 external BaseTexture get reflectivityTexture; external set reflectivityTexture(BaseTexture v);
 /// Used to switch from specular/glossiness to metallic/roughness workflow.
 external BaseTexture get metallicTexture; external set metallicTexture(BaseTexture v);
 /// Specifies the metallic scalar of the metallic/roughness workflow.
 /// Can also be used to scale the metalness values of the metallic texture.
 external num get metallic; external set metallic(num v);
 /// Specifies the roughness scalar of the metallic/roughness workflow.
 /// Can also be used to scale the roughness values of the metallic texture.
 external num get roughness; external set roughness(num v);
 /// Used to enable roughness/glossiness fetch from a separate chanel depending on the current mode.
 /// Gray Scale represents roughness in metallic mode and glossiness in specular mode.
 external BaseTexture get microSurfaceTexture; external set microSurfaceTexture(BaseTexture v);
 /// Stores surface normal data used to displace a mesh in a texture.
 external BaseTexture get bumpTexture; external set bumpTexture(BaseTexture v);
 /// Stores the pre-calculated light information of a mesh in a texture.
 external BaseTexture get lightmapTexture; external set lightmapTexture(BaseTexture v);
 /// Stores the refracted light information in a texture.
 external BaseTexture get refractionTexture; external set refractionTexture(BaseTexture v);
 /// The color of a material in ambient lighting.
 external Color3 get ambientColor; external set ambientColor(Color3 v);
 /// AKA Diffuse Color in other nomenclature.
 external Color3 get albedoColor; external set albedoColor(Color3 v);
 /// AKA Specular Color in other nomenclature.
 external Color3 get reflectivityColor; external set reflectivityColor(Color3 v);
 /// The color reflected from the material.
 external Color3 get reflectionColor; external set reflectionColor(Color3 v);
 /// The color emitted from the material.
 external Color3 get emissiveColor; external set emissiveColor(Color3 v);
 /// AKA Glossiness in other nomenclature.
 external num get microSurface; external set microSurface(num v);
 /// source material index of refraction (IOR)' / 'destination material IOR.
 external num get indexOfRefraction; external set indexOfRefraction(num v);
 /// Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.
 external bool get invertRefractionY; external set invertRefractionY(bool v);
 /// This parameters will make the material used its opacity to control how much it is refracting aginst not.
 /// Materials half opaque for instance using refraction could benefit from this control.
 external bool get linkRefractionWithTransparency; external set linkRefractionWithTransparency(bool v); external bool get useLightmapAsShadowmap; external set useLightmapAsShadowmap(bool v);
 /// Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
 external bool get useAlphaFromAlbedoTexture; external set useAlphaFromAlbedoTexture(bool v);
 /// Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
 external bool get forceAlphaTest; external set forceAlphaTest(bool v);
 /// Defines the alpha limits in alpha test mode.
 external num get alphaCutOff; external set alphaCutOff(num v);
 /// Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).
 /// A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
 external bool get useSpecularOverAlpha; external set useSpecularOverAlpha(bool v);
 /// Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
 external bool get useMicroSurfaceFromReflectivityMapAlpha; external set useMicroSurfaceFromReflectivityMapAlpha(bool v);
 /// Specifies if the metallic texture contains the roughness information in its alpha channel.
 external bool get useRoughnessFromMetallicTextureAlpha; external set useRoughnessFromMetallicTextureAlpha(bool v);
 /// Specifies if the metallic texture contains the roughness information in its green channel.
 external bool get useRoughnessFromMetallicTextureGreen; external set useRoughnessFromMetallicTextureGreen(bool v);
 /// Specifies if the metallic texture contains the metallness information in its blue channel.
 external bool get useMetallnessFromMetallicTextureBlue; external set useMetallnessFromMetallicTextureBlue(bool v);
 /// Specifies if the metallic texture contains the ambient occlusion information in its red channel.
 external bool get useAmbientOcclusionFromMetallicTextureRed; external set useAmbientOcclusionFromMetallicTextureRed(bool v);
 /// Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
 external bool get useAmbientInGrayScale; external set useAmbientInGrayScale(bool v);
 /// In case the reflectivity map does not contain the microsurface information in its alpha channel,
 /// The material will try to infer what glossiness each pixel should be.
 external bool get useAutoMicroSurfaceFromReflectivityMap; external set useAutoMicroSurfaceFromReflectivityMap(bool v);
 /// BJS is using an harcoded light falloff based on a manually sets up range.
 /// In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
 /// This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
 external bool get usePhysicalLightFalloff; external set usePhysicalLightFalloff(bool v);
 /// Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
 /// A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
 external bool get useRadianceOverAlpha; external set useRadianceOverAlpha(bool v);
 /// Allows using an object space normal map (instead of tangent space).
 external bool get useObjectSpaceNormalMap; external set useObjectSpaceNormalMap(bool v);
 /// Allows using the bump map in parallax mode.
 external bool get useParallax; external set useParallax(bool v);
 /// Allows using the bump map in parallax occlusion mode.
 external bool get useParallaxOcclusion; external set useParallaxOcclusion(bool v);
 /// Controls the scale bias of the parallax mode.
 external num get parallaxScaleBias; external set parallaxScaleBias(num v);
 /// If sets to true, disables all the lights affecting the material.
 external bool get disableLighting; external set disableLighting(bool v);
 /// Force the shader to compute irradiance in the fragment shader in order to take bump in account.
 external bool get forceIrradianceInFragment; external set forceIrradianceInFragment(bool v);
 /// Number of Simultaneous lights allowed on the material.
 external num get maxSimultaneousLights; external set maxSimultaneousLights(num v);
 /// If sets to true, x component of normal map value will invert (x = 1.0 - x).
 external bool get invertNormalMapX; external set invertNormalMapX(bool v);
 /// If sets to true, y component of normal map value will invert (y = 1.0 - y).
 external bool get invertNormalMapY; external set invertNormalMapY(bool v);
 /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
 external bool get twoSidedLighting; external set twoSidedLighting(bool v);
 /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
 /// And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
 external bool get useAlphaFresnel; external set useAlphaFresnel(bool v);
 /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
 /// And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
 external bool get useLinearAlphaFresnel; external set useLinearAlphaFresnel(bool v);
 /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
 /// And/Or occlude the blended part.
 external BaseTexture/*BaseTexture|Null*/ get environmentBRDFTexture; external set environmentBRDFTexture(BaseTexture/*BaseTexture|Null*/ v);
 /// Force normal to face away from face.
 external bool get forceNormalForward; external set forceNormalForward(bool v);
 /// Enables specular anti aliasing in the PBR shader.
 /// It will both interacts on the Geometry for analytical and IBL lighting.
 /// It also prefilter the roughness map based on the bump values.
 external bool get enableSpecularAntiAliasing; external set enableSpecularAntiAliasing(bool v);
 /// This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
 /// makes the reflect vector face the model (under horizon).
 external bool get useHorizonOcclusion; external set useHorizonOcclusion(bool v);
 /// This parameters will enable/disable radiance occlusion by preventing the radiance to lit
 /// too much the area relying on ambient texture to define their ambient occlusion.
 external bool get useRadianceOcclusion; external set useRadianceOcclusion(bool v);
 /// If set to true, no lighting calculations will be applied.
 external bool get unlit; external set unlit(bool v);
 /// Gets the image processing configuration used either in this material.
 /// Sets the Default image processing configuration used either in the this material.
 /// If sets to null, the scene one is in use.
 external ImageProcessingConfiguration get imageProcessingConfiguration; external set imageProcessingConfiguration(ImageProcessingConfiguration v);
 /// Gets wether the color curves effect is enabled.
 /// Sets wether the color curves effect is enabled.
 external bool get cameraColorCurvesEnabled; external set cameraColorCurvesEnabled(bool v);
 /// Gets wether the color grading effect is enabled.
 /// Gets wether the color grading effect is enabled.
 external bool get cameraColorGradingEnabled; external set cameraColorGradingEnabled(bool v);
 /// Gets wether tonemapping is enabled or not.
 /// Sets wether tonemapping is enabled or not
 external bool get cameraToneMappingEnabled; external set cameraToneMappingEnabled(bool v);
 /// The camera exposure used on this material.
 /// This property is here and not in the camera to allow controlling exposure without full screen post process.
 /// This corresponds to a photographic exposure.
 /// The camera exposure used on this material.
 /// This property is here and not in the camera to allow controlling exposure without full screen post process.
 /// This corresponds to a photographic exposure.
 external num get cameraExposure; external set cameraExposure(num v);
 /// Gets The camera contrast used on this material.
 /// Sets The camera contrast used on this material.
 external num get cameraContrast; external set cameraContrast(num v);
 /// Gets the Color Grading 2D Lookup Texture.
 /// Sets the Color Grading 2D Lookup Texture.
 external BaseTexture/*BaseTexture|Null*/ get cameraColorGradingTexture; external set cameraColorGradingTexture(BaseTexture/*BaseTexture|Null*/ v);
 /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
 /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
 /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
 /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
 /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
 /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
 /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
 /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
 external ColorCurves/*ColorCurves|Null*/ get cameraColorCurves; external set cameraColorCurves(ColorCurves/*ColorCurves|Null*/ v);
 /// Instantiates a new PBRMaterial instance.
 external factory PBRMaterial(String name, Scene scene);
 /// Returns the name of this material class.
 external String getClassName();
 /// Returns an array of the actively used textures.
 external List<BaseTexture> getActiveTextures();
 /// Checks to see if a texture is used in the material.
 external bool hasTexture(BaseTexture texture);
 /// Makes a duplicate of the current material.
 external PBRMaterial clone(String name);
 /// Serializes this PBR Material.
 external dynamic serialize();
 /// Parses a PBR Material from a serialized object.
 external static PBRMaterial Parse(dynamic source, Scene scene, String rootUrl); }

 /// The PBR material of BJS following the metal roughness convention.
 /// This fits to the PBR convention in the GLTF definition:
 /// https://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0
 @JS("BABYLON.PBRMetallicRoughnessMaterial" ) class PBRMetallicRoughnessMaterial extends PBRBaseSimpleMaterial { // @Ignore
 PBRMetallicRoughnessMaterial .fakeConstructor$() : super.fakeConstructor$() ;
 /// The base color has two different interpretations depending on the value of metalness.
 /// When the material is a metal, the base color is the specific measured reflectance value
 /// at normal incidence (F0). For a non-metal the base color represents the reflected diffuse color
 /// of the material.
 external Color3 get baseColor; external set baseColor(Color3 v);
 /// Base texture of the metallic workflow. It contains both the baseColor information in RGB as
 /// well as opacity information in the alpha channel.
 external BaseTexture get baseTexture; external set baseTexture(BaseTexture v);
 /// Specifies the metallic scalar value of the material.
 /// Can also be used to scale the metalness values of the metallic texture.
 external num get metallic; external set metallic(num v);
 /// Specifies the roughness scalar value of the material.
 /// Can also be used to scale the roughness values of the metallic texture.
 external num get roughness; external set roughness(num v);
 /// Texture containing both the metallic value in the B channel and the
 /// roughness value in the G channel to keep better precision.
 external BaseTexture get metallicRoughnessTexture; external set metallicRoughnessTexture(BaseTexture v);
 /// Instantiates a new PBRMetalRoughnessMaterial instance.
 external factory PBRMetallicRoughnessMaterial(String name, Scene scene);
 /// Return the currrent class name of the material.
 external String getClassName();
 /// Return the active textures of the material.
 external List<BaseTexture> getActiveTextures();
 /// Checks to see if a texture is used in the material.
 external bool hasTexture(BaseTexture texture);
 /// Makes a duplicate of the current material.
 external PBRMetallicRoughnessMaterial clone(String name);
 /// Serialize the material to a parsable JSON object.
 external dynamic serialize();
 /// Parses a JSON object correponding to the serialize function.
 external static PBRMetallicRoughnessMaterial Parse(dynamic source, Scene scene, String rootUrl); }

 /// The PBR material of BJS following the specular glossiness convention.
 /// This fits to the PBR convention in the GLTF definition:
 /// https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
 @JS("BABYLON.PBRSpecularGlossinessMaterial" ) class PBRSpecularGlossinessMaterial extends PBRBaseSimpleMaterial { // @Ignore
 PBRSpecularGlossinessMaterial .fakeConstructor$() : super.fakeConstructor$() ;
 /// Specifies the diffuse color of the material.
 external Color3 get diffuseColor; external set diffuseColor(Color3 v);
 /// Specifies the diffuse texture of the material. This can also contains the opcity value in its alpha
 /// channel.
 external BaseTexture get diffuseTexture; external set diffuseTexture(BaseTexture v);
 /// Specifies the specular color of the material. This indicates how reflective is the material (none to mirror).
 external Color3 get specularColor; external set specularColor(Color3 v);
 /// Specifies the glossiness of the material. This indicates "how sharp is the reflection".
 external num get glossiness; external set glossiness(num v);
 /// Specifies both the specular color RGB and the glossiness A of the material per pixels.
 external BaseTexture get specularGlossinessTexture; external set specularGlossinessTexture(BaseTexture v);
 /// Instantiates a new PBRSpecularGlossinessMaterial instance.
 external factory PBRSpecularGlossinessMaterial(String name, Scene scene);
 /// Return the currrent class name of the material.
 external String getClassName();
 /// Return the active textures of the material.
 external List<BaseTexture> getActiveTextures();
 /// Checks to see if a texture is used in the material.
 external bool hasTexture(BaseTexture texture);
 /// Makes a duplicate of the current material.
 external PBRSpecularGlossinessMaterial clone(String name);
 /// Serialize the material to a parsable JSON object.
 external dynamic serialize();
 /// Parses a JSON object correponding to the serialize function.
 external static PBRSpecularGlossinessMaterial Parse(dynamic source, Scene scene, String rootUrl); }

 @JS("BABYLON.BaseTexture" ) class BaseTexture { // @Ignore
 BaseTexture .fakeConstructor$() ;
 external static num get DEFAULT_ANISOTROPIC_FILTERING_LEVEL; external static set DEFAULT_ANISOTROPIC_FILTERING_LEVEL(num v); external String get name; external set name(String v); external get JS$_hasAlpha; external set JS$_hasAlpha(v); external bool get hasAlpha; external set hasAlpha(bool v); external bool get getAlphaFromRGB; external set getAlphaFromRGB(bool v); external num get level; external set level(num v); external num get coordinatesIndex; external set coordinatesIndex(num v); external get JS$_coordinatesMode; external set JS$_coordinatesMode(v);
 /// How a texture is mapped.
 /// | Value | Type                                | Description |
 /// | ----- | ----------------------------------- | ----------- |
 /// | 0     | EXPLICIT_MODE                       |             |
 /// | 1     | SPHERICAL_MODE                      |             |
 /// | 2     | PLANAR_MODE                         |             |
 /// | 3     | CUBIC_MODE                          |             |
 /// | 4     | PROJECTION_MODE                     |             |
 /// | 5     | SKYBOX_MODE                         |             |
 /// | 6     | INVCUBIC_MODE                       |             |
 /// | 7     | EQUIRECTANGULAR_MODE                |             |
 /// | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |
 /// | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |
 external num get coordinatesMode; external set coordinatesMode(num v);
 /// | Value | Type               | Description |
 /// | ----- | ------------------ | ----------- |
 /// | 0     | CLAMP_ADDRESSMODE  |             |
 /// | 1     | WRAP_ADDRESSMODE   |             |
 /// | 2     | MIRROR_ADDRESSMODE |             |
 external num get wrapU; external set wrapU(num v);
 /// | Value | Type               | Description |
 /// | ----- | ------------------ | ----------- |
 /// | 0     | CLAMP_ADDRESSMODE  |             |
 /// | 1     | WRAP_ADDRESSMODE   |             |
 /// | 2     | MIRROR_ADDRESSMODE |             |
 external num get wrapV; external set wrapV(num v);
 /// | Value | Type               | Description |
 /// | ----- | ------------------ | ----------- |
 /// | 0     | CLAMP_ADDRESSMODE  |             |
 /// | 1     | WRAP_ADDRESSMODE   |             |
 /// | 2     | MIRROR_ADDRESSMODE |             |
 external num get wrapR; external set wrapR(num v); external num get anisotropicFilteringLevel; external set anisotropicFilteringLevel(num v); external bool get isCube; external set isCube(bool v); external bool get is3D; external set is3D(bool v); external bool get gammaSpace; external set gammaSpace(bool v); external bool get invertZ; external set invertZ(bool v); external bool get lodLevelInAlpha; external set lodLevelInAlpha(bool v); external num get lodGenerationOffset; external set lodGenerationOffset(num v); external num get lodGenerationScale; external set lodGenerationScale(num v); external bool get isRenderTarget; external set isRenderTarget(bool v); external String get uid; external set uid(String v); external String toString(); external String getClassName(); external List<Animation> get animations; external set animations(List<Animation> v);
 /// An event triggered when the texture is disposed.
 external Observable<BaseTexture> get onDisposeObservable; external set onDisposeObservable(Observable<BaseTexture> v); external get JS$_onDisposeObserver; external set JS$_onDisposeObserver(v); external VoidFunc0 get onDispose; external set onDispose(VoidFunc0 v); external num get delayLoadState; external set delayLoadState(num v); external get JS$_scene; external set JS$_scene(v); external InternalTexture/*InternalTexture|Null*/ get JS$_texture; external set JS$_texture(InternalTexture/*InternalTexture|Null*/ v); external get JS$_uid; external set JS$_uid(v); external bool get isBlocking; external set isBlocking(bool v); external factory BaseTexture(Scene/*Scene|Null*/ scene); external Scene/*Scene|Null*/ getScene(); external Matrix getTextureMatrix(); external Matrix getReflectionTextureMatrix(); external InternalTexture/*InternalTexture|Null*/ getInternalTexture(); external bool isReadyOrNotBlocking(); external bool isReady(); external ISize getSize(); external ISize getBaseSize(); external void scale(num ratio); external bool get canRescale; external set canRescale(bool v); external InternalTexture/*InternalTexture|Null*/ JS$_getFromCache(String/*String|Null*/ url, bool noMipmap, [num sampling]); external void JS$_rebuild(); external void delayLoad(); external BaseTexture/*BaseTexture|Null*/ clone(); external num get textureType; external set textureType(num v); external num get textureFormat; external set textureFormat(num v); external TypedData/*TypedData|Null*/ readPixels([num faceIndex]); external void releaseInternalTexture(); external SphericalPolynomial/*SphericalPolynomial|Null*/ get sphericalPolynomial; external set sphericalPolynomial(SphericalPolynomial/*SphericalPolynomial|Null*/ v); external BaseTexture/*BaseTexture|Null*/ get JS$_lodTextureHigh; external set JS$_lodTextureHigh(BaseTexture/*BaseTexture|Null*/ v); external BaseTexture/*BaseTexture|Null*/ get JS$_lodTextureMid; external set JS$_lodTextureMid(BaseTexture/*BaseTexture|Null*/ v); external BaseTexture/*BaseTexture|Null*/ get JS$_lodTextureLow; external set JS$_lodTextureLow(BaseTexture/*BaseTexture|Null*/ v); external void dispose(); external dynamic serialize(); external static void WhenAllReady(List<BaseTexture> textures, void callback()); }

 /// This represents a color grading texture. This acts as a lookup table LUT, useful during post process
 /// It can help converting any input color in a desired output one. This can then be used to create effects
 /// from sepia, black and white to sixties or futuristic rendering...
 /// The only supported format is currently 3dl.
 /// More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table/
 @JS("BABYLON.ColorGradingTexture" ) class ColorGradingTexture extends BaseTexture { // @Ignore
 ColorGradingTexture .fakeConstructor$() : super.fakeConstructor$() ;
 /// The current texture matrix. (will always be identity in color grading texture)
 external get JS$_textureMatrix; external set JS$_textureMatrix(v);
 /// The texture URL.
 external String get url; external set url(String v);
 /// Empty line regex stored for GC.
 external static get JS$_noneEmptyLineRegex; external static set JS$_noneEmptyLineRegex(v); external get JS$_engine; external set JS$_engine(v);
 /// Instantiates a ColorGradingTexture from the following parameters.
 external factory ColorGradingTexture(String url, Scene scene);
 /// Returns the texture matrix used in most of the material.
 /// This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).
 external Matrix getTextureMatrix();
 /// Occurs when the file being loaded is a .3dl LUT file.
 external load3dlTexture();
 /// Starts the loading process of the texture.
 external loadTexture();
 /// Clones the color gradind texture.
 external ColorGradingTexture clone();
 /// Called during delayed load for textures.
 external void delayLoad();
 /// Parses a color grading texture serialized by Babylon.
 external static ColorGradingTexture/*ColorGradingTexture|Null*/ Parse(dynamic parsedTexture, Scene scene, String rootUrl);
 /// Serializes the LUT texture to json format.
 external dynamic serialize(); }

 @JS("BABYLON.CubeTexture" ) class CubeTexture extends BaseTexture { // @Ignore
 CubeTexture .fakeConstructor$() : super.fakeConstructor$() ;
 external String get url; external set url(String v); external num get coordinatesMode; external set coordinatesMode(num v);
 /// Gets or sets the center of the bounding box associated with the cube texture
 /// It must define where the camera used to render the texture was set
 external Vector3 get boundingBoxPosition; external set boundingBoxPosition(Vector3 v); external get JS$_boundingBoxSize; external set JS$_boundingBoxSize(v);
 /// Gets or sets the size of the bounding box associated with the cube texture
 /// When defined, the cubemap will switch to local mode
 /// @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
 /// @example https://www.babylonjs-playground.com/#RNASML
 external Vector3 get boundingBoxSize; external set boundingBoxSize(Vector3 v); external num get JS$_rotationY; external set JS$_rotationY(num v);
 /// Gets texture matrix rotation angle around Y axis radians.
 /// Sets texture matrix rotation angle around Y axis in radians.
 external num get rotationY; external set rotationY(num v); external get JS$_noMipmap; external set JS$_noMipmap(v); external get JS$_files; external set JS$_files(v); external get JS$_extensions; external set JS$_extensions(v); external get JS$_textureMatrix; external set JS$_textureMatrix(v); external get JS$_format; external set JS$_format(v); external get JS$_prefiltered; external set JS$_prefiltered(v); external static CubeTexture CreateFromImages(List<String> files, Scene scene, [bool noMipmap]); external static CubeTexture CreateFromPrefilteredData(String url, Scene scene, [dynamic forcedExtension]); external factory CubeTexture(String rootUrl, Scene scene, [List<String>/*List<String>|Null*/ extensions, bool noMipmap, List<String>/*List<String>|Null*/ files, VoidFunc0/*VoidFunc0|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, num format, bool prefiltered, dynamic forcedExtension]); external void delayLoad(); external Matrix getReflectionTextureMatrix(); external void setReflectionTextureMatrix(Matrix value); external static CubeTexture Parse(dynamic parsedTexture, Scene scene, String rootUrl); external CubeTexture clone(); }

 /// A class extending {BABYLON.Texture} allowing drawing on a texture
 /// @see http://doc.babylonjs.com/how_to/dynamictexture
 @JS("BABYLON.DynamicTexture" ) class DynamicTexture extends Texture { // @Ignore
 DynamicTexture .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_generateMipMaps; external set JS$_generateMipMaps(v); external get JS$_canvas; external set JS$_canvas(v); external get JS$_context; external set JS$_context(v); external get JS$_engine; external set JS$_engine(v);
 /// Creates a {BABYLON.DynamicTexture}
 external factory DynamicTexture(String name, dynamic options, dynamic/*Scene|Null|dynamic*/ scene, bool generateMipMaps, [num samplingMode, num format]);
 /// Gets the current state of canRescale
 external bool get canRescale; external set canRescale(bool v); external JS$_recreate(textureSize);
 /// Scales the texture
 external void scale(num ratio);
 /// Resizes the texture
 external void scaleTo(num width, num height);
 /// Gets the context of the canvas used by the texture
 external CanvasRenderingContext2D getContext();
 /// Clears the texture
 external void clear();
 /// Updates the texture
 external void update([bool invertY]);
 /// Draws text onto the texture
 external void drawText(String text, num x, num y, String font, String color, String clearColor, [bool invertY, bool update]);
 /// Clones the texture
 external DynamicTexture clone();
 /// @hidden
 external void JS$_rebuild(); }

 /// This represents a texture coming from an HDR input.
 /// The only supported format is currently panorama picture stored in RGBE format.
 /// Example of such files can be found on HDRLib: http://hdrlib.com/
 @JS("BABYLON.HDRCubeTexture" ) class HDRCubeTexture extends BaseTexture { // @Ignore
 HDRCubeTexture .fakeConstructor$() : super.fakeConstructor$() ;
 external static get JS$_facesMapping; external static set JS$_facesMapping(v); external get JS$_generateHarmonics; external set JS$_generateHarmonics(v); external get JS$_noMipmap; external set JS$_noMipmap(v); external get JS$_textureMatrix; external set JS$_textureMatrix(v); external get JS$_size; external set JS$_size(v); external get JS$_onLoad; external set JS$_onLoad(v); external get JS$_onError; external set JS$_onError(v);
 /// The texture URL.
 external String get url; external set url(String v);
 /// The texture coordinates mode. As this texture is stored in a cube format, please modify carefully.
 external num get coordinatesMode; external set coordinatesMode(num v); external bool get JS$_isBlocking; external set JS$_isBlocking(bool v);
 /// Gets wether or not the texture is blocking during loading.
 /// Sets wether or not the texture is blocking during loading.
 external bool get isBlocking; external set isBlocking(bool v); external num get JS$_rotationY; external set JS$_rotationY(num v);
 /// Gets texture matrix rotation angle around Y axis radians.
 /// Sets texture matrix rotation angle around Y axis in radians.
 external num get rotationY; external set rotationY(num v);
 /// Gets or sets the center of the bounding box associated with the cube texture
 /// It must define where the camera used to render the texture was set
 external Vector3 get boundingBoxPosition; external set boundingBoxPosition(Vector3 v); external get JS$_boundingBoxSize; external set JS$_boundingBoxSize(v);
 /// Gets or sets the size of the bounding box associated with the cube texture
 /// When defined, the cubemap will switch to local mode
 /// @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
 /// @example https://www.babylonjs-playground.com/#RNASML
 external Vector3 get boundingBoxSize; external set boundingBoxSize(Vector3 v);
 /// Instantiates an HDRTexture from the following parameters.
 external factory HDRCubeTexture(String url, Scene scene, num size, [bool noMipmap, bool generateHarmonics, bool gammaSpace, bool reserved, VoidFunc0/*VoidFunc0|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError]);
 /// Occurs when the file is raw .hdr file.
 external loadTexture(); external HDRCubeTexture clone(); external void delayLoad(); external Matrix getReflectionTextureMatrix(); external void setReflectionTextureMatrix(Matrix value); external static HDRCubeTexture/*HDRCubeTexture|Null*/ Parse(dynamic parsedTexture, Scene scene, String rootUrl); external dynamic serialize(); }

 /// Class used to store data associated with WebGL texture data for the engine
 /// This class should not be used directly
 @JS("BABYLON.InternalTexture" ) class InternalTexture implements IInternalTextureTracker { // @Ignore
 InternalTexture .fakeConstructor$() ;
 /// The source of the texture data is unknown
 external static num get DATASOURCE_UNKNOWN; external static set DATASOURCE_UNKNOWN(num v);
 /// Texture data comes from an URL
 external static num get DATASOURCE_URL; external static set DATASOURCE_URL(num v);
 /// Texture data is only used for temporary storage
 external static num get DATASOURCE_TEMP; external static set DATASOURCE_TEMP(num v);
 /// Texture data comes from raw data (ArrayBuffer)
 external static num get DATASOURCE_RAW; external static set DATASOURCE_RAW(num v);
 /// Texture content is dynamic (video or dynamic texture)
 external static num get DATASOURCE_DYNAMIC; external static set DATASOURCE_DYNAMIC(num v);
 /// Texture content is generated by rendering to it
 external static num get DATASOURCE_RENDERTARGET; external static set DATASOURCE_RENDERTARGET(num v);
 /// Texture content is part of a multi render target process
 external static num get DATASOURCE_MULTIRENDERTARGET; external static set DATASOURCE_MULTIRENDERTARGET(num v);
 /// Texture data comes from a cube data file
 external static num get DATASOURCE_CUBE; external static set DATASOURCE_CUBE(num v);
 /// Texture data comes from a raw cube data
 external static num get DATASOURCE_CUBERAW; external static set DATASOURCE_CUBERAW(num v);
 /// Texture data come from a prefiltered cube data file
 external static num get DATASOURCE_CUBEPREFILTERED; external static set DATASOURCE_CUBEPREFILTERED(num v);
 /// Texture content is raw 3D data
 external static num get DATASOURCE_RAW3D; external static set DATASOURCE_RAW3D(num v);
 /// Texture content is a depth texture
 external static num get DATASOURCE_DEPTHTEXTURE; external static set DATASOURCE_DEPTHTEXTURE(num v);
 /// Defines if the texture is ready
 external bool get isReady; external set isReady(bool v);
 /// Defines if the texture is a cube texture
 external bool get isCube; external set isCube(bool v);
 /// Defines if the texture contains 3D data
 external bool get is3D; external set is3D(bool v);
 /// Gets the URL used to load this texture
 external String get url; external set url(String v);
 /// Gets the sampling mode of the texture
 external num get samplingMode; external set samplingMode(num v);
 /// Gets a boolean indicating if the texture needs mipmaps generation
 external bool get generateMipMaps; external set generateMipMaps(bool v);
 /// Gets the number of samples used by the texture (WebGL2+ only)
 external num get samples; external set samples(num v);
 /// Gets the type of the texture
 external num get type; external set type(num v);
 /// Gets the format of the texture
 external num get format; external set format(num v);
 /// Observable called when the texture is loaded
 external Observable<InternalTexture> get onLoadedObservable; external set onLoadedObservable(Observable<InternalTexture> v);
 /// Gets the width of the texture
 external num get width; external set width(num v);
 /// Gets the height of the texture
 external num get height; external set height(num v);
 /// Gets the depth of the texture
 external num get depth; external set depth(num v);
 /// Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)
 external num get baseWidth; external set baseWidth(num v);
 /// Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)
 external num get baseHeight; external set baseHeight(num v);
 /// Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)
 external num get baseDepth; external set baseDepth(num v);
 /// Gets a boolean indicating if the texture is inverted on Y axis
 external bool get invertY; external set invertY(bool v);
 /// Gets or set the previous tracker in the list
 external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get previous; external set previous(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v);
 /// Gets or set the next tracker in the list
 external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get next; external set next(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v);
 /// @hidden
 external num get JS$_initialSlot; external set JS$_initialSlot(num v);
 /// @hidden
 external num get JS$_designatedSlot; external set JS$_designatedSlot(num v);
 /// @hidden
 external num get JS$_dataSource; external set JS$_dataSource(num v);
 /// @hidden
 external dynamic/*ByteBuffer|ImageElement|Null*/ get JS$_buffer; external set JS$_buffer(dynamic/*ByteBuffer|ImageElement|Null*/ v);
 /// @hidden
 external TypedData/*TypedData|Null*/ get JS$_bufferView; external set JS$_bufferView(TypedData/*TypedData|Null*/ v);
 /// @hidden
 external List<TypedData>/*List<TypedData>|Null*/ get JS$_bufferViewArray; external set JS$_bufferViewArray(List<TypedData>/*List<TypedData>|Null*/ v);
 /// @hidden
 external num get JS$_size; external set JS$_size(num v);
 /// @hidden
 external String get JS$_extension; external set JS$_extension(String v);
 /// @hidden
 external List<String>/*List<String>|Null*/ get JS$_files; external set JS$_files(List<String>/*List<String>|Null*/ v);
 /// @hidden
 external CanvasElement get JS$_workingCanvas; external set JS$_workingCanvas(CanvasElement v);
 /// @hidden
 external CanvasRenderingContext2D get JS$_workingContext; external set JS$_workingContext(CanvasRenderingContext2D v);
 /// @hidden
 external Framebuffer/*Framebuffer|Null*/ get JS$_framebuffer; external set JS$_framebuffer(Framebuffer/*Framebuffer|Null*/ v);
 /// @hidden
 external Renderbuffer/*Renderbuffer|Null*/ get JS$_depthStencilBuffer; external set JS$_depthStencilBuffer(Renderbuffer/*Renderbuffer|Null*/ v);
 /// @hidden
 external Framebuffer/*Framebuffer|Null*/ get JS$_MSAAFramebuffer; external set JS$_MSAAFramebuffer(Framebuffer/*Framebuffer|Null*/ v);
 /// @hidden
 external Renderbuffer/*Renderbuffer|Null*/ get JS$_MSAARenderBuffer; external set JS$_MSAARenderBuffer(Renderbuffer/*Renderbuffer|Null*/ v);
 /// @hidden
 external List<num>/*List<num>|Null*/ get JS$_attachments; external set JS$_attachments(List<num>/*List<num>|Null*/ v);
 /// @hidden
 external num/*num|Null*/ get JS$_cachedCoordinatesMode; external set JS$_cachedCoordinatesMode(num/*num|Null*/ v);
 /// @hidden
 external num/*num|Null*/ get JS$_cachedWrapU; external set JS$_cachedWrapU(num/*num|Null*/ v);
 /// @hidden
 external num/*num|Null*/ get JS$_cachedWrapV; external set JS$_cachedWrapV(num/*num|Null*/ v);
 /// @hidden
 external num/*num|Null*/ get JS$_cachedWrapR; external set JS$_cachedWrapR(num/*num|Null*/ v);
 /// @hidden
 external num/*num|Null*/ get JS$_cachedAnisotropicFilteringLevel; external set JS$_cachedAnisotropicFilteringLevel(num/*num|Null*/ v);
 /// @hidden
 external bool get JS$_isDisabled; external set JS$_isDisabled(bool v);
 /// @hidden
 external String/*String|Null*/ get JS$_compression; external set JS$_compression(String/*String|Null*/ v);
 /// @hidden
 external bool get JS$_generateStencilBuffer; external set JS$_generateStencilBuffer(bool v);
 /// @hidden
 external bool get JS$_generateDepthBuffer; external set JS$_generateDepthBuffer(bool v);
 /// @hidden
 external num get JS$_comparisonFunction; external set JS$_comparisonFunction(num v);
 /// @hidden
 external SphericalPolynomial/*SphericalPolynomial|Null*/ get JS$_sphericalPolynomial; external set JS$_sphericalPolynomial(SphericalPolynomial/*SphericalPolynomial|Null*/ v);
 /// @hidden
 external num get JS$_lodGenerationScale; external set JS$_lodGenerationScale(num v);
 /// @hidden
 external num get JS$_lodGenerationOffset; external set JS$_lodGenerationOffset(num v);
 /// @hidden
 external BaseTexture get JS$_lodTextureHigh; external set JS$_lodTextureHigh(BaseTexture v);
 /// @hidden
 external BaseTexture get JS$_lodTextureMid; external set JS$_lodTextureMid(BaseTexture v);
 /// @hidden
 external BaseTexture get JS$_lodTextureLow; external set JS$_lodTextureLow(BaseTexture v);
 /// @hidden
 external Texture/*Texture|Null*/ get JS$_webGLTexture; external set JS$_webGLTexture(Texture/*Texture|Null*/ v);
 /// @hidden
 external num get JS$_references; external set JS$_references(num v); external get JS$_engine; external set JS$_engine(v);
 /// Gets the data source type of the texture (can be one of the BABYLON.InternalTexture.DATASOURCE_XXXX)
 external num get dataSource; external set dataSource(num v);
 /// Creates a new InternalTexture
 external factory InternalTexture(Engine engine, num dataSource);
 /// Increments the number of references (ie. the number of {BABYLON.Texture} that point to it)
 external void incrementReferences();
 /// Change the size of the texture (not the size of the content)
 external void updateSize(num width, num height, [num depth]);
 /// @hidden
 external void JS$_rebuild(); external JS$_swapAndDie(target);
 /// Dispose the current allocated resources
 external void dispose(); }

 /// Internal interface used to track {BABYLON.InternalTexture} already bound to the GL context
 @anonymous @JS() abstract class IInternalTextureTracker {
 /// Gets or set the previous tracker in the list
 external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get previous; external set previous(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v);
 /// Gets or set the next tracker in the list
 external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get next; external set next(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v); external factory IInternalTextureTracker({ IInternalTextureTracker/*IInternalTextureTracker|Null*/ previous, IInternalTextureTracker/*IInternalTextureTracker|Null*/ next}); }

 /// Internal class used by the engine to get list of {BABYLON.InternalTexture} already bound to the GL context
 @JS("BABYLON.DummyInternalTextureTracker" ) class DummyInternalTextureTracker { // @Ignore
 DummyInternalTextureTracker .fakeConstructor$() ;
 /// Gets or set the previous tracker in the list
 external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get previous; external set previous(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v);
 /// Gets or set the next tracker in the list
 external IInternalTextureTracker/*IInternalTextureTracker|Null*/ get next; external set next(IInternalTextureTracker/*IInternalTextureTracker|Null*/ v); }

 @JS("BABYLON.MirrorTexture" ) class MirrorTexture extends RenderTargetTexture { // @Ignore
 MirrorTexture .fakeConstructor$() : super.fakeConstructor$() ;
 external get scene; external set scene(v); external Plane get mirrorPlane; external set mirrorPlane(Plane v); external get JS$_transformMatrix; external set JS$_transformMatrix(v); external get JS$_mirrorMatrix; external set JS$_mirrorMatrix(v); external get JS$_savedViewMatrix; external set JS$_savedViewMatrix(v); external get JS$_blurX; external set JS$_blurX(v); external get JS$_blurY; external set JS$_blurY(v); external get JS$_adaptiveBlurKernel; external set JS$_adaptiveBlurKernel(v); external get JS$_blurKernelX; external set JS$_blurKernelX(v); external get JS$_blurKernelY; external set JS$_blurKernelY(v); external get JS$_blurRatio; external set JS$_blurRatio(v); external num get blurRatio; external set blurRatio(num v); external num get adaptiveBlurKernel; external set adaptiveBlurKernel(num v); external num get blurKernel; external set blurKernel(num v); external num get blurKernelX; external set blurKernelX(num v); external num get blurKernelY; external set blurKernelY(num v); external JS$_autoComputeBlurKernel(); external void JS$_onRatioRescale(); external JS$_updateGammaSpace(); external get JS$_imageProcessingConfigChangeObserver; external set JS$_imageProcessingConfigChangeObserver(v); external factory MirrorTexture(String name, dynamic/*num|{
            width: number;
            height: number;
        }|{
            ratio: number;
        }*/ size, Scene scene, [bool generateMipMaps, num type, num samplingMode, bool generateDepthBuffer]); external JS$_preparePostProcesses(); external MirrorTexture clone(); external dynamic serialize(); external void dispose(); }

 @anonymous @JS() abstract class IMultiRenderTargetOptions { external bool get generateMipMaps; external set generateMipMaps(bool v); external List<num> get types; external set types(List<num> v); external List<num> get samplingModes; external set samplingModes(List<num> v); external bool get generateDepthBuffer; external set generateDepthBuffer(bool v); external bool get generateStencilBuffer; external set generateStencilBuffer(bool v); external bool get generateDepthTexture; external set generateDepthTexture(bool v); external num get textureCount; external set textureCount(num v); external bool get doNotChangeAspectRatio; external set doNotChangeAspectRatio(bool v); external num get defaultType; external set defaultType(num v); external factory IMultiRenderTargetOptions({ bool generateMipMaps, List<num> types, List<num> samplingModes, bool generateDepthBuffer, bool generateStencilBuffer, bool generateDepthTexture, num textureCount, bool doNotChangeAspectRatio, num defaultType}); }

 @JS("BABYLON.MultiRenderTarget" ) class MultiRenderTarget extends RenderTargetTexture { // @Ignore
 MultiRenderTarget .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_internalTextures; external set JS$_internalTextures(v); external get JS$_textures; external set JS$_textures(v); external bool get isSupported; external set isSupported(bool v); external get JS$_multiRenderTargetOptions; external set JS$_multiRenderTargetOptions(v); external List<Texture> get textures; external set textures(List<Texture> v); external Texture get depthTexture; external set depthTexture(Texture v); external num get wrapU; external set wrapU(num v); external num get wrapV; external set wrapV(num v); external factory MultiRenderTarget(String name, dynamic size, num count, Scene scene, [IMultiRenderTargetOptions options]); external void JS$_rebuild(); external JS$_createInternalTextures(); external JS$_createTextures(); external num get samples; external set samples(num v); external void resize(dynamic size); external void unbindFrameBuffer(Engine engine, num faceIndex); external void dispose(); external void releaseInternalTextures(); }

 @JS("BABYLON.RawTexture" ) class RawTexture extends Texture { // @Ignore
 RawTexture .fakeConstructor$() : super.fakeConstructor$() ;
 external num get format; external set format(num v); external get JS$_engine; external set JS$_engine(v); external factory RawTexture(TypedData data, num width, num height, num format, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode, num type]); external void update(TypedData data); external static RawTexture CreateLuminanceTexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode]); external static RawTexture CreateLuminanceAlphaTexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode]); external static RawTexture CreateAlphaTexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode]); external static RawTexture CreateRGBTexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode, num type]); external static RawTexture CreateRGBATexture(TypedData data, num width, num height, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode, num type]); }

 /// Class used to store 3D textures containing user data
 @JS("BABYLON.RawTexture3D" ) class RawTexture3D extends Texture { // @Ignore
 RawTexture3D .fakeConstructor$() : super.fakeConstructor$() ;
 /// Gets or sets the texture format to use
 external num get format; external set format(num v); external get JS$_engine; external set JS$_engine(v);
 /// Create a new RawTexture3D
 external factory RawTexture3D(TypedData data, num width, num height, num depth,
 /// Gets or sets the texture format to use
 num format, Scene scene, [bool generateMipMaps, bool invertY, num samplingMode]);
 /// Update the texture with new data
 external void update(TypedData data); }

 /// Creates a refraction texture used by refraction channel of the standard material.
 @JS("BABYLON.RefractionTexture" ) class RefractionTexture extends RenderTargetTexture { // @Ignore
 RefractionTexture .fakeConstructor$() : super.fakeConstructor$() ;
 external Plane get refractionPlane; external set refractionPlane(Plane v); external num get depth; external set depth(num v); external factory RefractionTexture(String name, num size, Scene scene, [bool generateMipMaps]); external RefractionTexture clone(); external dynamic serialize(); }

 @JS("BABYLON.RenderTargetTexture" ) class RenderTargetTexture extends Texture { // @Ignore
 RenderTargetTexture .fakeConstructor$() : super.fakeConstructor$() ;
 external bool get isCube; external set isCube(bool v); external static num get JS$_REFRESHRATE_RENDER_ONCE; external static set JS$_REFRESHRATE_RENDER_ONCE(num v); external static num get JS$_REFRESHRATE_RENDER_ONEVERYFRAME; external static set JS$_REFRESHRATE_RENDER_ONEVERYFRAME(num v); external static num get JS$_REFRESHRATE_RENDER_ONEVERYTWOFRAMES; external static set JS$_REFRESHRATE_RENDER_ONEVERYTWOFRAMES(num v); external static num get REFRESHRATE_RENDER_ONCE; external static set REFRESHRATE_RENDER_ONCE(num v); external static num get REFRESHRATE_RENDER_ONEVERYFRAME; external static set REFRESHRATE_RENDER_ONEVERYFRAME(num v); external static num get REFRESHRATE_RENDER_ONEVERYTWOFRAMES; external static set REFRESHRATE_RENDER_ONEVERYTWOFRAMES(num v);
 /// Use this predicate to dynamically define the list of mesh you want to render.
 /// If set, the renderList property will be overwritten.
 external Func1<AbstractMesh, bool> get renderListPredicate; external set renderListPredicate(Func1<AbstractMesh, bool> v);
 /// Use this list to define the list of mesh you want to render.
 external List<AbstractMesh>/*List<AbstractMesh>|Null*/ get renderList; external set renderList(List<AbstractMesh>/*List<AbstractMesh>|Null*/ v); external bool get renderParticles; external set renderParticles(bool v); external bool get renderSprites; external set renderSprites(bool v); external num get coordinatesMode; external set coordinatesMode(num v); external Camera/*Camera|Null*/ get activeCamera; external set activeCamera(Camera/*Camera|Null*/ v); external Function/*(opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>, beforeTransparents?: () => void) => void*/ get customRenderFunction; external set customRenderFunction(Function/*(opaqueSubMeshes: SmartArray<SubMesh>, alphaTestSubMeshes: SmartArray<SubMesh>, transparentSubMeshes: SmartArray<SubMesh>, depthOnlySubMeshes: SmartArray<SubMesh>, beforeTransparents?: () => void) => void*/ v); external bool get useCameraPostProcesses; external set useCameraPostProcesses(bool v); external bool get ignoreCameraViewport; external set ignoreCameraViewport(bool v); external get JS$_postProcessManager; external set JS$_postProcessManager(v); external get JS$_postProcesses; external set JS$_postProcesses(v); external get JS$_resizeObserver; external set JS$_resizeObserver(v);
 /// An event triggered when the texture is unbind.
 external Observable<RenderTargetTexture> get onBeforeBindObservable; external set onBeforeBindObservable(Observable<RenderTargetTexture> v);
 /// An event triggered when the texture is unbind.
 external Observable<RenderTargetTexture> get onAfterUnbindObservable; external set onAfterUnbindObservable(Observable<RenderTargetTexture> v); external get JS$_onAfterUnbindObserver; external set JS$_onAfterUnbindObserver(v); external VoidFunc0 get onAfterUnbind; external set onAfterUnbind(VoidFunc0 v);
 /// An event triggered before rendering the texture
 external Observable<num> get onBeforeRenderObservable; external set onBeforeRenderObservable(Observable<num> v); external get JS$_onBeforeRenderObserver; external set JS$_onBeforeRenderObserver(v); external VoidFunc1<num> get onBeforeRender; external set onBeforeRender(VoidFunc1<num> v);
 /// An event triggered after rendering the texture
 external Observable<num> get onAfterRenderObservable; external set onAfterRenderObservable(Observable<num> v); external get JS$_onAfterRenderObserver; external set JS$_onAfterRenderObserver(v); external VoidFunc1<num> get onAfterRender; external set onAfterRender(VoidFunc1<num> v);
 /// An event triggered after the texture clear
 external Observable<Engine> get onClearObservable; external set onClearObservable(Observable<Engine> v); external get JS$_onClearObserver; external set JS$_onClearObserver(v); external VoidFunc1<Engine> get onClear; external set onClear(VoidFunc1<Engine> v); external Color4 get clearColor; external set clearColor(Color4 v); external dynamic/*num|{
            width: number;
            height: number;
        }*/ get JS$_size; external set JS$_size(dynamic/*num|{
            width: number;
            height: number;
        }*/ v); external dynamic/*num|{
            width: number;
            height: number;
        }|{
            ratio: number;
        }*/ get JS$_initialSizeParameter; external set JS$_initialSizeParameter(dynamic/*num|{
            width: number;
            height: number;
        }|{
            ratio: number;
        }*/ v); external num/*num|Null*/ get JS$_sizeRatio; external set JS$_sizeRatio(num/*num|Null*/ v); external bool get JS$_generateMipMaps; external set JS$_generateMipMaps(bool v); external RenderingManager get JS$_renderingManager; external set JS$_renderingManager(RenderingManager v); external List<String> get JS$_waitingRenderList; external set JS$_waitingRenderList(List<String> v); external bool get JS$_doNotChangeAspectRatio; external set JS$_doNotChangeAspectRatio(bool v); external num get JS$_currentRefreshId; external set JS$_currentRefreshId(num v); external num get JS$_refreshRate; external set JS$_refreshRate(num v); external Matrix get JS$_textureMatrix; external set JS$_textureMatrix(Matrix v); external num get JS$_samples; external set JS$_samples(num v); external RenderTargetCreationOptions get JS$_renderTargetOptions; external set JS$_renderTargetOptions(RenderTargetCreationOptions v); external RenderTargetCreationOptions get renderTargetOptions; external set renderTargetOptions(RenderTargetCreationOptions v); external Engine get JS$_engine; external set JS$_engine(Engine v); external void JS$_onRatioRescale();
 /// Gets or sets the center of the bounding box associated with the texture (when in cube mode)
 /// It must define where the camera used to render the texture is set
 external Vector3 get boundingBoxPosition; external set boundingBoxPosition(Vector3 v); external get JS$_boundingBoxSize; external set JS$_boundingBoxSize(v);
 /// Gets or sets the size of the bounding box associated with the texture (when in cube mode)
 /// When defined, the cubemap will switch to local mode
 /// @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity
 /// @example https://www.babylonjs-playground.com/#RNASML
 external Vector3 get boundingBoxSize; external set boundingBoxSize(Vector3 v);
 /// In case the RTT has been created with a depth texture, get the associated
 /// depth texture.
 /// Otherwise, return null.
 external InternalTexture/*InternalTexture|Null*/ get depthStencilTexture; external set depthStencilTexture(InternalTexture/*InternalTexture|Null*/ v);
 /// Instantiate a render target texture. This is mainly to render of screen the scene to for instance apply post processse
 /// or used a shadow, depth texture...
 external factory RenderTargetTexture(String name, dynamic/*num|{
            width: number;
            height: number;
        }|{
            ratio: number;
        }*/ size, Scene/*Scene|Null*/ scene, [bool generateMipMaps, bool doNotChangeAspectRatio, num type, bool isCube, num samplingMode, bool generateDepthBuffer, bool generateStencilBuffer, bool isMulti]);
 /// Creates a depth stencil texture.
 /// This is only available in WebGL 2 or with the depth texture extension available.
 external void createDepthStencilTexture([num comparisonFunction, bool bilinearFiltering, bool generateStencil]); external JS$_processSizeParameter(size); external num get samples; external set samples(num v); external void resetRefreshCounter(); external num get refreshRate; external set refreshRate(num v); external void addPostProcess(PostProcess postProcess); external void clearPostProcesses([bool dispose]); external void removePostProcess(PostProcess postProcess); external bool JS$_shouldRender(); external num getRenderSize(); external num getRenderWidth(); external num getRenderHeight(); external bool get canRescale; external set canRescale(bool v); external void scale(num ratio); external Matrix getReflectionTextureMatrix(); external void resize(dynamic/*num|{
            width: number;
            height: number;
        }|{
            ratio: number;
        }*/ size); external void render([bool useCameraPostProcess, bool dumpForDebug]); external JS$_bestReflectionRenderTargetDimension(renderDimension, scale); external void unbindFrameBuffer(Engine engine, num faceIndex); external renderToTarget(faceIndex, currentRenderList, currentRenderListLength, useCameraPostProcess, dumpForDebug);
 /// Overrides the default sort function applied in the renderging group to prepare the meshes.
 /// This allowed control for front to back rendering or reversly depending of the special needs.
 external void setRenderingOrder(num renderingGroupId, [Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ opaqueSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ alphaTestSortCompareFn, Func2<SubMesh, SubMesh, num>/*Func2<SubMesh, SubMesh, num>|Null*/ transparentSortCompareFn]);
 /// Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
 external void setRenderingAutoClearDepthStencil(num renderingGroupId, bool autoClearDepthStencil); external RenderTargetTexture clone(); external dynamic serialize(); external void disposeFramebufferObjects(); external void dispose(); external void JS$_rebuild();
 /// Clear the info related to rendering groups preventing retention point in material dispose.
 external void freeRenderingGroups(); }

 @JS("BABYLON.Texture" ) class Texture extends BaseTexture { // @Ignore
 Texture .fakeConstructor$() : super.fakeConstructor$() ;
 external static num get NEAREST_SAMPLINGMODE; external static set NEAREST_SAMPLINGMODE(num v); external static num get NEAREST_NEAREST_MIPLINEAR; external static set NEAREST_NEAREST_MIPLINEAR(num v); external static num get BILINEAR_SAMPLINGMODE; external static set BILINEAR_SAMPLINGMODE(num v); external static num get LINEAR_LINEAR_MIPNEAREST; external static set LINEAR_LINEAR_MIPNEAREST(num v); external static num get TRILINEAR_SAMPLINGMODE; external static set TRILINEAR_SAMPLINGMODE(num v); external static num get LINEAR_LINEAR_MIPLINEAR; external static set LINEAR_LINEAR_MIPLINEAR(num v); external static num get NEAREST_NEAREST_MIPNEAREST; external static set NEAREST_NEAREST_MIPNEAREST(num v); external static num get NEAREST_LINEAR_MIPNEAREST; external static set NEAREST_LINEAR_MIPNEAREST(num v); external static num get NEAREST_LINEAR_MIPLINEAR; external static set NEAREST_LINEAR_MIPLINEAR(num v); external static num get NEAREST_LINEAR; external static set NEAREST_LINEAR(num v); external static num get NEAREST_NEAREST; external static set NEAREST_NEAREST(num v); external static num get LINEAR_NEAREST_MIPNEAREST; external static set LINEAR_NEAREST_MIPNEAREST(num v); external static num get LINEAR_NEAREST_MIPLINEAR; external static set LINEAR_NEAREST_MIPLINEAR(num v); external static num get LINEAR_LINEAR; external static set LINEAR_LINEAR(num v); external static num get LINEAR_NEAREST; external static set LINEAR_NEAREST(num v); external static num get EXPLICIT_MODE; external static set EXPLICIT_MODE(num v); external static num get SPHERICAL_MODE; external static set SPHERICAL_MODE(num v); external static num get PLANAR_MODE; external static set PLANAR_MODE(num v); external static num get CUBIC_MODE; external static set CUBIC_MODE(num v); external static num get PROJECTION_MODE; external static set PROJECTION_MODE(num v); external static num get SKYBOX_MODE; external static set SKYBOX_MODE(num v); external static num get INVCUBIC_MODE; external static set INVCUBIC_MODE(num v); external static num get EQUIRECTANGULAR_MODE; external static set EQUIRECTANGULAR_MODE(num v); external static num get FIXED_EQUIRECTANGULAR_MODE; external static set FIXED_EQUIRECTANGULAR_MODE(num v); external static num get FIXED_EQUIRECTANGULAR_MIRRORED_MODE; external static set FIXED_EQUIRECTANGULAR_MIRRORED_MODE(num v); external static num get CLAMP_ADDRESSMODE; external static set CLAMP_ADDRESSMODE(num v); external static num get WRAP_ADDRESSMODE; external static set WRAP_ADDRESSMODE(num v); external static num get MIRROR_ADDRESSMODE; external static set MIRROR_ADDRESSMODE(num v);
 /// Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file
 external static bool get UseSerializedUrlIfAny; external static set UseSerializedUrlIfAny(bool v); external String/*String|Null*/ get url; external set url(String/*String|Null*/ v); external num get uOffset; external set uOffset(num v); external num get vOffset; external set vOffset(num v); external num get uScale; external set uScale(num v); external num get vScale; external set vScale(num v); external num get uAng; external set uAng(num v); external num get vAng; external set vAng(num v); external num get wAng; external set wAng(num v); external bool get noMipmap; external set noMipmap(bool v); external get JS$_noMipmap; external set JS$_noMipmap(v); external bool get JS$_invertY; external set JS$_invertY(bool v); external get JS$_rowGenerationMatrix; external set JS$_rowGenerationMatrix(v); external get JS$_cachedTextureMatrix; external set JS$_cachedTextureMatrix(v); external get JS$_projectionModeMatrix; external set JS$_projectionModeMatrix(v); external get JS$_t0; external set JS$_t0(v); external get JS$_t1; external set JS$_t1(v); external get JS$_t2; external set JS$_t2(v); external get JS$_cachedUOffset; external set JS$_cachedUOffset(v); external get JS$_cachedVOffset; external set JS$_cachedVOffset(v); external get JS$_cachedUScale; external set JS$_cachedUScale(v); external get JS$_cachedVScale; external set JS$_cachedVScale(v); external get JS$_cachedUAng; external set JS$_cachedUAng(v); external get JS$_cachedVAng; external set JS$_cachedVAng(v); external get JS$_cachedWAng; external set JS$_cachedWAng(v); external get JS$_cachedProjectionMatrixId; external set JS$_cachedProjectionMatrixId(v); external get JS$_cachedCoordinatesMode; external set JS$_cachedCoordinatesMode(v); external num get JS$_samplingMode; external set JS$_samplingMode(num v); external get JS$_buffer; external set JS$_buffer(v); external get JS$_deleteBuffer; external set JS$_deleteBuffer(v); external num/*num|Null*/ get JS$_format; external set JS$_format(num/*num|Null*/ v); external get JS$_delayedOnLoad; external set JS$_delayedOnLoad(v); external get JS$_delayedOnError; external set JS$_delayedOnError(v); external Observable<Texture>/*Observable<Texture>|Null*/ get JS$_onLoadObservable; external set JS$_onLoadObservable(Observable<Texture>/*Observable<Texture>|Null*/ v); external bool get JS$_isBlocking; external set JS$_isBlocking(bool v); external bool get isBlocking; external set isBlocking(bool v); external num get samplingMode; external set samplingMode(num v); external factory Texture(String/*String|Null*/ url, Scene/*Scene|Null*/ scene, [bool noMipmap, bool invertY, num samplingMode, VoidFunc0/*VoidFunc0|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, dynamic buffer, bool deleteBuffer, num format]); external void updateURL(String url); external void delayLoad(); external void updateSamplingMode(num samplingMode); external JS$_prepareRowForTextureGeneration(x, y, z, t); external Matrix getTextureMatrix(); external Matrix getReflectionTextureMatrix(); external Texture clone(); external Observable<Texture> get onLoadObservable; external set onLoadObservable(Observable<Texture> v); external dynamic serialize(); external String getClassName(); external void dispose(); external static Texture CreateFromBase64String(String data, String name, Scene scene, [bool noMipmap, bool invertY, num samplingMode, VoidFunc0/*VoidFunc0|Null*/ onLoad, VoidFunc0/*VoidFunc0|Null*/ onError, num format]); external static BaseTexture/*BaseTexture|Null*/ Parse(dynamic parsedTexture, Scene scene, String rootUrl); external static Texture LoadFromDataString(String name, dynamic buffer, Scene scene, [bool deleteBuffer, bool noMipmap, bool invertY, num samplingMode, VoidFunc0/*VoidFunc0|Null*/ onLoad, Function/*(message?: string, exception?: any) => void|Null*/ onError, num format]); }

 /// Settings for finer control over video usage
 @anonymous @JS() abstract class VideoTextureSettings {
 /// Applies `autoplay` to video, if specified
 external bool get autoPlay; external set autoPlay(bool v);
 /// Applies `loop` to video, if specified
 external bool get loop; external set loop(bool v);
 /// Automatically updates internal texture from video at every frame in the render loop
 external bool get autoUpdateTexture; external set autoUpdateTexture(bool v); external factory VideoTextureSettings({ bool autoPlay, bool loop, bool autoUpdateTexture}); }

 @JS("BABYLON.VideoTexture" ) class VideoTexture extends Texture { // @Ignore
 VideoTexture .fakeConstructor$() : super.fakeConstructor$() ;
 /// Tells whether textures will be updated automatically or user is required to call `updateTexture` manually
 external bool get autoUpdateTexture; external set autoUpdateTexture(bool v);
 /// The video instance used by the texture internally
 external VideoElement get video; external set video(VideoElement v); external get JS$_generateMipMaps; external set JS$_generateMipMaps(v); external get JS$_engine; external set JS$_engine(v); external get JS$_stillImageCaptured; external set JS$_stillImageCaptured(v);
 /// Creates a video texture.
 /// Sample : https://doc.babylonjs.com/how_to/video_texture
 external factory VideoTexture(String/*String|Null*/ name, dynamic/*String|List<String>|VideoElement*/ src, Scene/*Scene|Null*/ scene, [bool generateMipMaps, bool invertY, num samplingMode, VideoTextureSettings settings]); external JS$_getName(src); external JS$_getVideo(src); external get JS$_createInternalTexture; external set JS$_createInternalTexture(v); external get reset; external set reset(v);
 /// Internal method to initiate `update`.
 external void JS$_rebuild();
 /// Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.
 external void update();
 /// Update Texture in `manual` mode. Does not do anything if not visible or paused.
 external void updateTexture(bool isVisible); external VoidFunc1Opt1<dynamic/*Event|dynamic*/> get JS$_updateInternalTexture; external set JS$_updateInternalTexture(VoidFunc1Opt1<dynamic/*Event|dynamic*/> v);
 /// Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.
 external void updateURL(String url); external void dispose(); external static void CreateFromWebCam(Scene scene, void onReady(VideoTexture videoTexture), dynamic/*{
            minWidth: number;
            maxWidth: number;
            minHeight: number;
            maxHeight: number;
            deviceId: string;
        }*/ constraints); }

 /// Configuration for Draco compression
 @anonymous @JS() abstract class IDracoCompressionConfiguration {
 /// Configuration for the decoder.
 external dynamic/*{
            /**
             * The url to the WebAssembly module.
             */
            wasmUrl?: string;
            /**
             * The url to the WebAssembly binary.
             */
            wasmBinaryUrl?: string;
            /**
             * The url to the fallback JavaScript module.
             */
            fallbackUrl?: string;
        }*/ get decoder; external set decoder(dynamic/*{
            /**
             * The url to the WebAssembly module.
             */
            wasmUrl?: string;
            /**
             * The url to the WebAssembly binary.
             */
            wasmBinaryUrl?: string;
            /**
             * The url to the fallback JavaScript module.
             */
            fallbackUrl?: string;
        }*/ v); external factory IDracoCompressionConfiguration({ dynamic/*{
            /**
             * The url to the WebAssembly module.
             */
            wasmUrl?: string;
            /**
             * The url to the WebAssembly binary.
             */
            wasmBinaryUrl?: string;
            /**
             * The url to the fallback JavaScript module.
             */
            fallbackUrl?: string;
        }*/ decoder}); }

 /// Draco compression (https://google.github.io/draco/)
 @JS("BABYLON.DracoCompression" ) class DracoCompression implements IDisposable { // @Ignore
 DracoCompression .fakeConstructor$() ;
 external static get JS$_DecoderModulePromise; external static set JS$_DecoderModulePromise(v);
 /// The configuration.
 external static IDracoCompressionConfiguration get Configuration; external static set Configuration(IDracoCompressionConfiguration v);
 /// Returns true if the decoder is available.
 external static bool get DecoderAvailable; external static set DecoderAvailable(bool v);
 /// Constructor
 external factory DracoCompression();
 /// Stop all async operations and release resources.
 external void dispose();
 /// Decode Draco compressed mesh data to vertex data.
 external Promise<VertexData> decodeMeshAsync(TypedData data, dynamic/*JSMap of <String,num>*/ attributes); external static JS$_GetDecoderModule(); external static JS$_LoadScriptAsync(url); external static JS$_LoadFileAsync(url); }

 /// Particle emitter emitting particles from the inside of a box.
 /// It emits the particles randomly between 2 given directions.
 @JS("BABYLON.BoxParticleEmitter" ) class BoxParticleEmitter implements IParticleEmitterType { // @Ignore
 BoxParticleEmitter .fakeConstructor$() ;
 /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
 external Vector3 get direction1; external set direction1(Vector3 v);
 /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
 external Vector3 get direction2; external set direction2(Vector3 v);
 /// Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
 external Vector3 get minEmitBox; external set minEmitBox(Vector3 v);
 /// Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
 external Vector3 get maxEmitBox; external set maxEmitBox(Vector3 v);
 /// Creates a new instance BoxParticleEmitter
 external factory BoxParticleEmitter();
 /// Called by the particle System when the direction is computed for the created particle.
 external void startDirectionFunction(num emitPower, Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);
 /// Called by the particle System when the position is computed for the created particle.
 external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);
 /// Clones the current emitter and returns a copy of it
 external BoxParticleEmitter clone();
 /// Called by the {BABYLON.GPUParticleSystem} to setup the update shader
 external void applyToShader(Effect effect);
 /// Returns a string to use to update the GPU particles update shader
 external String getEffectDefines();
 /// Returns the string "BoxEmitter"
 external String getClassName();
 /// Serializes the particle system to a JSON object.
 external dynamic serialize();
 /// Parse properties from a JSON object
 external void parse(dynamic serializationObject); }

 /// Particle emitter emitting particles from the inside of a cone.
 /// It emits the particles alongside the cone volume from the base to the particle.
 /// The emission direction might be randomized.
 @JS("BABYLON.ConeParticleEmitter" ) class ConeParticleEmitter implements IParticleEmitterType { // @Ignore
 ConeParticleEmitter .fakeConstructor$() ;
 /// The radius of the emission cone.
 external num get angle; external set angle(num v);
 /// The cone base angle.
 external num get directionRandomizer; external set directionRandomizer(num v); external get JS$_radius; external set JS$_radius(v); external get JS$_height; external set JS$_height(v);
 /// Gets the radius of the emission cone.
 /// Sets the radius of the emission cone.
 external num get radius; external set radius(num v);
 /// Creates a new instance ConeParticleEmitter
 external factory ConeParticleEmitter([num radius,
 /// The radius of the emission cone.
 num angle,
 /// The cone base angle.
 num directionRandomizer]);
 /// Called by the particle System when the direction is computed for the created particle.
 external void startDirectionFunction(num emitPower, Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);
 /// Called by the particle System when the position is computed for the created particle.
 external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);
 /// Clones the current emitter and returns a copy of it
 external ConeParticleEmitter clone();
 /// Called by the {BABYLON.GPUParticleSystem} to setup the update shader
 external void applyToShader(Effect effect);
 /// Returns a string to use to update the GPU particles update shader
 external String getEffectDefines();
 /// Returns the string "BoxEmitter"
 external String getClassName();
 /// Serializes the particle system to a JSON object.
 external dynamic serialize();
 /// Parse properties from a JSON object
 external void parse(dynamic serializationObject); }

 /// Particle emitter represents a volume emitting particles.
 /// This is the responsibility of the implementation to define the volume shape like cone/sphere/box.
 @anonymous @JS() abstract class IParticleEmitterType {
 /// Called by the particle System when the direction is computed for the created particle.
 external void startDirectionFunction(num emitPower, Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);
 /// Called by the particle System when the position is computed for the created particle.
 external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);
 /// Clones the current emitter and returns a copy of it
 external IParticleEmitterType clone();
 /// Called by the {BABYLON.GPUParticleSystem} to setup the update shader
 external void applyToShader(Effect effect);
 /// Returns a string to use to update the GPU particles update shader
 external String getEffectDefines();
 /// Returns a string representing the class name
 external String getClassName();
 /// Serializes the particle system to a JSON object.
 external dynamic serialize();
 /// Parse properties from a JSON object
 external void parse(dynamic serializationObject); }

 /// Particle emitter emitting particles from the inside of a sphere.
 /// It emits the particles alongside the sphere radius. The emission direction might be randomized.
 @JS("BABYLON.SphereParticleEmitter" ) class SphereParticleEmitter implements IParticleEmitterType { // @Ignore
 SphereParticleEmitter .fakeConstructor$() ;
 /// The radius of the emission sphere.
 external num get radius; external set radius(num v);
 /// How much to randomize the particle direction [0-1].
 external num get directionRandomizer; external set directionRandomizer(num v);
 /// Creates a new instance SphereParticleEmitter
 external factory SphereParticleEmitter([
 /// The radius of the emission sphere.
 num radius,
 /// How much to randomize the particle direction [0-1].
 num directionRandomizer]);
 /// Called by the particle System when the direction is computed for the created particle.
 external void startDirectionFunction(num emitPower, Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);
 /// Called by the particle System when the position is computed for the created particle.
 external void startPositionFunction(Matrix worldMatrix, Vector3 positionToUpdate, Particle particle);
 /// Clones the current emitter and returns a copy of it
 external SphereParticleEmitter clone();
 /// Called by the {BABYLON.GPUParticleSystem} to setup the update shader
 external void applyToShader(Effect effect);
 /// Returns a string to use to update the GPU particles update shader
 external String getEffectDefines();
 /// Returns the string "SphereParticleEmitter"
 external String getClassName();
 /// Serializes the particle system to a JSON object.
 external dynamic serialize();
 /// Parse properties from a JSON object
 external void parse(dynamic serializationObject); }

 /// Particle emitter emitting particles from the inside of a sphere.
 /// It emits the particles randomly between two vectors.
 @JS("BABYLON.SphereDirectedParticleEmitter" ) class SphereDirectedParticleEmitter extends SphereParticleEmitter { // @Ignore
 SphereDirectedParticleEmitter .fakeConstructor$() : super.fakeConstructor$() ;
 /// The min limit of the emission direction.
 external Vector3 get direction1; external set direction1(Vector3 v);
 /// The max limit of the emission direction.
 external Vector3 get direction2; external set direction2(Vector3 v);
 /// Creates a new instance SphereDirectedParticleEmitter
 external factory SphereDirectedParticleEmitter([num radius,
 /// The min limit of the emission direction.
 Vector3 direction1,
 /// The max limit of the emission direction.
 Vector3 direction2]);
 /// Called by the particle System when the direction is computed for the created particle.
 external void startDirectionFunction(num emitPower, Matrix worldMatrix, Vector3 directionToUpdate, Particle particle);
 /// Clones the current emitter and returns a copy of it
 external SphereDirectedParticleEmitter clone();
 /// Called by the {BABYLON.GPUParticleSystem} to setup the update shader
 external void applyToShader(Effect effect);
 /// Returns a string to use to update the GPU particles update shader
 external String getEffectDefines();
 /// Returns the string "SphereDirectedParticleEmitter"
 external String getClassName();
 /// Serializes the particle system to a JSON object.
 external dynamic serialize();
 /// Parse properties from a JSON object
 external void parse(dynamic serializationObject); }

 @JS("BABYLON.CannonJSPlugin" ) class CannonJSPlugin implements IPhysicsEnginePlugin { // @Ignore
 CannonJSPlugin .fakeConstructor$() ;
 external get JS$_useDeltaForWorldStep; external set JS$_useDeltaForWorldStep(v); external dynamic get world; external set world(dynamic v); external String get name; external set name(String v); external get JS$_physicsMaterials; external set JS$_physicsMaterials(v); external get JS$_fixedTimeStep; external set JS$_fixedTimeStep(v); external dynamic get BJSCANNON; external set BJSCANNON(dynamic v); external factory CannonJSPlugin([bool JS$_useDeltaForWorldStep, num iterations]); external void setGravity(Vector3 gravity); external void setTimeStep(num timeStep); external num getTimeStep(); external void executeStep(num delta, List<PhysicsImpostor> impostors); external void applyImpulse(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint); external void applyForce(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint); external void generatePhysicsBody(PhysicsImpostor impostor); external JS$_processChildMeshes(mainImpostor); external void removePhysicsBody(PhysicsImpostor impostor); external void generateJoint(PhysicsImpostorJoint impostorJoint); external void removeJoint(PhysicsImpostorJoint impostorJoint); external JS$_addMaterial(name, friction, restitution); external JS$_checkWithEpsilon(value); external JS$_createShape(impostor); external JS$_createHeightmap(object, [pointDepth]); external get JS$_minus90X; external set JS$_minus90X(v); external get JS$_plus90X; external set JS$_plus90X(v); external get JS$_tmpPosition; external set JS$_tmpPosition(v); external get JS$_tmpDeltaPosition; external set JS$_tmpDeltaPosition(v); external get JS$_tmpUnityRotation; external set JS$_tmpUnityRotation(v); external JS$_updatePhysicsBodyTransformation(impostor); external void setTransformationFromPhysicsBody(PhysicsImpostor impostor); external void setPhysicsBodyTransformation(PhysicsImpostor impostor, Vector3 newPosition, Quaternion newRotation); external bool isSupported(); external void setLinearVelocity(PhysicsImpostor impostor, Vector3 velocity); external void setAngularVelocity(PhysicsImpostor impostor, Vector3 velocity); external Vector3/*Vector3|Null*/ getLinearVelocity(PhysicsImpostor impostor); external Vector3/*Vector3|Null*/ getAngularVelocity(PhysicsImpostor impostor); external void setBodyMass(PhysicsImpostor impostor, num mass); external num getBodyMass(PhysicsImpostor impostor); external num getBodyFriction(PhysicsImpostor impostor); external void setBodyFriction(PhysicsImpostor impostor, num friction); external num getBodyRestitution(PhysicsImpostor impostor); external void setBodyRestitution(PhysicsImpostor impostor, num restitution); external void sleepBody(PhysicsImpostor impostor); external void wakeUpBody(PhysicsImpostor impostor); external void updateDistanceJoint(PhysicsJoint joint, num maxDistance, [num minDistance]); external void setMotor(IMotorEnabledJoint joint, [num speed, num maxForce, num motorIndex]); external void setLimit(IMotorEnabledJoint joint, num upperLimit, [num lowerLimit]); external void syncMeshWithImpostor(AbstractMesh mesh, PhysicsImpostor impostor); external num getRadius(PhysicsImpostor impostor); external void getBoxSizeToRef(PhysicsImpostor impostor, Vector3 result); external void dispose(); external JS$_extendNamespace(); }

 @JS("BABYLON.OimoJSPlugin" ) class OimoJSPlugin implements IPhysicsEnginePlugin { // @Ignore
 OimoJSPlugin .fakeConstructor$() ;
 external dynamic get world; external set world(dynamic v); external String get name; external set name(String v); external dynamic get BJSOIMO; external set BJSOIMO(dynamic v); external factory OimoJSPlugin([num iterations]); external void setGravity(Vector3 gravity); external void setTimeStep(num timeStep); external num getTimeStep(); external get JS$_tmpImpostorsArray; external set JS$_tmpImpostorsArray(v); external void executeStep(num delta, List<PhysicsImpostor> impostors); external void applyImpulse(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint); external void applyForce(PhysicsImpostor impostor, Vector3 force, Vector3 contactPoint); external void generatePhysicsBody(PhysicsImpostor impostor); external get JS$_tmpPositionVector; external set JS$_tmpPositionVector(v); external void removePhysicsBody(PhysicsImpostor impostor); external void generateJoint(PhysicsImpostorJoint impostorJoint); external void removeJoint(PhysicsImpostorJoint impostorJoint); external bool isSupported(); external void setTransformationFromPhysicsBody(PhysicsImpostor impostor); external void setPhysicsBodyTransformation(PhysicsImpostor impostor, Vector3 newPosition, Quaternion newRotation); external void setLinearVelocity(PhysicsImpostor impostor, Vector3 velocity); external void setAngularVelocity(PhysicsImpostor impostor, Vector3 velocity); external Vector3/*Vector3|Null*/ getLinearVelocity(PhysicsImpostor impostor); external Vector3/*Vector3|Null*/ getAngularVelocity(PhysicsImpostor impostor); external void setBodyMass(PhysicsImpostor impostor, num mass); external num getBodyMass(PhysicsImpostor impostor); external num getBodyFriction(PhysicsImpostor impostor); external void setBodyFriction(PhysicsImpostor impostor, num friction); external num getBodyRestitution(PhysicsImpostor impostor); external void setBodyRestitution(PhysicsImpostor impostor, num restitution); external void sleepBody(PhysicsImpostor impostor); external void wakeUpBody(PhysicsImpostor impostor); external void updateDistanceJoint(PhysicsJoint joint, num maxDistance, [num minDistance]); external void setMotor(IMotorEnabledJoint joint, num speed, [num maxForce, num motorIndex]); external void setLimit(IMotorEnabledJoint joint, num upperLimit, [num lowerLimit, num motorIndex]); external void syncMeshWithImpostor(AbstractMesh mesh, PhysicsImpostor impostor); external num getRadius(PhysicsImpostor impostor); external void getBoxSizeToRef(PhysicsImpostor impostor, Vector3 result); external void dispose(); }

 /// This represents a set of one or more post processes in Babylon.
 /// A post process can be used to apply a shader to a texture after it is rendered.
 /// @example https://doc.babylonjs.com/how_to/how_to_use_postprocessrenderpipeline
 @JS("BABYLON.PostProcessRenderEffect" ) class PostProcessRenderEffect { // @Ignore
 PostProcessRenderEffect .fakeConstructor$() ;
 external get JS$_postProcesses; external set JS$_postProcesses(v); external get JS$_getPostProcesses; external set JS$_getPostProcesses(v); external get JS$_singleInstance; external set JS$_singleInstance(v); external get JS$_cameras; external set JS$_cameras(v); external get JS$_indicesForCamera; external set JS$_indicesForCamera(v);
 /// Name of the effect
 external String get JS$_name; external set JS$_name(String v);
 /// Instantiates a post process render effect.
 /// A post process can be used to apply a shader to a texture after it is rendered.
 external factory PostProcessRenderEffect(Engine engine, String name, dynamic/*PostProcess|List<PostProcess>|Null*/ getPostProcesses(), [bool singleInstance]);
 /// Checks if all the post processes in the effect are supported.
 external bool get isSupported; external set isSupported(bool v);
 /// Updates the current state of the effect
 external void JS$_update();
 /// Attaches the effect on cameras
 /*external void JS$_attachCameras(Camera cameras);*/
 /// Attaches the effect on cameras
 /*external void JS$_attachCameras(List<Camera> cameras);*/
 external void JS$_attachCameras(dynamic/*Camera|List<Camera>*/ cameras);
 /// Detatches the effect on cameras
 /*external void JS$_detachCameras(Camera cameras);*/
 /// Detatches the effect on cameras
 /*external void JS$_detachCameras(List<Camera> cameras);*/
 external void JS$_detachCameras(dynamic/*Camera|List<Camera>*/ cameras);
 /// Enables the effect on given cameras
 /*external void JS$_enable(Camera cameras);*/
 /// Enables the effect on given cameras
 /*external void JS$_enable(List<Camera>|Null cameras);*/
 external void JS$_enable(dynamic/*Camera|T*/ cameras);
 /// Disables the effect on the given cameras
 /*external void JS$_disable(Camera cameras);*/
 /// Disables the effect on the given cameras
 /*external void JS$_disable(List<Camera>|Null cameras);*/
 external void JS$_disable(dynamic/*Camera|T*/ cameras);
 /// Gets a list of the post processes contained in the effect.
 external List<PostProcess>/*List<PostProcess>|Null*/ getPostProcesses([Camera camera]); }

 @JS("BABYLON.PostProcessRenderPipeline" ) class PostProcessRenderPipeline { // @Ignore
 PostProcessRenderPipeline .fakeConstructor$() ;
 external get engine; external set engine(v); external get JS$_renderEffects; external set JS$_renderEffects(v); external get JS$_renderEffectsForIsolatedPass; external set JS$_renderEffectsForIsolatedPass(v); external List<Camera> get JS$_cameras; external set JS$_cameras(List<Camera> v); external String get JS$_name; external set JS$_name(String v); external factory PostProcessRenderPipeline(Engine engine, String name); external String getClassName(); external bool get isSupported; external set isSupported(bool v); external void addEffect(PostProcessRenderEffect renderEffect); external void JS$_rebuild();
 /*external void JS$_enableEffect(String renderEffectName, Camera cameras);*/
 /*external void JS$_enableEffect(String renderEffectName, List<Camera> cameras);*/
 external void JS$_enableEffect(String renderEffectName, dynamic/*Camera|List<Camera>*/ cameras);
 /*external void JS$_disableEffect(String renderEffectName, List<Camera>|Null cameras);*/
 /*external void JS$_disableEffect(String renderEffectName, List<Camera>|Null cameras);*/
 external void JS$_disableEffect(String renderEffectName, T cameras);
 /*external void JS$_attachCameras(Camera cameras, bool unique);*/
 /*external void JS$_attachCameras(List<Camera> cameras, bool unique);*/
 external void JS$_attachCameras(dynamic/*Camera|List<Camera>*/ cameras, bool unique);
 /*external void JS$_detachCameras(Camera cameras);*/
 /*external void JS$_detachCameras(List<Camera>|Null cameras);*/
 external void JS$_detachCameras(dynamic/*Camera|T*/ cameras); external void JS$_update(); external void JS$_reset(); external bool JS$_enableMSAAOnFirstPostProcess(num sampleCount); external void dispose(); }

 @JS("BABYLON.PostProcessRenderPipelineManager" ) class PostProcessRenderPipelineManager { // @Ignore
 PostProcessRenderPipelineManager .fakeConstructor$() ;
 external get JS$_renderPipelines; external set JS$_renderPipelines(v); external factory PostProcessRenderPipelineManager(); external void addPipeline(PostProcessRenderPipeline renderPipeline);
 /*external void attachCamerasToRenderPipeline(
    String renderPipelineName, Camera cameras,
    [bool unique]);*/
 /*external void attachCamerasToRenderPipeline(
    String renderPipelineName, List<Camera> cameras,
    [bool unique]);*/
 external void attachCamerasToRenderPipeline(String renderPipelineName, dynamic/*Camera|List<Camera>*/ cameras, [bool unique]);
 /*external void detachCamerasFromRenderPipeline(
    String renderPipelineName, Camera cameras);*/
 /*external void detachCamerasFromRenderPipeline(
    String renderPipelineName, List<Camera> cameras);*/
 external void detachCamerasFromRenderPipeline(String renderPipelineName, dynamic/*Camera|List<Camera>*/ cameras);
 /*external void enableEffectInPipeline(
    String renderPipelineName, String renderEffectName, Camera cameras);*/
 /*external void enableEffectInPipeline(
    String renderPipelineName, String renderEffectName, List<Camera> cameras);*/
 external void enableEffectInPipeline(String renderPipelineName, String renderEffectName, dynamic/*Camera|List<Camera>*/ cameras);
 /*external void disableEffectInPipeline(
    String renderPipelineName, String renderEffectName, Camera cameras);*/
 /*external void disableEffectInPipeline(
    String renderPipelineName, String renderEffectName, List<Camera> cameras);*/
 external void disableEffectInPipeline(String renderPipelineName, String renderEffectName, dynamic/*Camera|List<Camera>*/ cameras); external void update(); external void JS$_rebuild(); external void dispose(); }

 /// Helper class dealing with the extraction of spherical polynomial dataArray
 /// from a cube map.
 @JS("BABYLON.CubeMapToSphericalPolynomialTools" ) class CubeMapToSphericalPolynomialTools { // @Ignore
 CubeMapToSphericalPolynomialTools .fakeConstructor$() ;
 external static get FileFaces; external static set FileFaces(v);
 /// Converts a texture to the according Spherical Polynomial data.
 /// This extracts the first 3 orders only as they are the only one used in the lighting.
 external static SphericalPolynomial/*SphericalPolynomial|Null*/ ConvertCubeMapTextureToSphericalPolynomial(BaseTexture texture);
 /// Converts a cubemap to the according Spherical Polynomial data.
 /// This extracts the first 3 orders only as they are the only one used in the lighting.
 external static SphericalPolynomial ConvertCubeMapToSphericalPolynomial(CubeMapInfo cubeInfo); }

 /// Header information of HDR texture files.
 @anonymous @JS() abstract class HDRInfo {
 /// The height of the texture in pixels.
 external num get height; external set height(num v);
 /// The width of the texture in pixels.
 external num get width; external set width(num v);
 /// The index of the beginning of the data in the binary file.
 external num get dataPosition; external set dataPosition(num v); external factory HDRInfo({ num height, num width, num dataPosition}); }

 /// This groups tools to convert HDR texture to native colors array.
 @JS("BABYLON.HDRTools" ) class HDRTools { // @Ignore
 HDRTools .fakeConstructor$() ;
 external static Ldexp(mantissa, exponent); external static Rgbe2float(float32array, red, green, blue, exponent, index); external static readStringLine(uint8array, startIndex);
 /// Reads header information from an RGBE texture stored in a native array.
 /// More information on this format are available here:
 /// https://en.wikipedia.org/wiki/RGBE_image_format
 external static HDRInfo RGBE_ReadHeader(Uint8List uint8array);
 /// Returns the cubemap information (each faces texture data) extracted from an RGBE texture.
 /// This RGBE texture needs to store the information as a panorama.
 /// More information on this format are available here:
 /// https://en.wikipedia.org/wiki/RGBE_image_format
 external static CubeMapInfo GetCubeMapTextureData(ByteBuffer buffer, num size);
 /// Returns the pixels data extracted from an RGBE texture.
 /// This pixels will be stored left to right up to down in the R G B order in one array.
 /// More information on this format are available here:
 /// https://en.wikipedia.org/wiki/RGBE_image_format
 external static Float32List RGBE_ReadPixels(Uint8List uint8array, HDRInfo hdrInfo); external static RGBE_ReadPixels_RLE(uint8array, hdrInfo); }

 /// CubeMap information grouping all the data for each faces as well as the cubemap size.
 @anonymous @JS() abstract class CubeMapInfo {
 /// The pixel array for the front face.
 /// This is stored in format, left to right, up to down format.
 external TypedData/*TypedData|Null*/ get front; external set front(TypedData/*TypedData|Null*/ v);
 /// The pixel array for the back face.
 /// This is stored in format, left to right, up to down format.
 external TypedData/*TypedData|Null*/ get back; external set back(TypedData/*TypedData|Null*/ v);
 /// The pixel array for the left face.
 /// This is stored in format, left to right, up to down format.
 external TypedData/*TypedData|Null*/ get left; external set left(TypedData/*TypedData|Null*/ v);
 /// The pixel array for the right face.
 /// This is stored in format, left to right, up to down format.
 external TypedData/*TypedData|Null*/ get right; external set right(TypedData/*TypedData|Null*/ v);
 /// The pixel array for the up face.
 /// This is stored in format, left to right, up to down format.
 external TypedData/*TypedData|Null*/ get up; external set up(TypedData/*TypedData|Null*/ v);
 /// The pixel array for the down face.
 /// This is stored in format, left to right, up to down format.
 external TypedData/*TypedData|Null*/ get down; external set down(TypedData/*TypedData|Null*/ v);
 /// The size of the cubemap stored.
 /// Each faces will be size * size pixels.
 external num get size; external set size(num v);
 /// The format of the texture.
 /// RGBA, RGB.
 external num get format; external set format(num v);
 /// The type of the texture data.
 /// UNSIGNED_INT, FLOAT.
 external num get type; external set type(num v);
 /// Specifies whether the texture is in gamma space.
 external bool get gammaSpace; external set gammaSpace(bool v); external factory CubeMapInfo({ TypedData/*TypedData|Null*/ front, TypedData/*TypedData|Null*/ back, TypedData/*TypedData|Null*/ left, TypedData/*TypedData|Null*/ right, TypedData/*TypedData|Null*/ up, TypedData/*TypedData|Null*/ down, num size, num format, num type, bool gammaSpace}); }

 /// Helper class usefull to convert panorama picture to their cubemap representation in 6 faces.
 @JS("BABYLON.PanoramaToCubeMapTools" ) class PanoramaToCubeMapTools { // @Ignore
 PanoramaToCubeMapTools .fakeConstructor$() ;
 external static get FACE_FRONT; external static set FACE_FRONT(v); external static get FACE_BACK; external static set FACE_BACK(v); external static get FACE_RIGHT; external static set FACE_RIGHT(v); external static get FACE_LEFT; external static set FACE_LEFT(v); external static get FACE_DOWN; external static set FACE_DOWN(v); external static get FACE_UP; external static set FACE_UP(v);
 /// Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).
 external static CubeMapInfo ConvertPanoramaToCubemap(Float32List float32Array, num inputWidth, num inputHeight, num size); external static CreateCubemapTexture(texSize, faceData, float32Array, inputWidth, inputHeight); external static CalcProjectionSpherical(vDir, float32Array, inputWidth, inputHeight); }

 @JS("BABYLON.CustomProceduralTexture" ) class CustomProceduralTexture extends ProceduralTexture { // @Ignore
 CustomProceduralTexture .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_animate; external set JS$_animate(v); external get JS$_time; external set JS$_time(v); external get JS$_config; external set JS$_config(v); external get JS$_texturePath; external set JS$_texturePath(v); external factory CustomProceduralTexture(String name, dynamic texturePath, num size, Scene scene, [Texture fallbackTexture, bool generateMipMaps]); external loadJson(jsonUrl); external bool isReady(); external void render([bool useCameraPostProcess]); external void updateTextures(); external void updateShaderUniforms(); external bool get animate; external set animate(bool v); }

 @JS("BABYLON.ProceduralTexture" ) class ProceduralTexture extends Texture { // @Ignore
 ProceduralTexture .fakeConstructor$() : super.fakeConstructor$() ;
 external bool get isCube; external set isCube(bool v); external get JS$_size; external set JS$_size(v); external bool get JS$_generateMipMaps; external set JS$_generateMipMaps(bool v); external bool get isEnabled; external set isEnabled(bool v); external get JS$_currentRefreshId; external set JS$_currentRefreshId(v); external get JS$_refreshRate; external set JS$_refreshRate(v); external VoidFunc0 get onGenerated; external set onGenerated(VoidFunc0 v); external get JS$_vertexBuffers; external set JS$_vertexBuffers(v); external get JS$_indexBuffer; external set JS$_indexBuffer(v); external get JS$_effect; external set JS$_effect(v); external get JS$_uniforms; external set JS$_uniforms(v); external get JS$_samplers; external set JS$_samplers(v); external get JS$_fragment; external set JS$_fragment(v); external dynamic/*JSMap of <String,Texture>*/ get JS$_textures; external set JS$_textures(dynamic/*JSMap of <String,Texture>*/ v); external get JS$_floats; external set JS$_floats(v); external get JS$_floatsArrays; external set JS$_floatsArrays(v); external get JS$_colors3; external set JS$_colors3(v); external get JS$_colors4; external set JS$_colors4(v); external get JS$_vectors2; external set JS$_vectors2(v); external get JS$_vectors3; external set JS$_vectors3(v); external get JS$_matrices; external set JS$_matrices(v); external get JS$_fallbackTexture; external set JS$_fallbackTexture(v); external get JS$_fallbackTextureUsed; external set JS$_fallbackTextureUsed(v); external get JS$_engine; external set JS$_engine(v); external factory ProceduralTexture(String name, dynamic size, dynamic fragment, Scene scene, [Texture/*Texture|Null*/ fallbackTexture, bool generateMipMaps, bool isCube]); external JS$_createIndexBuffer(); external void JS$_rebuild(); external void reset(); external bool isReady(); external void resetRefreshCounter(); external void setFragment(dynamic fragment); external num get refreshRate; external set refreshRate(num v); external bool JS$_shouldRender(); external num getRenderSize(); external void resize(num size, bool generateMipMaps); external JS$_checkUniform(uniformName); external ProceduralTexture setTexture(String name, Texture texture); external ProceduralTexture setFloat(String name, num value); external ProceduralTexture setFloats(String name, List<num> value); external ProceduralTexture setColor3(String name, Color3 value); external ProceduralTexture setColor4(String name, Color4 value); external ProceduralTexture setVector2(String name, Vector2 value); external ProceduralTexture setVector3(String name, Vector3 value); external ProceduralTexture setMatrix(String name, Matrix value); external void render([bool useCameraPostProcess]); external ProceduralTexture clone(); external void dispose(); }

 /// The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
 /// See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
 @JS("BABYLON.DefaultRenderingPipeline" ) class DefaultRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable { // @Ignore
 DefaultRenderingPipeline .fakeConstructor$() : super.fakeConstructor$() ;
 external get JS$_scene; external set JS$_scene(v); external get JS$_originalCameras; external set JS$_originalCameras(v);
 /// ID of the sharpen post process,
 external get SharpenPostProcessId; external set SharpenPostProcessId(v);
 /// ID of the image processing post process;
 external String get ImageProcessingPostProcessId; external set ImageProcessingPostProcessId(String v);
 /// ID of the Fast Approximate Anti-Aliasing post process;
 external String get FxaaPostProcessId; external set FxaaPostProcessId(String v);
 /// ID of the chromatic aberration post process,
 external get ChromaticAberrationPostProcessId; external set ChromaticAberrationPostProcessId(v);
 /// ID of the grain post process
 external get GrainPostProcessId; external set GrainPostProcessId(v);
 /// Sharpen post process which will apply a sharpen convolution to enhance edges
 external SharpenPostProcess get sharpen; external set sharpen(SharpenPostProcess v); external get JS$_sharpenEffect; external set JS$_sharpenEffect(v); external get bloom; external set bloom(v);
 /// Depth of field effect, applies a blur based on how far away objects are from the focus distance.
 external DepthOfFieldEffect get depthOfField; external set depthOfField(DepthOfFieldEffect v);
 /// The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
 external FxaaPostProcess get fxaa; external set fxaa(FxaaPostProcess v);
 /// Image post processing pass used to perform operations such as tone mapping or color grading.
 external ImageProcessingPostProcess get imageProcessing; external set imageProcessing(ImageProcessingPostProcess v);
 /// Chromatic aberration post process which will shift rgb colors in the image
 external ChromaticAberrationPostProcess get chromaticAberration; external set chromaticAberration(ChromaticAberrationPostProcess v); external get JS$_chromaticAberrationEffect; external set JS$_chromaticAberrationEffect(v);
 /// Grain post process which add noise to the image
 external GrainPostProcess get grain; external set grain(GrainPostProcess v); external get JS$_grainEffect; external set JS$_grainEffect(v);
 /// Animations which can be used to tweak settings over a period of time
 external List<Animation> get animations; external set animations(List<Animation> v); external get JS$_imageProcessingConfigurationObserver; external set JS$_imageProcessingConfigurationObserver(v); external get JS$_sharpenEnabled; external set JS$_sharpenEnabled(v); external get JS$_bloomEnabled; external set JS$_bloomEnabled(v); external get JS$_depthOfFieldEnabled; external set JS$_depthOfFieldEnabled(v); external get JS$_depthOfFieldBlurLevel; external set JS$_depthOfFieldBlurLevel(v); external get JS$_fxaaEnabled; external set JS$_fxaaEnabled(v); external get JS$_imageProcessingEnabled; external set JS$_imageProcessingEnabled(v); external get JS$_defaultPipelineTextureType; external set JS$_defaultPipelineTextureType(v); external get JS$_bloomScale; external set JS$_bloomScale(v); external get JS$_chromaticAberrationEnabled; external set JS$_chromaticAberrationEnabled(v); external get JS$_grainEnabled; external set JS$_grainEnabled(v); external get JS$_buildAllowed; external set JS$_buildAllowed(v);
 /// Enable or disable the sharpen process from the pipeline
 external bool get sharpenEnabled; external set sharpenEnabled(bool v); external get JS$_resizeObserver; external set JS$_resizeObserver(v); external get JS$_hardwareScaleLevel; external set JS$_hardwareScaleLevel(v); external get JS$_bloomKernel; external set JS$_bloomKernel(v);
 /// Specifies the size of the bloom blur kernel, relative to the final output size
 external num get bloomKernel; external set bloomKernel(num v);
 /// Specifies the weight of the bloom in the final rendering
 external get JS$_bloomWeight; external set JS$_bloomWeight(v);
 /// Specifies the luma threshold for the area that will be blurred by the bloom
 external get JS$_bloomThreshold; external set JS$_bloomThreshold(v); external get JS$_hdr; external set JS$_hdr(v);
 /// The strength of the bloom.
 external num get bloomWeight; external set bloomWeight(num v);
 /// The strength of the bloom.
 external num get bloomThreshold; external set bloomThreshold(num v);
 /// The scale of the bloom, lower value will provide better performance.
 external num get bloomScale; external set bloomScale(num v);
 /// Enable or disable the bloom from the pipeline
 external bool get bloomEnabled; external set bloomEnabled(bool v); external JS$_rebuildBloom();
 /// If the depth of field is enabled.
 external bool get depthOfFieldEnabled; external set depthOfFieldEnabled(bool v);
 /// Blur level of the depth of field effect. (Higher blur will effect performance)
 external num/*enum DepthOfFieldEffectBlurLevel*/ get depthOfFieldBlurLevel; external set depthOfFieldBlurLevel(num/*enum DepthOfFieldEffectBlurLevel*/ v);
 /// If the anti aliasing is enabled.
 external bool get fxaaEnabled; external set fxaaEnabled(bool v); external get JS$_samples; external set JS$_samples(v);
 /// MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
 external num get samples; external set samples(num v);
 /// If image processing is enabled.
 external bool get imageProcessingEnabled; external set imageProcessingEnabled(bool v);
 /// Enable or disable the chromaticAberration process from the pipeline
 external bool get chromaticAberrationEnabled; external set chromaticAberrationEnabled(bool v);
 /// Enable or disable the grain process from the pipeline
 external bool get grainEnabled; external set grainEnabled(bool v);
 /// @constructor
 external factory DefaultRenderingPipeline(String name, bool hdr, Scene scene, [List<Camera> cameras, bool automaticBuild]);
 /// Force the compilation of the entire pipeline.
 external void prepare(); external get JS$_hasCleared; external set JS$_hasCleared(v); external get JS$_prevPostProcess; external set JS$_prevPostProcess(v); external get JS$_prevPrevPostProcess; external set JS$_prevPrevPostProcess(v); external JS$_setAutoClearAndTextureSharing(postProcess, [skipTextureSharing]); external JS$_buildPipeline(); external JS$_disposePostProcesses([disposeNonRecreated]);
 /// Dispose of the pipeline and stop all post processes
 external void dispose();
 /// Serialize the rendering pipeline (Used when exporting)
 external dynamic serialize();
 /// Parse the serialized pipeline
 external static DefaultRenderingPipeline Parse(dynamic source, Scene scene, String rootUrl); }

 @JS("BABYLON.LensRenderingPipeline" ) class LensRenderingPipeline extends PostProcessRenderPipeline { // @Ignore
 LensRenderingPipeline .fakeConstructor$() : super.fakeConstructor$() ;
 /// The chromatic aberration PostProcess id in the pipeline
 external String get LensChromaticAberrationEffect; external set LensChromaticAberrationEffect(String v);
 /// The highlights enhancing PostProcess id in the pipeline
 external String get HighlightsEnhancingEffect; external set HighlightsEnhancingEffect(String v);
 /// The depth-of-field PostProcess id in the pipeline
 external String get LensDepthOfFieldEffect; external set LensDepthOfFieldEffect(String v); external get JS$_scene; external set JS$_scene(v); external get JS$_depthTexture; external set JS$_depthTexture(v); external get JS$_grainTexture; external set JS$_grainTexture(v); external get JS$_chromaticAberrationPostProcess; external set JS$_chromaticAberrationPostProcess(v); external get JS$_highlightsPostProcess; external set JS$_highlightsPostProcess(v); external get JS$_depthOfFieldPostProcess; external set JS$_depthOfFieldPostProcess(v); external get JS$_edgeBlur; external set JS$_edgeBlur(v); external get JS$_grainAmount; external set JS$_grainAmount(v); external get JS$_chromaticAberration; external set JS$_chromaticAberration(v); external get JS$_distortion; external set JS$_distortion(v); external get JS$_highlightsGain; external set JS$_highlightsGain(v); external get JS$_highlightsThreshold; external set JS$_highlightsThreshold(v); external get JS$_dofDistance; external set JS$_dofDistance(v); external get JS$_dofAperture; external set JS$_dofAperture(v); external get JS$_dofDarken; external set JS$_dofDarken(v); external get JS$_dofPentagon; external set JS$_dofPentagon(v); external get JS$_blurNoise; external set JS$_blurNoise(v);
 /// @constructor
 /// Effect parameters are as follow:
 /// {
 /// chromatic_aberration: number;       // from 0 to x (1 for realism)
 /// edge_blur: number;                  // from 0 to x (1 for realism)
 /// distortion: number;                 // from 0 to x (1 for realism)
 /// grain_amount: number;               // from 0 to 1
 /// grain_texture: BABYLON.Texture;     // texture to use for grain effect; if unset, use random B&W noise
 /// dof_focus_distance: number;         // depth-of-field: focus distance; unset to disable (disabled by default)
 /// dof_aperture: number;               // depth-of-field: focus blur bias (default: 1)
 /// dof_darken: number;                 // depth-of-field: darken that which is out of focus (from 0 to 1, disabled by default)
 /// dof_pentagon: boolean;              // depth-of-field: makes a pentagon-like "bokeh" effect
 /// dof_gain: number;                   // depth-of-field: highlights gain; unset to disable (disabled by default)
 /// dof_threshold: number;              // depth-of-field: highlights threshold (default: 1)
 /// blur_noise: boolean;                // add a little bit of noise to the blur (default: true)
 /// }
 /// Note: if an effect parameter is unset, effect is disabled
 external factory LensRenderingPipeline(String name, dynamic parameters, Scene scene, [num ratio, List<Camera> cameras]); external void setEdgeBlur(num amount); external void disableEdgeBlur(); external void setGrainAmount(num amount); external void disableGrain(); external void setChromaticAberration(num amount); external void disableChromaticAberration(); external void setEdgeDistortion(num amount); external void disableEdgeDistortion(); external void setFocusDistance(num amount); external void disableDepthOfField(); external void setAperture(num amount); external void setDarkenOutOfFocus(num amount); external void enablePentagonBokeh(); external void disablePentagonBokeh(); external void enableNoiseBlur(); external void disableNoiseBlur(); external void setHighlightsGain(num amount); external void setHighlightsThreshold(num amount); external void disableHighlights();
 /// Removes the internal pipeline assets and detaches the pipeline from the scene cameras
 external void dispose([bool disableDepthRender]); external JS$_createChromaticAberrationPostProcess(ratio); external JS$_createHighlightsPostProcess(ratio); external JS$_createDepthOfFieldPostProcess(ratio); external JS$_createGrainTexture(); }

 @JS("BABYLON.SSAO2RenderingPipeline" ) class SSAO2RenderingPipeline extends PostProcessRenderPipeline { // @Ignore
 SSAO2RenderingPipeline .fakeConstructor$() : super.fakeConstructor$() ;
 /// The PassPostProcess id in the pipeline that contains the original scene color
 external String get SSAOOriginalSceneColorEffect; external set SSAOOriginalSceneColorEffect(String v);
 /// The SSAO PostProcess id in the pipeline
 external String get SSAORenderEffect; external set SSAORenderEffect(String v);
 /// The horizontal blur PostProcess id in the pipeline
 external String get SSAOBlurHRenderEffect; external set SSAOBlurHRenderEffect(String v);
 /// The vertical blur PostProcess id in the pipeline
 external String get SSAOBlurVRenderEffect; external set SSAOBlurVRenderEffect(String v);
 /// The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
 external String get SSAOCombineRenderEffect; external set SSAOCombineRenderEffect(String v);
 /// The output strength of the SSAO post-process. Default value is 1.0.
 external num get totalStrength; external set totalStrength(num v);
 /// Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.
 external num get maxZ; external set maxZ(num v);
 /// In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much
 external num get minZAspect; external set minZAspect(num v);
 /// Number of samples used for the SSAO calculations. Default value is 8
 external get JS$_samples; external set JS$_samples(v);
 /// Ratio object used for SSAO ratio and blur ratio
 external get JS$_ratio; external set JS$_ratio(v);
 /// Dynamically generated sphere sampler.
 external get JS$_sampleSphere; external set JS$_sampleSphere(v);
 /// Blur filter offsets
 external get JS$_samplerOffsets; external set JS$_samplerOffsets(v); external num get samples; external set samples(num v);
 /// Are we using bilateral blur ?
 external get JS$_expensiveBlur; external set JS$_expensiveBlur(v); external bool get expensiveBlur; external set expensiveBlur(bool v);
 /// The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0
 external num get radius; external set radius(num v);
 /// The base color of the SSAO post-process
 /// The final result is "base + ssao" between [0, 1]
 external num get base; external set base(num v);
 /// Support test.
 external static bool get IsSupported; external static set IsSupported(bool v); external get JS$_scene; external set JS$_scene(v); external get JS$_depthTexture; external set JS$_depthTexture(v); external get JS$_normalTexture; external set JS$_normalTexture(v); external get JS$_randomTexture; external set JS$_randomTexture(v); external get JS$_originalColorPostProcess; external set JS$_originalColorPostProcess(v); external get JS$_ssaoPostProcess; external set JS$_ssaoPostProcess(v); external get JS$_blurHPostProcess; external set JS$_blurHPostProcess(v); external get JS$_blurVPostProcess; external set JS$_blurVPostProcess(v); external get JS$_ssaoCombinePostProcess; external set JS$_ssaoCombinePostProcess(v); external get JS$_firstUpdate; external set JS$_firstUpdate(v);
 /// @constructor
 external factory SSAO2RenderingPipeline(String name, Scene scene, dynamic ratio, [List<Camera> cameras]);
 /// Removes the internal pipeline assets and detatches the pipeline from the scene cameras
 external void dispose([bool disableGeometryBufferRenderer]); external JS$_createBlurPostProcess(ssaoRatio, blurRatio); external void JS$_rebuild(); external JS$_generateHemisphere(); external JS$_createSSAOPostProcess(ratio); external JS$_createSSAOCombinePostProcess(ratio); external JS$_createRandomTexture();
 /// Serialize the rendering pipeline (Used when exporting)
 external dynamic serialize();
 /// Parse the serialized pipeline
 external static SSAO2RenderingPipeline Parse(dynamic source, Scene scene, String rootUrl); }

 @JS("BABYLON.SSAORenderingPipeline" ) class SSAORenderingPipeline extends PostProcessRenderPipeline { // @Ignore
 SSAORenderingPipeline .fakeConstructor$() : super.fakeConstructor$() ;
 /// The PassPostProcess id in the pipeline that contains the original scene color
 external String get SSAOOriginalSceneColorEffect; external set SSAOOriginalSceneColorEffect(String v);
 /// The SSAO PostProcess id in the pipeline
 external String get SSAORenderEffect; external set SSAORenderEffect(String v);
 /// The horizontal blur PostProcess id in the pipeline
 external String get SSAOBlurHRenderEffect; external set SSAOBlurHRenderEffect(String v);
 /// The vertical blur PostProcess id in the pipeline
 external String get SSAOBlurVRenderEffect; external set SSAOBlurVRenderEffect(String v);
 /// The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
 external String get SSAOCombineRenderEffect; external set SSAOCombineRenderEffect(String v);
 /// The output strength of the SSAO post-process. Default value is 1.0.
 external num get totalStrength; external set totalStrength(num v);
 /// The radius around the analyzed pixel used by the SSAO post-process. Default value is 0.0006
 external num get radius; external set radius(num v);
 /// Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel
 /// Must not be equal to fallOff and superior to fallOff.
 /// Default value is 0.975
 external num get area; external set area(num v);
 /// Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel
 /// Must not be equal to area and inferior to area.
 /// Default value is 0.0
 external num get fallOff; external set fallOff(num v);
 /// The base color of the SSAO post-process
 /// The final result is "base + ssao" between [0, 1]
 external num get base; external set base(num v); external get JS$_scene; external set JS$_scene(v); external get JS$_depthTexture; external set JS$_depthTexture(v); external get JS$_randomTexture; external set JS$_randomTexture(v); external get JS$_originalColorPostProcess; external set JS$_originalColorPostProcess(v); external get JS$_ssaoPostProcess; external set JS$_ssaoPostProcess(v); external get JS$_blurHPostProcess; external set JS$_blurHPostProcess(v); external get JS$_blurVPostProcess; external set JS$_blurVPostProcess(v); external get JS$_ssaoCombinePostProcess; external set JS$_ssaoCombinePostProcess(v); external get JS$_firstUpdate; external set JS$_firstUpdate(v);
 /// @constructor
 external factory SSAORenderingPipeline(String name, Scene scene, dynamic ratio, [List<Camera> cameras]);
 /// Removes the internal pipeline assets and detatches the pipeline from the scene cameras
 external void dispose([bool disableDepthRender]); external JS$_createBlurPostProcess(ratio); external void JS$_rebuild(); external JS$_createSSAOPostProcess(ratio); external JS$_createSSAOCombinePostProcess(ratio); external JS$_createRandomTexture(); }

 @JS("BABYLON.StandardRenderingPipeline" ) class StandardRenderingPipeline extends PostProcessRenderPipeline implements IDisposable, IAnimatable { // @Ignore
 StandardRenderingPipeline .fakeConstructor$() : super.fakeConstructor$() ;
 /// Public members
 external PostProcess/*PostProcess|Null*/ get originalPostProcess; external set originalPostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get downSampleX4PostProcess; external set downSampleX4PostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get brightPassPostProcess; external set brightPassPostProcess(PostProcess/*PostProcess|Null*/ v); external List<PostProcess> get blurHPostProcesses; external set blurHPostProcesses(List<PostProcess> v); external List<PostProcess> get blurVPostProcesses; external set blurVPostProcesses(List<PostProcess> v); external PostProcess/*PostProcess|Null*/ get textureAdderPostProcess; external set textureAdderPostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get volumetricLightPostProcess; external set volumetricLightPostProcess(PostProcess/*PostProcess|Null*/ v); external BlurPostProcess/*BlurPostProcess|Null*/ get volumetricLightSmoothXPostProcess; external set volumetricLightSmoothXPostProcess(BlurPostProcess/*BlurPostProcess|Null*/ v); external BlurPostProcess/*BlurPostProcess|Null*/ get volumetricLightSmoothYPostProcess; external set volumetricLightSmoothYPostProcess(BlurPostProcess/*BlurPostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get volumetricLightMergePostProces; external set volumetricLightMergePostProces(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get volumetricLightFinalPostProcess; external set volumetricLightFinalPostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get luminancePostProcess; external set luminancePostProcess(PostProcess/*PostProcess|Null*/ v); external List<PostProcess> get luminanceDownSamplePostProcesses; external set luminanceDownSamplePostProcesses(List<PostProcess> v); external PostProcess/*PostProcess|Null*/ get hdrPostProcess; external set hdrPostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get textureAdderFinalPostProcess; external set textureAdderFinalPostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get lensFlareFinalPostProcess; external set lensFlareFinalPostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get hdrFinalPostProcess; external set hdrFinalPostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get lensFlarePostProcess; external set lensFlarePostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get lensFlareComposePostProcess; external set lensFlareComposePostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get motionBlurPostProcess; external set motionBlurPostProcess(PostProcess/*PostProcess|Null*/ v); external PostProcess/*PostProcess|Null*/ get depthOfFieldPostProcess; external set depthOfFieldPostProcess(PostProcess/*PostProcess|Null*/ v); external num get brightThreshold; external set brightThreshold(num v); external num get blurWidth; external set blurWidth(num v); external bool get horizontalBlur; external set horizontalBlur(bool v); external num get exposure; external set exposure(num v); external Texture/*Texture|Null*/ get lensTexture; external set lensTexture(Texture/*Texture|Null*/ v); external num get volumetricLightCoefficient; external set volumetricLightCoefficient(num v); external num get volumetricLightPower; external set volumetricLightPower(num v); external num get volumetricLightBlurScale; external set volumetricLightBlurScale(num v); external dynamic/*SpotLight|DirectionalLight|Null*/ get sourceLight; external set sourceLight(dynamic/*SpotLight|DirectionalLight|Null*/ v); external num get hdrMinimumLuminance; external set hdrMinimumLuminance(num v); external num get hdrDecreaseRate; external set hdrDecreaseRate(num v); external num get hdrIncreaseRate; external set hdrIncreaseRate(num v); external Texture/*Texture|Null*/ get lensColorTexture; external set lensColorTexture(Texture/*Texture|Null*/ v); external num get lensFlareStrength; external set lensFlareStrength(num v); external num get lensFlareGhostDispersal; external set lensFlareGhostDispersal(num v); external num get lensFlareHaloWidth; external set lensFlareHaloWidth(num v); external num get lensFlareDistortionStrength; external set lensFlareDistortionStrength(num v); external Texture/*Texture|Null*/ get lensStarTexture; external set lensStarTexture(Texture/*Texture|Null*/ v); external Texture/*Texture|Null*/ get lensFlareDirtTexture; external set lensFlareDirtTexture(Texture/*Texture|Null*/ v); external num get depthOfFieldDistance; external set depthOfFieldDistance(num v); external num get depthOfFieldBlurWidth; external set depthOfFieldBlurWidth(num v); external num get motionStrength; external set motionStrength(num v); external List<Animation> get animations; external set animations(List<Animation> v);
 /// Private members
 external get JS$_scene; external set JS$_scene(v); external get JS$_currentDepthOfFieldSource; external set JS$_currentDepthOfFieldSource(v); external get JS$_basePostProcess; external set JS$_basePostProcess(v); external get JS$_hdrCurrentLuminance; external set JS$_hdrCurrentLuminance(v); external get JS$_floatTextureType; external set JS$_floatTextureType(v); external get JS$_ratio; external set JS$_ratio(v); external get JS$_bloomEnabled; external set JS$_bloomEnabled(v); external get JS$_depthOfFieldEnabled; external set JS$_depthOfFieldEnabled(v); external get JS$_vlsEnabled; external set JS$_vlsEnabled(v); external get JS$_lensFlareEnabled; external set JS$_lensFlareEnabled(v); external get JS$_hdrEnabled; external set JS$_hdrEnabled(v); external get JS$_motionBlurEnabled; external set JS$_motionBlurEnabled(v); external get JS$_motionBlurSamples; external set JS$_motionBlurSamples(v); external get JS$_volumetricLightStepsCount; external set JS$_volumetricLightStepsCount(v); external bool get BloomEnabled; external set BloomEnabled(bool v); external bool get DepthOfFieldEnabled; external set DepthOfFieldEnabled(bool v); external bool get LensFlareEnabled; external set LensFlareEnabled(bool v); external bool get HDREnabled; external set HDREnabled(bool v); external bool get VLSEnabled; external set VLSEnabled(bool v); external bool get MotionBlurEnabled; external set MotionBlurEnabled(bool v); external num get volumetricLightStepsCount; external set volumetricLightStepsCount(num v); external num get motionBlurSamples; external set motionBlurSamples(num v);
 /// @constructor
 external factory StandardRenderingPipeline(String name, Scene scene, num ratio, [PostProcess/*PostProcess|Null*/ originalPostProcess, List<Camera> cameras]); external JS$_buildPipeline(); external JS$_createDownSampleX4PostProcess(scene, ratio); external JS$_createBrightPassPostProcess(scene, ratio); external JS$_createBlurPostProcesses(scene, ratio, indice, [blurWidthKey]); external JS$_createTextureAdderPostProcess(scene, ratio); external JS$_createVolumetricLightPostProcess(scene, ratio); external JS$_createLuminancePostProcesses(scene, textureType); external JS$_createHdrPostProcess(scene, ratio); external JS$_createLensFlarePostProcess(scene, ratio); external JS$_createDepthOfFieldPostProcess(scene, ratio); external JS$_createMotionBlurPostProcess(scene, ratio); external JS$_getDepthTexture(); external JS$_disposePostProcesses();
 /// Dispose of the pipeline and stop all post processes
 external void dispose();
 /// Serialize the rendering pipeline (Used when exporting)
 external dynamic serialize();
 /// Parse the serialized pipeline
 external static StandardRenderingPipeline Parse(dynamic source, Scene scene, String rootUrl); external static num get LuminanceSteps; external static set LuminanceSteps(num v); }

 
// End module BABYLON
 
/* Skipping class Window*/
 
/* Skipping class WebGLRenderingContext*/
 
/* Skipping class Document*/
 
/* Skipping class HTMLCanvasElement*/
 
/* Skipping class CanvasRenderingContext2D*/
 
/* Skipping class WebGLBuffer*/
 
/* Skipping class WebGLProgram*/
 
/* Skipping class MouseEvent*/
 
/* Skipping class Navigator*/
 
/* Skipping class HTMLVideoElement*/
 
/* Skipping class Screen*/
 @anonymous @JS() abstract class Math { external num fround(num x); external num imul(num a, num b); }

 @anonymous @JS() abstract class EXT_disjoint_timer_query { external num get QUERY_COUNTER_BITS_EXT; external set QUERY_COUNTER_BITS_EXT(num v); external num get TIME_ELAPSED_EXT; external set TIME_ELAPSED_EXT(num v); external num get TIMESTAMP_EXT; external set TIMESTAMP_EXT(num v); external num get GPU_DISJOINT_EXT; external set GPU_DISJOINT_EXT(num v); external num get QUERY_RESULT_EXT; external set QUERY_RESULT_EXT(num v); external num get QUERY_RESULT_AVAILABLE_EXT; external set QUERY_RESULT_AVAILABLE_EXT(num v); external void queryCounterEXT(WebGLQuery query, num target); external WebGLQuery createQueryEXT(); external void beginQueryEXT(num target, WebGLQuery query); external void endQueryEXT(num target); external dynamic getQueryObjectEXT(WebGLQuery query, num target); external void deleteQueryEXT(WebGLQuery query); }

 
/* Skipping class WebGLUniformLocation*/
 @JS() external void importScripts([String urls1, String urls2, String urls3, String urls4, String urls5]); @JS() external dynamic get safePostMessage; @JS("VRDisplay" ) abstract class VRDisplay implements EventTarget { external VRDisplayCapabilities get capabilities; external set capabilities(VRDisplayCapabilities v); external num get depthFar; external set depthFar(num v); external num get depthNear; external set depthNear(num v); external num get displayId; external set displayId(num v); external String get displayName; external set displayName(String v); external bool get isConnected; external set isConnected(bool v); external bool get isPresenting; external set isPresenting(bool v); external VRStageParameters/*VRStageParameters|Null*/ get stageParameters; external set stageParameters(VRStageParameters/*VRStageParameters|Null*/ v); external void cancelAnimationFrame(num handle); external Promise<Null> exitPresent(); external VREyeParameters getEyeParameters(String whichEye); external bool getFrameData(VRFrameData frameData); external List<VRLayer> getLayers(); external VRPose getPose(); external VRPose getImmediatePose(); external num requestAnimationFrame(FrameRequestCallback callback); external Promise<Null> requestPresent(List<VRLayer> layers); external void resetPose(); external void submitFrame([VRPose pose]); external static VRDisplay get prototype; external static set prototype(VRDisplay v); external factory VRDisplay(); }

 @anonymous @JS() abstract class VRLayer { external List<num>/*List<num>|Null*/ get leftBounds; external set leftBounds(List<num>/*List<num>|Null*/ v); external List<num>/*List<num>|Null*/ get rightBounds; external set rightBounds(List<num>/*List<num>|Null*/ v); external CanvasElement/*CanvasElement|Null*/ get source; external set source(CanvasElement/*CanvasElement|Null*/ v); external factory VRLayer({ List<num>/*List<num>|Null*/ leftBounds, List<num>/*List<num>|Null*/ rightBounds, CanvasElement/*CanvasElement|Null*/ source}); }

 @anonymous @JS() abstract class VRDisplayCapabilities { external bool get canPresent; external set canPresent(bool v); external bool get hasExternalDisplay; external set hasExternalDisplay(bool v); external bool get hasOrientation; external set hasOrientation(bool v); external bool get hasPosition; external set hasPosition(bool v); external num get maxLayers; external set maxLayers(num v); external factory VRDisplayCapabilities({ bool canPresent, bool hasExternalDisplay, bool hasOrientation, bool hasPosition, num maxLayers}); }

 @anonymous @JS() abstract class VREyeParameters { external VRFieldOfView get fieldOfView; external set fieldOfView(VRFieldOfView v); external Float32List get offset; external set offset(Float32List v); external num get renderHeight; external set renderHeight(num v); external num get renderWidth; external set renderWidth(num v); external factory VREyeParameters({ VRFieldOfView fieldOfView, Float32List offset, num renderHeight, num renderWidth}); }

 @anonymous @JS() abstract class VRFieldOfView { external num get downDegrees; external set downDegrees(num v); external num get leftDegrees; external set leftDegrees(num v); external num get rightDegrees; external set rightDegrees(num v); external num get upDegrees; external set upDegrees(num v); external factory VRFieldOfView({ num downDegrees, num leftDegrees, num rightDegrees, num upDegrees}); }

 @anonymous @JS() abstract class VRFrameData { external Float32List get leftProjectionMatrix; external set leftProjectionMatrix(Float32List v); external Float32List get leftViewMatrix; external set leftViewMatrix(Float32List v); external VRPose get pose; external set pose(VRPose v); external Float32List get rightProjectionMatrix; external set rightProjectionMatrix(Float32List v); external Float32List get rightViewMatrix; external set rightViewMatrix(Float32List v); external num get timestamp; external set timestamp(num v); external factory VRFrameData({ Float32List leftProjectionMatrix, Float32List leftViewMatrix, VRPose pose, Float32List rightProjectionMatrix, Float32List rightViewMatrix, num timestamp}); }

 @anonymous @JS() abstract class VRPose { external Float32List/*Float32List|Null*/ get angularAcceleration; external set angularAcceleration(Float32List/*Float32List|Null*/ v); external Float32List/*Float32List|Null*/ get angularVelocity; external set angularVelocity(Float32List/*Float32List|Null*/ v); external Float32List/*Float32List|Null*/ get linearAcceleration; external set linearAcceleration(Float32List/*Float32List|Null*/ v); external Float32List/*Float32List|Null*/ get linearVelocity; external set linearVelocity(Float32List/*Float32List|Null*/ v); external Float32List/*Float32List|Null*/ get orientation; external set orientation(Float32List/*Float32List|Null*/ v); external Float32List/*Float32List|Null*/ get position; external set position(Float32List/*Float32List|Null*/ v); external num get timestamp; external set timestamp(num v); external factory VRPose({ Float32List/*Float32List|Null*/ angularAcceleration, Float32List/*Float32List|Null*/ angularVelocity, Float32List/*Float32List|Null*/ linearAcceleration, Float32List/*Float32List|Null*/ linearVelocity, Float32List/*Float32List|Null*/ orientation, Float32List/*Float32List|Null*/ position, num timestamp}); }

 @anonymous @JS() abstract class VRStageParameters { external Float32List get sittingToStandingTransform; external set sittingToStandingTransform(Float32List v); external num get sizeX; external set sizeX(num v); external num get sizeY; external set sizeY(num v); external factory VRStageParameters({ Float32List sittingToStandingTransform, num sizeX, num sizeY}); }

 
/* Skipping class Window*/
 
/* Skipping class Gamepad*/
 @anonymous @JS() abstract class ImageBitmap { external num get width; external set width(num v); external num get height; external set height(num v); external void close(); }

 @JS("WebGLQuery" ) abstract class WebGLQuery implements WebGLObject { external static WebGLQuery get prototype; external static set prototype(WebGLQuery v); external factory WebGLQuery(); }

 @JS("WebGLSampler" ) abstract class WebGLSampler implements WebGLObject { external static WebGLSampler get prototype; external static set prototype(WebGLSampler v); external factory WebGLSampler(); }

 @JS("WebGLSync" ) abstract class WebGLSync implements WebGLObject { external static WebGLSync get prototype; external static set prototype(WebGLSync v); external factory WebGLSync(); }

 @JS("WebGLTransformFeedback" ) abstract class WebGLTransformFeedback implements WebGLObject { external static WebGLTransformFeedback get prototype; external static set prototype(WebGLTransformFeedback v); external factory WebGLTransformFeedback(); }

 @JS("WebGLVertexArrayObject" ) abstract class WebGLVertexArrayObject implements WebGLObject { external static WebGLVertexArrayObject get prototype; external static set prototype(WebGLVertexArrayObject v); external factory WebGLVertexArrayObject(); }

 @JS() external dynamic get DracoDecoderModule; @JS() external set DracoDecoderModule(dynamic v); @JS() external dynamic get WebAssembly; @JS() external set WebAssembly(dynamic v);